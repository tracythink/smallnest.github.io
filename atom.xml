<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[鸟窝]]></title>
  <subtitle><![CDATA[大道至简 Simplicity is the ultimate form of sophistication]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://colobu.com/"/>
  <updated>2016-06-27T08:10:33.070Z</updated>
  <id>http://colobu.com/</id>
  
  <author>
    <name><![CDATA[smallnest]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[深入Go语言 - 7]]></title>
    <link href="http://colobu.com/2016/06/22/dive-into-go-7/"/>
    <id>http://colobu.com/2016/06/22/dive-into-go-7/</id>
    <published>2016-06-22T08:26:47.000Z</published>
    <updated>2016-06-27T08:10:04.000Z</updated>
    <content type="html"><![CDATA[<p>本章介绍Go语言的语句，重点介绍goroutine的相关知识。</p>
<a id="more"></a>
<p>Go语言的语法定义罗列了所有的语句类型:</p>
<pre class="highlight">
Statement =
    Declaration | LabeledStmt | SimpleStmt |
    GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |
    FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |
    DeferStmt .

SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .
</pre>


<p>语句控制程序逻辑的运行。终止语句(terminating statement)代表结束当前程序逻辑单元的运行。<br>1、 A &quot;return&quot; or &quot;goto&quot; statement.<br>2、A call to the built-in function panic.<br>3、A block in which the statement list ends in a terminating statement.<br>4、 An &quot;if&quot; statement in which:<br>＊ the &quot;else&quot; branch is present, and<br>＊ both branches are terminating statements.<br>5、A &quot;for&quot; statement in which:<br>＊ there are no &quot;break&quot; statements referring to the &quot;for&quot; statement, and<br>＊ the loop condition is absent.<br>6、A &quot;switch&quot; statement in which:<br>＊ there are no &quot;break&quot; statements referring to the &quot;switch&quot; statement,<br>＊ there is a default case, and<br>＊ the statement lists in each case, including the default, end in a terminating statement, or a possibly labeled &quot;fallthrough&quot; statement.<br>7、A &quot;select&quot; statement in which:<br>＊ there are no &quot;break&quot; statements referring to the &quot;select&quot; statement, and<br>＊ the statement lists in each case, including the default if present, end in a terminating statement.<br>8、A labeled statement labeling a terminating statement.</p>
<p>其它的语句都不会终止程序单元的执行。</p>
<p>参考</p>
<ul>
<li><a href="https://github.com/golang/go/issues/14422" target="_blank" rel="external">https://github.com/golang/go/issues/14422</a></li>
<li><a href="https://github.com/golang/go/issues/14537" target="_blank" rel="external">https://github.com/golang/go/issues/14537</a></li>
</ul>
<h3 id="空语句">空语句</h3>
<p>空语句不错任何事</p>
<h3 id="标签语句">标签语句</h3>
<p>增加一个标签， 为 goto、break、continue 使用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error: log.Panic(<span class="string">"error encountered"</span>)</div></pre></td></tr></table></figure>

<h3 id="表达式语句">表达式语句</h3>
<p>除了特别的内置函数， 一般函数和方法调用、receive 操作都可以出现在语句的上下文中，<br>这样的语句可以用括号括起来。</p>
<p>下面的内置的函数不能在语句中：</p>
<pre class="highlight">
append cap complex imag len make new real
unsafe.Alignof unsafe.Offsetof unsafe.Sizeof
</pre>

<p>下面的操作都可以作为语句：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">h(x+y)</div><div class="line">f.Close()</div><div class="line">&lt;-ch</div><div class="line">(&lt;-ch)</div></pre></td></tr></table></figure>

<p>但是下面的内置函数调用就不可以:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">len</span>(<span class="string">"foo"</span>) <span class="comment">//错误</span></div></pre></td></tr></table></figure>

<h3 id="send语句">send语句</h3>
<p>可以通过send的语句往channel发送一个值。</p>
<h3 id="自增和自减语句">自增和自减语句</h3>
<p>注意，Go语言中&quot;++&quot;和&quot;--&quot;是语句(statement)，而不是表达式(expression)，并且只能放在操作数的后面(postfix)。操作数必须是可寻址的或者是map索引表达式。</p>
<p><code>x++</code> 等价于 <code>x += 1</code>，<code>x--</code> 等价于 <code>x -= 1</code>。</p>
<p>因为它们不是表达式，所以不能以表达式的方式给其它变量赋值，下面的代码是错误的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span>{<span class="string">"1"</span>:<span class="number"> 1</span>, <span class="string">"2"</span>:<span class="number"> 2</span>}</div><div class="line">m[<span class="string">"1"</span>]++</div><div class="line"></div><div class="line">i :=<span class="number"> 0</span></div><div class="line">i++</div><div class="line"></div><div class="line"><span class="keyword">var</span> j = i++ <span class="comment">//错误</span></div></pre></td></tr></table></figure>

<h3 id="赋值语句">赋值语句</h3>
<p>赋值语句左边的操作数必须是可寻址的、或者是map索引表达式、抑或是空标识符_。</p>
<p>操作数可以用括号括起来，不管是左边的操作数还是右边的操作数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i, j <span class="typename">int</span></div><div class="line">(i), (j) = <span class="number">(3</span>),<span class="number"> 4</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> k <span class="typename">int</span></div><div class="line">(k) = i</div><div class="line">_, _, _ = i, j, k</div></pre></td></tr></table></figure>

<p>复合的赋值操作 <code>x op= y</code>等价于<code>x = x op (y)</code>,但是x只会被计算一次。运算符的左右两边只能是单值的表达式，而且左边的操作符不能是空标识符。</p>
<p>前面也有代码举例，Go支持多值赋值(tuple)，左边的操作数的数量必须和右边的值的数量相同。</p>
<p>赋值过程分为两阶段：</p>
<ol>
<li>计算左边的索引表达式的操作数和指针， 右边的表达式</li>
<li>从左到右赋值</li>
</ol>
<p>下面是赋值语句的一些例子，你可以琢磨琢磨。</p>
<pre class="highlight">
a, b = b, a  // exchange a and b

x := []int{1, 2, 3}
i := 0
i, x[i] = 1, 2  // set i = 1, x[0] = 2

i = 0
x[i], i = 2, 1  // set x[0] = 2, i = 1

x[0], x[0] = 1, 2  // set x[0] = 1, then x[0] = 2 (so x[0] == 2 at end)

x[1], x[3] = 4, 5  // set x[1] = 4, then panic setting x[3] = 5.

type Point struct { x, y int }
var p *Point
x[2], p.x = 6, 7  // set x[2] = 6, then panic setting p.x = 7

i = 2
x = []int{3, 5, 7}
for i, x[i] = range x {  // set i, x[2] = 0, x[0]
    break
}
// after this loop, i == 0 and x == []int{3, 5, 3}
</pre>

<h3 id="if_语句">if 语句</h3>
<p>if语句类似其它语言中比如Java、C的if语句，但是也有不同：<br>1、if语句中的条件表达式可以有简单的语句:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> x := f(); x &lt; y {</div><div class="line">	<span class="keyword">return</span> x</div><div class="line">} <span class="keyword">else</span> <span class="keyword">if</span> x &gt; z {</div><div class="line">	<span class="keyword">return</span> z</div><div class="line">} <span class="keyword">else</span> {</div><div class="line">	<span class="keyword">return</span> y</div><div class="line">}</div></pre></td></tr></table></figure>

<p>2、代码块必须以大括号括起来，即使是单行代码块不能省略大括号</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> x &gt; max</div><div class="line">  x = max  <span class="comment">//错误</span></div></pre></td></tr></table></figure>

<p>3、if 中的条件表达式可以省略括号，而且一般都省略括号</p>
<h3 id="switch_语句">switch 语句</h3>
<p>switch提供了多路处理的机制。switch有两种：表达式switch和type switch。 类型switch在前一章中已经介绍了，本节只介绍表达式switch。</p>
<p>表达式switch(以下直接叫switch)中的表达式会被计算，然后和case clause进行比较。case clause中的表达式不一定是常数。表达式的计算都是从左到右，从上而下的计算的。</p>
<p>如果遇到第一个满足的case，其它的case就不会执行，如果没有满足条件的case,并且有一个default的case的话，会执行default代码块，相当于default用来兜底。最多有一个default，而且一般都将它放在底部，尽管它的位置和其它case cluase没有顺序限制。</p>
<p>在case表达式中，对于未声明类型的bool常量，它首先会被转换成bool类型，对于其它常量，会被转换成缺省类型进行比较。</p>
<p>编译器可能不允许有重复的 case 常量 clause,但是非常量的表达式可以：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	i :=<span class="number"> 4</span></div><div class="line"></div><div class="line">	<span class="keyword">switch</span> i {</div><div class="line">	<span class="keyword">case</span><span class="number"> 1</span>:</div><div class="line">		fmt.Println<span class="number">(1</span>)</div><div class="line">	<span class="keyword">case</span><span class="number"> 2</span>:</div><div class="line">		fmt.Println<span class="number">(2</span>)</div><div class="line">	<span class="keyword">case</span> f():</div><div class="line">		fmt.Println(<span class="string">"f"</span>)</div><div class="line">	<span class="keyword">case</span><span class="number"> 4</span>:</div><div class="line">		fmt.Println<span class="number">(4</span>)</div><div class="line"></div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		fmt.Println(<span class="string">"unknown"</span>)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> f() <span class="typename">int</span> {</div><div class="line">	<span class="keyword">return</span><span class="number"> 4</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>fallthrough</code>语句可以是case语句或者default的代码块的最后一个语句，只要当前的case语句或者default语句不是最后一个case语句。 但是<code>fallthrough</code>不能出现在代码块的中间(非最后一个语句)。</p>
<p><code>fallthrough</code>将直接跳到下一个case clause的代码块的第一个语句中，不会和那个case 表达式再进行比较。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">i :=<span class="number"> 1</span></div><div class="line"></div><div class="line"><span class="keyword">switch</span> i {</div><div class="line"><span class="keyword">case</span><span class="number"> 1</span>:</div><div class="line">	fmt.Println<span class="number">(1</span>)</div><div class="line">	<span class="keyword">fallthrough</span></div><div class="line">	<span class="comment">//fmt.Println("after fallthrough") //错误</span></div><div class="line"><span class="keyword">case</span><span class="number"> 2</span>:</div><div class="line">	fmt.Println<span class="number">(2</span>)</div><div class="line"><span class="keyword">case</span><span class="number"> 3</span>:</div><div class="line">	fmt.Println<span class="number">(3</span>)</div><div class="line"><span class="keyword">default</span>:</div><div class="line">	fmt.Println(<span class="string">"unknown"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的代码输出 1 和 2。</p>
<p>switch 表达式的前面可以有简单的表达式，它在switch表达式计算之前执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> x := f(); x<span class="number">&gt;0</span> {</div><div class="line">	<span class="keyword">case</span> <span class="constant">true</span>:</div><div class="line">}</div></pre></td></tr></table></figure>

<p>switch表达式也可以省略，省略的时候意味着表达式为 true，所以会进入case 表达式为true的代码块：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> {</div><div class="line"><span class="keyword">case</span> x &lt; y: f1()</div><div class="line"><span class="keyword">case</span> x &lt; z: f2()</div><div class="line"><span class="keyword">case</span> x ==<span class="number"> 4</span>: f3()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>switch表达式也一般省略括号。</p>
<h3 id="for_语句">for 语句</h3>
<p>for 语句也不用括号,而且在三段式的for语句中，加上括号反而报错。</p>
<p>Go扩展了其它语言中的for语句饿功能，它有以下的形式：</p>
<p>1、普通的三段式的for语句 <code>for init; condition; post {……}</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 10</span>; i++ {</div><div class="line">	fmt.Println(i)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>其中的三段中的任意部分都可以省略，但是分号不能省略。</p>
<p>2、只包含条件表达式的for语句 <code>for condition {}</code><br>Go语言中没有while语句，所以for的这种形式类似while语句。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">i :=<span class="number"> 0</span></div><div class="line"><span class="keyword">for</span> i &lt;<span class="number"> 10</span> {</div><div class="line">	i++</div><div class="line">}</div></pre></td></tr></table></figure>

<p>3、for ... range语句<br>对于数组、slice、字符串、map对象以及 从channel中接收的值，可以使用这种语句进行遍历。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = []<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>,<span class="number"> 4</span>,<span class="number"> 5</span>}</div><div class="line"></div><div class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> s {</div><div class="line">	fmt.Printf(<span class="string">"index: %d, value: %d\n"</span>, i, v)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>对于不同的类型， range迭代的结果可能是一个值，也可能是两个值。具体如下：</p>
<table>
<thead>
<tr>
<th>Range 表达式</th>
<th>第一个值</th>
<th>第二个值</th>
</tr>
</thead>
<tbody>
<tr>
<td>array or slice  a  [n]E, *[n]E, or []E</td>
<td>index    i  int</td>
<td>a[i]       E</td>
</tr>
<tr>
<td>string          s  string type</td>
<td>index    i  int</td>
<td>see below  rune</td>
</tr>
<tr>
<td>map             m  map[K]V</td>
<td>key      k  K</td>
<td>m[k]       V</td>
</tr>
<tr>
<td>channel         c  chan E, &lt;-chan E</td>
<td>element  e  E</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>4、 无任何条件和语句的 for</p>
<figure class="highlight for"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="constant">i</span> := 10</div><div class="line">for {</div><div class="line">	i++</div><div class="line">	if i &gt; 20 {</div><div class="line">		break</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li>对于数组，数组指针、slice，索引从0开始，止于 len(a) -1</li>
<li>对于字符串， range将迭代unicode code point，而不是字节byte, 因此索引值为当前unicode字符的起始位置，值为rune。如果不是unicode字符，第二个值为0xFFFD</li>
<li>对于map的迭代每次迭代可能不同。入股迭代的过程中还没有被访问的对象被移除了，后续的迭代中不会出现这些删除的值。如果迭代的过程中往map中增加值，则增加的值可能出现后续的迭代中，也可能不出现。</li>
<li>对于channel,迭代一直会执行，直到channel被关闭。如果channel为nil,则range表达式永远被阻塞，一定要注意。</li>
</ul>
<h3 id="select_语句">select 语句</h3>
<p>select语句从一组<a href="https://golang.org/ref/spec#Send_statements" target="_blank" rel="external">send</a>操作和<a href="https://golang.org/ref/spec#Receive_operator" target="_blank" rel="external">receive</a>操作中选择一个执行。</p>
<p>它类似switch但是只用来对channel进行操作。</p>
<ul>
<li>channel操作数如果是一个表达式，那么表达式只会被计算一次</li>
<li>如果有多个case可以被执行，只有一个case会被选择执行。选择算法是伪随机算法。如果没有case可以执行，并且有一个default case,则这个default会被选择执行， 如果没有default, select会被阻塞直到有一个case可以被执行。</li>
</ul>
<p>select一次只有一个case会执行，所以很多情况下我们把它放入到一个 for循环中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a []<span class="typename">int</span></div><div class="line"><span class="keyword">var</span> c, c1, c2, c3, c4 <span class="keyword">chan</span> <span class="typename">int</span></div><div class="line"><span class="keyword">var</span> i1, i2 <span class="typename">int</span></div><div class="line"><span class="keyword">select</span> {</div><div class="line"><span class="keyword">case</span> i1 = &lt;-c1:</div><div class="line"> <span class="built_in">print</span>(<span class="string">"received "</span>, i1, <span class="string">" from c1\n"</span>)</div><div class="line"><span class="keyword">case</span> c2 &lt;- i2:</div><div class="line"> <span class="built_in">print</span>(<span class="string">"sent "</span>, i2, <span class="string">" to c2\n"</span>)</div><div class="line"><span class="keyword">case</span> i3, ok := (&lt;-c3):  <span class="comment">// same as: i3, ok := &lt;-c3</span></div><div class="line"> <span class="keyword">if</span> ok {</div><div class="line">	 <span class="built_in">print</span>(<span class="string">"received "</span>, i3, <span class="string">" from c3\n"</span>)</div><div class="line"> } <span class="keyword">else</span> {</div><div class="line">	 <span class="built_in">print</span>(<span class="string">"c3 is closed\n"</span>)</div><div class="line"> }</div><div class="line"><span class="keyword">case</span> a[f()] = &lt;-c4:</div><div class="line"> <span class="comment">// same as:</span></div><div class="line"> <span class="comment">// case t := &lt;-c4</span></div><div class="line"> <span class="comment">//	a[f()] = t</span></div><div class="line"><span class="keyword">default</span>:</div><div class="line"> <span class="built_in">print</span>(<span class="string">"no communication\n"</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">for</span> {  <span class="comment">// send random sequence of bits to c</span></div><div class="line"> <span class="keyword">select</span> {</div><div class="line"> <span class="keyword">case</span> c &lt;-<span class="number"> 0</span>:  <span class="comment">// note: no statement, no fallthrough, no folding of cases</span></div><div class="line"> <span class="keyword">case</span> c &lt;-<span class="number"> 1</span>:</div><div class="line"> }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">select</span> {}  <span class="comment">// block forever</span></div></pre></td></tr></table></figure>

<p>select 语句也经常加入超时的case:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">  c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">string</span>,<span class="number"> 1</span>)</div><div class="line">  <span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">      time.Sleep(time.Second *<span class="number"> 2</span>)</div><div class="line">      c1 &lt;- <span class="string">"result 1"</span></div><div class="line">  }()</div><div class="line"></div><div class="line"><span class="comment">//执行超时case</span></div><div class="line">  <span class="keyword">select</span> {</div><div class="line">  <span class="keyword">case</span> res := &lt;-c1:</div><div class="line">      fmt.Println(res)</div><div class="line">  <span class="keyword">case</span> &lt;-time.After(time.Second *<span class="number"> 1</span>):</div><div class="line">      fmt.Println(<span class="string">"timeout 1"</span>)</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="comment">//执行C2</span></div><div class="line">  c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">string</span>,<span class="number"> 1</span>)</div><div class="line">  <span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">      time.Sleep(time.Second *<span class="number"> 2</span>)</div><div class="line">      c2 &lt;- <span class="string">"result 2"</span></div><div class="line">  }()</div><div class="line">  <span class="keyword">select</span> {</div><div class="line">  <span class="keyword">case</span> res := &lt;-c2:</div><div class="line">      fmt.Println(res)</div><div class="line">  <span class="keyword">case</span> &lt;-time.After(time.Second *<span class="number"> 3</span>):</div><div class="line">      fmt.Println(<span class="string">"timeout 2"</span>)</div><div class="line">  }</div></pre></td></tr></table></figure>

<h3 id="return_语句">return 语句</h3>
<p>return语句从函数中返回。</p>
<p>如果函数没有返回类型， return语句不能返回任何值。</p>
<p>如果函数有返回类型，那么有几种情况<br>1、返回值可以显示地写在return的后面,每个表达式必须是单值的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> simpleF() <span class="typename">int</span> {</div><div class="line">	<span class="keyword">return</span><span class="number"> 2</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> complexF1() (re <span class="typename">float64</span>, im <span class="typename">float64</span>) {</div><div class="line">	<span class="keyword">return</span><span class="number"> -7.0</span>,<span class="number"> -4.0</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>2、return语句中的表达式列表可以是对返回多只函数的调用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> complexF2() (re <span class="typename">float64</span>, im <span class="typename">float64</span>) {</div><div class="line">	<span class="keyword">return</span> complexF1()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>3、如果函数的返回类型参数指定了名字，则return 可以返回空。这些返回类型参数就像本地变量一样。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> complexF3() (re <span class="typename">float64</span>, im <span class="typename">float64</span>) {</div><div class="line">	re =<span class="number"> 7.0</span></div><div class="line">	im =<span class="number"> 4.0</span></div><div class="line">	<span class="keyword">return</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (devnull) Write(p []<span class="typename">byte</span>) (n <span class="typename">int</span>, _ error) {</div><div class="line">	n = <span class="built_in">len</span>(p)</div><div class="line">	<span class="keyword">return</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>所有的结果值在函数的开始时都被初始化为它们的零值。</p>
<p>编译器可能不允许下面的scope中的return返回空：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> f(n <span class="typename">int</span>) (res <span class="typename">int</span>, err error) {</div><div class="line">	<span class="keyword">if</span> _, err := f(n<span class="number">-1</span>); err != <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span>  <span class="comment">// invalid return statement: err is shadowed</span></div><div class="line">	}</div><div class="line">	<span class="keyword">return</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="break_语句">break 语句</h3>
<p>break用来终止执行最内层的 for、 switch 或者 select语句。</p>
<p>如果break后面跟着一个标签，则标签应该紧贴着要终止的for、switch或者selector语句，下面的代码中 break label2就是错的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">label2:</div><div class="line">	i :=<span class="number"> 10</span></div><div class="line"></div><div class="line">label1:</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		i++</div><div class="line">		<span class="keyword">if</span> i &gt;<span class="number"> 20</span> {</div><div class="line">			<span class="keyword">break</span> label1</div><div class="line">		}</div><div class="line">		fmt.Println(i)</div><div class="line">		<span class="keyword">if</span> i &lt;<span class="number"> 10</span> {</div><div class="line">			<span class="keyword">break</span> label2</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<p>为什么要用标签呢？因为不带标签的break只能终止最内层(innermost)的循环，如果像终止外部的循环，就得用标签了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">label1:</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		fmt.Println(<span class="string">"hello"</span>)</div><div class="line">		<span class="keyword">for</span> {</div><div class="line">			fmt.Println(<span class="string">"world"</span>)</div><div class="line">			<span class="keyword">break</span> label1</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<h3 id="continue_语句">continue 语句</h3>
<p>continue语句开始最内层的 for循环的下一次迭代，终止本次迭代。</p>
<p>同样，如果后面跟着标签，将开始外层的标签指定的for循环的下一次迭代。</p>
<h3 id="goto语句">goto语句</h3>
<p>goto跳转太强大，在很多语言中虽然都提供但是不推荐使用，Go也一样。</p>
<p>下面的goto是不允许的，因为标签L跳过了变量v等声明和赋值，如果后面的代码访问v会有问题。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">goto</span> L  <span class="comment">// BAD</span></div><div class="line">	v :=<span class="number"> 3</span></div><div class="line">L:</div></pre></td></tr></table></figure>

<p>代码块外部的goto不能跳到一个代码块内部的标签上:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> n<span class="number">%2</span> ==<span class="number"> 1</span> {</div><div class="line">	<span class="keyword">goto</span> L1</div><div class="line">}</div><div class="line"><span class="keyword">for</span> n &gt;<span class="number"> 0</span> {</div><div class="line">	f()</div><div class="line">	n--</div><div class="line">L1:</div><div class="line">	f()</div><div class="line">	n--</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="defer_语句">defer 语句</h3>
<p>defer语句调用一个函数，这个函数将会在当前函数返回的时候才被调用，货站当前函数执行了一个return语句，或者发生panic。</p>
<p>无论是否有panic， defer函数都会调用。</p>
<p>函数可以是普通函数或者方法。调用内置函数有限制，限制条件和上面的表达式语句一样。</p>
<p>当defer语句执行时，函数的参数就会被计算一次，但是函数还没有被调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">i :=<span class="number"> 0</span></div><div class="line"></div><div class="line"><span class="keyword">defer</span> <span class="keyword">func</span>(i <span class="typename">int</span>) {</div><div class="line">	fmt.Printf(<span class="string">"defer: %d\n"</span>, i)</div><div class="line">}(i)</div><div class="line"></div><div class="line">i =<span class="number"> 50</span></div><div class="line"></div><div class="line"><span class="keyword">defer</span> <span class="keyword">func</span>(i <span class="typename">int</span>) {</div><div class="line">	fmt.Printf(<span class="string">"defer: %d\n"</span>, i) <span class="comment">//50</span></div><div class="line">}(i)</div><div class="line"></div><div class="line">i =<span class="number"> 100</span></div></pre></td></tr></table></figure>

<p>当一个函数中有多个defer语句时，最后的defer语句中函数最先被执行，也就是defer函数的执行是和它的定义成反序。比如上面的代码先输出50,再输出0.</p>
<p>defer语句中函数也可以有返回值，但是返回值会被忽略。</p>
<p>defer语句中如果定义了一个函数字面量(匿名函数)，而且函数中对外部的函数返回参数有所修改的话，修改结果会生效，比如下面的结果，虽然函数最后一个语句返回0,但是defer函数又修改了result的结果，所以f的最终结果为1。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// f 返回 1</span></div><div class="line"><span class="keyword">func</span> f() (result <span class="typename">int</span>) {</div><div class="line">	<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">		result++</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span><span class="number"> 0</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="go_语句">go 语句</h3>
<p>go语句将一个函数调用在一个新的goroutine中独立执行。</p>
<p>goroutine是值得仔细介绍的内容，而且goroutine 调度也非常的有趣，这会在下一章中独立介绍。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本章介绍Go语言的语句，重点介绍goroutine的相关知识。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入Go语言 - 6]]></title>
    <link href="http://colobu.com/2016/06/21/dive-into-go-6/"/>
    <id>http://colobu.com/2016/06/21/dive-into-go-6/</id>
    <published>2016-06-21T09:25:44.000Z</published>
    <updated>2016-06-23T10:11:32.000Z</updated>
    <content type="html"><![CDATA[<p>本文介绍 类型转换(Conversion)、类型断言(type assertion) 和类型切换（type switch)。</p>
<p>这三个概念类似但是又完全不同。</p>
<a id="more"></a>
<h3 id="类型转换_Conversion">类型转换 Conversion</h3>
<p>将一个值x转换成特定类型T,格式为 <code>T(x)</code>,非常的简单，类型加小括号即可。</p>
<p>如果类型T以 *、&lt;-、func(不带结果列表)，未避免造成歧义，需要将类型括号包裹起来： <code>(T)(x)</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">*Point(p)        <span class="comment">// same as *(Point(p))</span></div><div class="line">(*Point)(p)      <span class="comment">// p is converted to *Point</span></div><div class="line">&lt;-<span class="keyword">chan</span> <span class="typename">int</span>(c)    <span class="comment">// same as &lt;-(chan int(c))</span></div><div class="line">(&lt;-<span class="keyword">chan</span> <span class="typename">int</span>)(c)  <span class="comment">// c is converted to &lt;-chan int</span></div><div class="line"><span class="keyword">func</span>()(x)        <span class="comment">// function signature func() x</span></div><div class="line">(<span class="keyword">func</span>())(x)      <span class="comment">// x is converted to func()</span></div><div class="line">(<span class="keyword">func</span>() <span class="typename">int</span>)(x)  <span class="comment">// x is converted to func() int</span></div><div class="line"><span class="keyword">func</span>() <span class="typename">int</span>(x)    <span class="comment">// x is converted to func() int (unambiguous)</span></div></pre></td></tr></table></figure>

<p>并不是任意的值都可以转换成类型T, 它需要遵循一定的规则，下面一一道来。</p>
<p>对于一个常量值x, 如果能转换成T类型的值，它需要满足下面的条件之一:</p>
<h4 id="转换常量值">转换常量值</h4>
<ul>
<li>x 可以表达为T的值</li>
<li>x 是浮点数值， T是浮点类型。 x 使用 IEEE 754 round-to-even 规则 且 IEEE -0.0 会进一步舍入到无符号的 0.0， 经过舍入后的x可以表示为T。这一条主要约束浮点数取整的规则，并不是完全按照四舍五入规则计算的。</li>
<li>x是一个整数而T是字符串类型</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="typename">uint</span>(<span class="constant">iota</span>)               <span class="comment">// iota value of type uint</span></div><div class="line"><span class="typename">float32</span><span class="number">(2.718281828</span>)     <span class="comment">// 2.718281828 of type float32</span></div><div class="line"><span class="typename">complex128</span><span class="number">(1</span>)            <span class="comment">// 1.0 + 0.0i of type complex128</span></div><div class="line"><span class="typename">float32</span><span class="number">(0.49999999</span>)      <span class="comment">// 0.5 of type float32</span></div><div class="line"><span class="typename">float64</span><span class="number">(-1e-1000</span>)        <span class="comment">// 0.0 of type float64</span></div><div class="line"><span class="typename">string</span>(<span class="string">'x'</span>)              <span class="comment">// "x" of type string</span></div><div class="line"><span class="typename">string</span><span class="number">(0</span>x266c)           <span class="comment">// "♬" of type string</span></div><div class="line">MyString(<span class="string">"foo"</span> + <span class="string">"bar"</span>)  <span class="comment">// "foobar" of type MyString</span></div><div class="line"><span class="typename">string</span>([]<span class="typename">byte</span>{<span class="string">'a'</span>})      <span class="comment">// not a constant: []byte{'a'} is not a constant</span></div><div class="line">(*<span class="typename">int</span>)(<span class="constant">nil</span>)              <span class="comment">// not a constant: nil is not a constant, *int is not a boolean, numeric, or string type</span></div><div class="line"><span class="typename">int</span><span class="number">(1.2</span>)                 <span class="comment">// illegal: 1.2 cannot be represented as an int</span></div><div class="line"><span class="typename">string</span><span class="number">(65.0</span>)             <span class="comment">// illegal: 65.0 is not an integer constant</span></div></pre></td></tr></table></figure>

<h4 id="转换变量值">转换变量值</h4>
<p>对于一个常量值x, 如果能转换成T类型的值，它需要满足下面的条件之一:</p>
<ul>
<li>x可以<a href="https://golang.org/ref/spec#Assignability" target="_blank" rel="external">赋值</a>给 T</li>
<li>x的类型和T的底层类型 类型一致</li>
<li>x类型和T 都是未命名的指针类型，它们的指针指向的对象类型 类型一致</li>
<li>x的类型和T都是整数或者浮点数</li>
<li>x的类型和T都是复数</li>
<li>x是整数、slice of byte、slice of rune, T是字符串类型</li>
<li>x是字符串， T是slice of byte 或者slice of rune</li>
</ul>
<p>数值类型和字符串之间的转换可能会改变x的呈现并且会带来运行时的花费。<br>其它的转换只是改变x的类型，不会改变x的呈现。</p>
<p>并没有直接整数和指针之间的转换。但是在前面的章节中也举例了，指针可以通过曲折的方式转换成整数，<br>它是通过包<code>unsafe</code>实现的， 甚至于你通过这种方式还可以访问struct未导出的字段。</p>
<p>类型不一致的两个变量不能赋值, 并且也没有什么强制类型转换的概念：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i1 <span class="typename">int8</span> =<span class="number"> 10</span></div><div class="line"><span class="keyword">var</span> i2 <span class="typename">uint8</span> = i1 <span class="comment">//错误</span></div><div class="line"><span class="keyword">var</span> i3 <span class="typename">uint8</span> = (<span class="typename">uint8</span>)i1 <span class="comment">//错误</span></div></pre></td></tr></table></figure>

<p>比如在类型那一章讲的例子，也是通过这种类型转换实现的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">x := [...]<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>,<span class="number"> 4</span>,<span class="number"> 5</span>}</div><div class="line">p := &x<span class="number">[0</span>]</div><div class="line"><span class="comment">//p = p + 1</span></div><div class="line">index2Pointer := unsafe.Pointer(<span class="typename">uintptr</span>(unsafe.Pointer(p)) + unsafe.Sizeof(x<span class="number">[0</span>]))</div><div class="line">p = (*<span class="typename">int</span>)(index2Pointer) <span class="comment">//x[1]</span></div><div class="line">fmt.Printf(<span class="string">"%d\n"</span>, *p)    <span class="comment">//2</span></div></pre></td></tr></table></figure>

<h3 id="类型转换实践">类型转换实践</h3>
<p>这一节介绍常见类型一致的转换。</p>
<h4 id="数值类型之间的转换">数值类型之间的转换</h4>
<p>非常量的数值之间的转换遵循下面三条原则:<br>1、整数之间的转换时，如果值是有符号的整数，它的符号位会扩展无限大，否则零扩展，然后它会被删减以适合结果类型。怎么理解，看例子。<br>对于无符号数v: <code>v := uint16(0x10F0)</code>,如果进行转换<code>uint32(int8(v))</code>,可以看到它的结果是<code>0xFFFFFFF0</code>，不会有溢出指示或者错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">v1 := <span class="typename">uint16</span><span class="number">(0</span>x10F0)</div><div class="line">fmt.Printf(<span class="string">"%d=%b\n"</span>, v1, v1) <span class="comment">//4336=1000011110000</span></div><div class="line"></div><div class="line">v2 := <span class="typename">int8</span>(v1)</div><div class="line">fmt.Printf(<span class="string">"%d=%b\n"</span>, v2, v2) <span class="comment">//-16=-10000</span></div><div class="line"></div><div class="line">v3 := <span class="typename">uint16</span>(v2)</div><div class="line">fmt.Printf(<span class="string">"%d=%b\n"</span>, v3, v3) <span class="comment">//65520=1111111111110000</span></div><div class="line"></div><div class="line">v4 := <span class="typename">int16</span>(v2)</div><div class="line">fmt.Printf(<span class="string">"%d=%b\n"</span>, v4, v4) <span class="comment">//-16=-10000</span></div></pre></td></tr></table></figure>

<p>介绍一下。 对于v1,它是一个无符号的整数， 要把它转为有符号的int8，那么我们只看v1的后8位:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1111 0000</div></pre></td></tr></table></figure>

<p>不幸的是，这个8位的最高位是1,我们会把它作为符号位，所以v2是个负数，那么<code>11110000</code>就是这个负数的补码，<br>那么它的原码是多少呢，计算补码的补码就是负数的原码:<code>1001 0000</code>,所以它是-16。如果最高位是0，简单了，本身就是它的原码。</p>
<p>再看v2转v3， 也就是有符号整数转无符号整数。v2是负数，内部表示为<code>11110000</code>,因为要扩展为16位，将符号位1扩展到最高位<code>1111 1111 1111 0000</code>,因为它是无符号整数，所以这个值整数的值65520。</p>
<p>你可以把v1值的值改为0xff60看看输出是什么？此时转换不会符号位为负数的情况。</p>
<blockquote>
<p>补码（two&#39;s complement) 指的是正数=原码，负数=反码加一<br>反码（ones&#39; complement) 指的就是通常所指的反码。<br>对一个整数的补码再求补码，等于该整数自身。<br>补码的正零与负零表示方法相同。</p>
</blockquote>
<p>2、浮点数转换成整数时，小数部分被丢弃,也就是朝0方向舍入。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> v1 <span class="typename">float32</span> =<span class="number"> 0.999999</span></div><div class="line">fmt.Println(<span class="typename">int</span>(v1))</div><div class="line">v1 =<span class="number"> -0.999999</span></div><div class="line">fmt.Println(<span class="typename">int</span>(v1))</div></pre></td></tr></table></figure>

<p>3、当转换整数或者浮点数到浮点数的时候，或者一个复数到另一个复数， 结果值会被舍入到目标类型的精度。例如类型为float32的变量x可以通过附加的精度超过标准的IEEE-754 32-bit数， 但是float32(x)代表x的值舍入到 IEEE-754 32 bit的精度。类似地， x + 0.1 可以使用超过32 bit的精度，但是float32(x + 0.1) 肯定是32 bit的精度。</p>
<blockquote>
<p>the value of a variable x of type float32 may be stored using additional precision beyond that of an IEEE-754 32-bit number, but float32(x) represents the result of rounding x&#39;s value to 32-bit precision. Similarly, x + 0.1 may use more than 32 bits of precision, but float32(x + 0.1) does not.</p>
</blockquote>
<p>关于浮点数格式IEEE-754, 随便一本计算机原理的教材中都会介绍，网上也有无数的文章介绍，它由三个域组成，float32中分别占1位、8位、和 23位,本文中就不详细介绍了。<br><img src="float32.png" alt="float32"></p>
<h4 id="整数和bool之间的转换">整数和bool之间的转换</h4>
<p>虽然有人提议实现快速的整数和bool之间的转换，但是目前看起来还没有实现，所以下面的语句是不对的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">i1 :=<span class="number"> 1</span></div><div class="line">i2 :=<span class="number"> 0</span></div><div class="line">fmt.Printf(<span class="string">"%t %t\n"</span>, <span class="typename">bool</span>(i1), <span class="typename">bool</span>(i2))</div></pre></td></tr></table></figure>

<p>但是你完全可以通过其它方式实现， 比如判断语句 <code>n &gt; 0</code>, 或者利用一个定义好的表(map,数组等)进行查表转换。</p>
<p>参考</p>
<ul>
<li><a href="https://github.com/golang/go/issues/6011" target="_blank" rel="external">https://github.com/golang/go/issues/6011</a></li>
<li><a href="https://github.com/golang/go/issues/7657" target="_blank" rel="external">https://github.com/golang/go/issues/7657</a></li>
</ul>
<h4 id="基于字节的字符串的转换">基于字节的字符串的转换</h4>
<p>字符串代表一串字节流，所以很容易的和slice of byte, slice of rune进行转换。<br>1、无符号整数或者有符号整数通过它对应的UTF-8编码转换成字符串。合法的Unicode code之外的值都被转换成<code>\uFFFD</code>。这里的整数也包含rune.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="typename">string</span>(<span class="string">'a'</span>)       <span class="comment">// "a"</span></div><div class="line"><span class="typename">string</span><span class="number">(-1</span>)        <span class="comment">// "\ufffd" == "\xef\xbf\xbd"</span></div><div class="line"><span class="typename">string</span><span class="number">(0</span>xf8)      <span class="comment">// "\u00f8" == "ø" == "\xc3\xb8"</span></div><div class="line"><span class="keyword">type</span> MyString <span class="typename">string</span></div><div class="line">MyString<span class="number">(0</span>x65e5)  <span class="comment">// "\u65e5" == "日" == "\xe6\x97\xa5"</span></div></pre></td></tr></table></figure>

<p>2、字节slice根据UTF-8编码产生字符串</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="typename">string</span>([]<span class="typename">byte</span>{<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'\xc3'</span>, <span class="string">'\xb8'</span>})   <span class="comment">// "hellø"</span></div><div class="line"><span class="typename">string</span>([]<span class="typename">byte</span>{})                                     <span class="comment">// ""</span></div><div class="line"><span class="typename">string</span>([]<span class="typename">byte</span>(<span class="constant">nil</span>))                                  <span class="comment">// ""</span></div></pre></td></tr></table></figure>

<p>3、将rune slice转换成字符串相当于将rune连接起来</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="typename">string</span>([]<span class="typename">rune</span><span class="number">{0</span>x9E1F,<span class="number"> 0</span>x7A9D})   <span class="comment">// "\u9e1f\u7a9d" == "鸟窝"</span></div><div class="line"><span class="typename">string</span>([]<span class="typename">rune</span>{})                         <span class="comment">// ""</span></div><div class="line"><span class="typename">string</span>([]<span class="typename">rune</span>(<span class="constant">nil</span>))                      <span class="comment">// ""</span></div></pre></td></tr></table></figure>

<p>4、将字符串转为byte slice会将字符串的字节流复制到一个byte slice</p>
<p>5、将一个字符串转为rune slice会将产生一个新的rune slice,包含字符串中每个rune</p>
<h4 id="字符串和基本类型之间的转换">字符串和基本类型之间的转换</h4>
<p>包strconv提供了字符串和基本数据类型的转换。上面我们提到了字符串和整数之间的转换，但是有时候我们需要的是将 12转换成字符串 &quot;12&quot;，或者从字符串中解析处一个整数，这个时候就可以使用这个包。</p>
<p>首先它提供了一组往byte slice增加基本类型元素的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> AppendBool(dst []<span class="typename">byte</span>, b <span class="typename">bool</span>) []<span class="typename">byte</span></div><div class="line"><span class="keyword">func</span> AppendFloat(dst []<span class="typename">byte</span>, f <span class="typename">float64</span>, fmt <span class="typename">byte</span>, prec, bitSize <span class="typename">int</span>) []<span class="typename">byte</span></div><div class="line"><span class="keyword">func</span> AppendInt(dst []<span class="typename">byte</span>, i <span class="typename">int64</span>, base <span class="typename">int</span>) []<span class="typename">byte</span></div><div class="line"><span class="keyword">func</span> AppendQuote(dst []<span class="typename">byte</span>, s <span class="typename">string</span>) []<span class="typename">byte</span></div><div class="line"><span class="keyword">func</span> AppendQuoteRune(dst []<span class="typename">byte</span>, r <span class="typename">rune</span>) []<span class="typename">byte</span></div><div class="line"><span class="keyword">func</span> AppendQuoteRuneToASCII(dst []<span class="typename">byte</span>, r <span class="typename">rune</span>) []<span class="typename">byte</span></div><div class="line"><span class="keyword">func</span> AppendQuoteRuneToGraphic(dst []<span class="typename">byte</span>, r <span class="typename">rune</span>) []<span class="typename">byte</span></div><div class="line"><span class="keyword">func</span> AppendQuoteToASCII(dst []<span class="typename">byte</span>, s <span class="typename">string</span>) []<span class="typename">byte</span></div><div class="line"><span class="keyword">func</span> AppendQuoteToGraphic(dst []<span class="typename">byte</span>, s <span class="typename">string</span>) []<span class="typename">byte</span></div><div class="line"><span class="keyword">func</span> AppendUint(dst []<span class="typename">byte</span>, i <span class="typename">uint64</span>, base <span class="typename">int</span>) []<span class="typename">byte</span></div></pre></td></tr></table></figure>

<p>一组从字符串中解析出基本类型的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> ParseBool(str <span class="typename">string</span>) (value <span class="typename">bool</span>, err error)</div><div class="line"><span class="keyword">func</span> ParseFloat(s <span class="typename">string</span>, bitSize <span class="typename">int</span>) (f <span class="typename">float64</span>, err error)</div><div class="line"><span class="keyword">func</span> ParseInt(s <span class="typename">string</span>, base <span class="typename">int</span>, bitSize <span class="typename">int</span>) (i <span class="typename">int64</span>, err error)</div><div class="line"><span class="keyword">func</span> ParseUint(s <span class="typename">string</span>, base <span class="typename">int</span>, bitSize <span class="typename">int</span>) (n <span class="typename">uint64</span>, err error)</div></pre></td></tr></table></figure>

<p>一组为字符串或者rune加引号和剥离引号的方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Quote(s <span class="typename">string</span>) <span class="typename">string</span></div><div class="line"><span class="keyword">func</span> QuoteRune(r <span class="typename">rune</span>) <span class="typename">string</span></div><div class="line"><span class="keyword">func</span> QuoteRuneToASCII(r <span class="typename">rune</span>) <span class="typename">string</span></div><div class="line"><span class="keyword">func</span> QuoteRuneToGraphic(r <span class="typename">rune</span>) <span class="typename">string</span></div><div class="line"><span class="keyword">func</span> QuoteToASCII(s <span class="typename">string</span>) <span class="typename">string</span></div><div class="line"><span class="keyword">func</span> QuoteToGraphic(s <span class="typename">string</span>) <span class="typename">string</span></div><div class="line"><span class="keyword">func</span> Unquote(s <span class="typename">string</span>) (t <span class="typename">string</span>, err error)</div><div class="line"><span class="keyword">func</span> UnquoteChar(s <span class="typename">string</span>, quote <span class="typename">byte</span>) (value <span class="typename">rune</span>, multibyte <span class="typename">bool</span>, tail <span class="typename">string</span>, err error)</div></pre></td></tr></table></figure>

<p>一组检查字符串或者rune为特定类型的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> CanBackquote(s <span class="typename">string</span>) <span class="typename">bool</span></div><div class="line"><span class="keyword">func</span> IsGraphic(r <span class="typename">rune</span>) <span class="typename">bool</span></div><div class="line"><span class="keyword">func</span> IsPrint(r <span class="typename">rune</span>) <span class="typename">bool</span></div></pre></td></tr></table></figure>

<p>一组格式化基本类型为字符串的方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> FormatBool(b <span class="typename">bool</span>) <span class="typename">string</span></div><div class="line"><span class="keyword">func</span> FormatFloat(f <span class="typename">float64</span>, fmt <span class="typename">byte</span>, prec, bitSize <span class="typename">int</span>) <span class="typename">string</span></div><div class="line"><span class="keyword">func</span> FormatInt(i <span class="typename">int64</span>, base <span class="typename">int</span>) <span class="typename">string</span></div><div class="line"><span class="keyword">func</span> FormatUint(i <span class="typename">uint64</span>, base <span class="typename">int</span>) <span class="typename">string</span></div></pre></td></tr></table></figure>

<p>重要的放在最后说，我们在编程中更多的用到的两个方法, 整数字面值和字符串之间的转换:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Atoi(s <span class="typename">string</span>) (i <span class="typename">int</span>, err error)</div><div class="line"><span class="keyword">func</span> Itoa(i <span class="typename">int</span>) <span class="typename">string</span></div></pre></td></tr></table></figure>

<p>参考</p>
<ul>
<li><a href="https://golang.org/pkg/strconv/" target="_blank" rel="external">https://golang.org/pkg/strconv/</a></li>
</ul>
<h4 id="字节slice和整数之间的转换">字节slice和整数之间的转换</h4>
<p>包 encoding/binary实现了数值和字节序列之间的转换，包含变长int的各种编解码。</p>
<p>Go中的数值类型都是固定长度的位数(int8, uint8, int16, float32, complex64)，所以组成这些数组的bit可以转换成各种字节slice。</p>
<p>变长int (varint)经常用于节省空间，比如一个， Go实现的varint规范可以参考<a href="https://developers.google.com/protocol-buffers/docs/encoding" target="_blank" rel="external">proto-buff的实现</a>。很多编解码库中都使用了变长的int，这样对于大量的小数字我们可以用更少的字节来表示，对于网络传输来说很有好处。</p>
<p>这个包经常用在网络传输的序列化和反序列中。</p>
<p>另外一个值得注意的是数值是由多个字节组成的，这就涉及到字节序的问题，你必须指定使用小端序或大端序。</p>
<p>首先看一下定长的数值的转换，主要是<code>Read</code>和<code>Write</code>两个方法，底层还是通过移位操作实现的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Read(r io.Reader, order ByteOrder, data <span class="keyword">interface</span>{}) error</div><div class="line"><span class="keyword">func</span> Write(w io.Writer, order ByteOrder, data <span class="keyword">interface</span>{}) error</div></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"bytes"</span></div><div class="line">	<span class="string">"encoding/binary"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	b := write()</div><div class="line">	read(b)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> write() []<span class="typename">byte</span> {</div><div class="line">	buf := <span class="built_in">new</span>(bytes.Buffer)</div><div class="line">	<span class="keyword">var</span> data = []<span class="keyword">interface</span>{}{</div><div class="line">		<span class="typename">uint16</span><span class="number">(61374</span>), <span class="comment">//efbe</span></div><div class="line">		<span class="typename">int8</span><span class="number">(-54</span>),     <span class="comment">//-36</span></div><div class="line">		<span class="typename">uint8</span><span class="number">(254</span>),    <span class="comment">//fe</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> data {</div><div class="line">		err := binary.Write(buf, binary.BigEndian, v)</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			fmt.Println(<span class="string">"binary.Write failed:"</span>, err)</div><div class="line">		}</div><div class="line">	}</div><div class="line">	fmt.Printf(<span class="string">"%x\n"</span>, buf.Bytes()) <span class="comment">//efbecafe</span></div><div class="line">	<span class="keyword">return</span> buf.Bytes()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> read(b []<span class="typename">byte</span>) {</div><div class="line">	<span class="keyword">var</span> i1 <span class="typename">uint16</span></div><div class="line">	<span class="keyword">var</span> i2 <span class="typename">int8</span></div><div class="line">	<span class="keyword">var</span> i3 <span class="typename">uint8</span></div><div class="line"></div><div class="line">	buf := bytes.NewReader(b)</div><div class="line">	err := binary.Read(buf, binary.BigEndian, &i1)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		fmt.Println(<span class="string">"binary.Read failed:"</span>, err)</div><div class="line">	}</div><div class="line">	err = binary.Read(buf, binary.BigEndian, &i2)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		fmt.Println(<span class="string">"binary.Read failed:"</span>, err)</div><div class="line">	}</div><div class="line">	err = binary.Read(buf, binary.BigEndian, &i3)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		fmt.Println(<span class="string">"binary.Read failed:"</span>, err)</div><div class="line">	}</div><div class="line"></div><div class="line">	fmt.Println(i1, i2, i3) <span class="comment">//61374 -54 254</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>一种不通用的适合特定类型的转换也可以使用下面的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> readInt32(b []<span class="typename">byte</span>) <span class="typename">int32</span> {</div><div class="line">    <span class="comment">// equivalnt of return int32(binary.LittleEndian.Uint32(b))</span></div><div class="line">    <span class="keyword">return</span> <span class="typename">int32</span>(<span class="typename">uint32</span>(b<span class="number">[0</span>]) | <span class="typename">uint32</span>(b<span class="number">[1</span>])&lt;<span class="number">&lt;8</span> | <span class="typename">uint32</span>(b<span class="number">[2</span>])&lt;<span class="number">&lt;16</span> | <span class="typename">uint32</span>(b<span class="number">[3</span>])&lt;<span class="number">&lt;24</span>)</div><div class="line">}</div><div class="line"><span class="comment">//或者</span></div><div class="line"><span class="keyword">func</span> ReadInt32Unsafe(b []<span class="typename">byte</span>) <span class="typename">int32</span> {</div><div class="line">    <span class="keyword">return</span> *(*<span class="typename">int32</span>)(unsafe.Pointer(&b<span class="number">[0</span>]))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>变长int的操作函数:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> PutUvarint(buf []<span class="typename">byte</span>, x <span class="typename">uint64</span>) <span class="typename">int</span></div><div class="line"><span class="keyword">func</span> PutVarint(buf []<span class="typename">byte</span>, x <span class="typename">int64</span>) <span class="typename">int</span></div><div class="line"><span class="keyword">func</span> Uvarint(buf []<span class="typename">byte</span>) (<span class="typename">uint64</span>, <span class="typename">int</span>)</div><div class="line"><span class="keyword">func</span> Varint(buf []<span class="typename">byte</span>) (<span class="typename">int64</span>, <span class="typename">int</span>)</div><div class="line"><span class="keyword">func</span> ReadUvarint(r io.ByteReader) (<span class="typename">uint64</span>, error)</div><div class="line"><span class="keyword">func</span> ReadVarint(r io.ByteReader) (<span class="typename">int64</span>, error)</div></pre></td></tr></table></figure>

<p>以及一个对象被转换成多少字节的方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Size(v <span class="keyword">interface</span>{}) <span class="typename">int</span></div></pre></td></tr></table></figure>

<p>参考</p>
<ul>
<li><a href="https://golang.org/pkg/encoding/binary/" target="_blank" rel="external">https://golang.org/pkg/encoding/binary/</a></li>
<li><a href="https://zh.wikipedia.org/wiki/字节序#.E5.AD.97.E8.8A.82.E9.A1.BA.E5.BA.8F" target="_blank" rel="external">https://zh.wikipedia.org/wiki/字节序#.E5.AD.97.E8.8A.82.E9.A1.BA.E5.BA.8F</a></li>
<li><a href="http://codereview.stackexchange.com/questions/15945/effectively-convert-little-endian-byte-slice-to-int32" target="_blank" rel="external">http://codereview.stackexchange.com/questions/15945/effectively-convert-little-endian-byte-slice-to-int32</a></li>
</ul>
<h4 id="数组和slice之间的转换">数组和slice之间的转换</h4>
<p>数组转换成slice很简单，前面讲到了，利用索引运算：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a[low:high]</div><div class="line">a[low:high:max]</div></pre></td></tr></table></figure>

<p>而slice转数组，我们可以好好分析一下。</p>
<p>slice的底层实现是数组，所以有一个&quot;hack&quot;方法，将slice的底层数组返回:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"reflect"</span></div><div class="line">    <span class="string">"unsafe"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> SIZEOF_INT32 =<span class="number"> 4</span> <span class="comment">// bytes</span></div><div class="line"></div><div class="line"><span class="comment">// Get the slice header</span></div><div class="line">header := *(*reflect.SliceHeader)(unsafe.Pointer(&raw))</div><div class="line"></div><div class="line"><span class="comment">// The length and capacity of the slice are different.</span></div><div class="line">header.Len /= SIZEOF_INT32</div><div class="line">header.Cap /= SIZEOF_INT32</div><div class="line"></div><div class="line"><span class="comment">// Convert slice header to an []int32</span></div><div class="line">data := *(*[]<span class="typename">int32</span>)(unsafe.Pointer(&header))</div></pre></td></tr></table></figure>

<p>安全的方式是生成数组然后依次赋值，注意copy是不行的，因为copy的参数必须都是slice:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"encoding/binary"</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> SIZEOF_INT32 =<span class="number"> 4</span> <span class="comment">// bytes</span></div><div class="line"></div><div class="line">data := <span class="built_in">make</span>([]<span class="typename">int32</span>, <span class="built_in">len</span>(raw)/SIZEOF_INT32)</div><div class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> data {</div><div class="line">    <span class="comment">// assuming little endian</span></div><div class="line">    data[i] = <span class="typename">int32</span>(binary.LittleEndian.Uint32(raw[i*SIZEOF_INT32:(i<span class="number">+1</span>)*SIZEOF_INT32]))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>参考</p>
<ul>
<li><a href="http://stackoverflow.com/questions/19073769/in-golang-how-do-you-convert-a-slice-into-an-array" target="_blank" rel="external">http://stackoverflow.com/questions/19073769/in-golang-how-do-you-convert-a-slice-into-an-array</a></li>
<li><a href="http://stackoverflow.com/questions/11924196/convert-between-slices-of-different-types" target="_blank" rel="external">http://stackoverflow.com/questions/11924196/convert-between-slices-of-different-types</a></li>
<li><a href="https://groups.google.com/forum/#!topic/golang-nuts/yNis7bQG_rY" target="_blank" rel="external">https://groups.google.com/forum/#!topic/golang-nuts/yNis7bQG_rY</a></li>
</ul>
<h4 id="struct和字符串之间的转换">struct和字符串之间的转换</h4>
<p>struct类型的值和字符串之间的转换我们称之为marshal和unmarshal。<br>有非常多的库可以做这个事情，比如gob, encoding/json等。</p>
<p>Go序列化框架的性能比较可以参照我的一个开源项目: <a href="https://github.com/smallnest/gosercomp" target="_blank" rel="external">gosercomp</a>。</p>
<h3 id="类型断言_type_assertion">类型断言 type assertion</h3>
<p>和上节的类型转换不同，类型断言是将接口类型的值x，转换成类型T。</p>
<p>格式为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">x.(T)</div><div class="line">v := x.(T)</div><div class="line">v, ok := x.(T)</div></pre></td></tr></table></figure>

<p>类型断言的必要条件是x是接口类型,非接口类型的x不能做类型断言:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i <span class="typename">int</span> =<span class="number"> 10</span></div><div class="line">v := i.(<span class="typename">int</span>) <span class="comment">//错误</span></div></pre></td></tr></table></figure>

<p>T可以是非接口类型，如果想断言合法，则T应该实现x的接口。</p>
<p>T也可以是接口，则x的动态类型也应该实现接口T。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>{} =<span class="number"> 7</span>  <span class="comment">// x 的动态类型为int， 值为 7</span></div><div class="line">i := x.(<span class="typename">int</span>)           <span class="comment">// i 的类型为 int， 值为 7</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> { m() }</div><div class="line"><span class="keyword">var</span> y I</div><div class="line">s := y.(<span class="typename">string</span>)        <span class="comment">// 非法: string 没有实现接口 I (missing method m)</span></div><div class="line">r := y.(io.Reader)     <span class="comment">// y如果实现了接口io.Reader和I的情况下，  r的类型则为io.Reader</span></div></pre></td></tr></table></figure>

<p>类型断言如果非法，运行时时候就会出现 impossible type assertion panic，为了避免这种情况，可以使用下面的语法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">v, ok = x.(T)</div><div class="line">v, ok := x.(T)</div><div class="line"><span class="keyword">var</span> v, ok = x.(T)</div></pre></td></tr></table></figure>

<p>ok代表类型断言是否合法，如果非法ok =false,v为T的零值，这样就不会出现运行时panic了。</p>
<p>希望你能记住，类型转换和类型断言完全是两个概念。</p>
<h3 id="类型切换_type_switch">类型切换 type switch</h3>
<p>类型切换(暂且这么翻译吧，英语更准确)用来比较类型而不是对值进行比较。</p>
<p>switch语句虽然在下一章中去讲，但是对于读者来说，多少会一种或者几种常用的编程语言，switch是一个条件语句，它可以判断某个值是否匹配某个case clause。但是对于type switch，它检查的是值x的类型T是否匹配某个类型。</p>
<p>格式如下，类型类型断言，但是括号内的不是某个具体的类型，而是单词<code>type</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> x.(<span class="keyword">type</span>) {</div><div class="line"><span class="comment">// cases</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>type switch语句中可以有一个简写的变量声明，这种情况下，等价于这个变量声明在每个case clause隐式代码块的开始位置。如果case clause只列出了一个类型，则变量的类型就是这个类型，否则就是原始值的类型。</p>
<p>假设下面的例子中x的类型为x interface{}</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> i := x.(<span class="keyword">type</span>) {</div><div class="line"><span class="keyword">case</span> <span class="constant">nil</span>:</div><div class="line">  printString(<span class="string">"x is nil"</span>) <span class="comment">// i的类型是 x的类型 (interface{})</span></div><div class="line"><span class="keyword">case</span> <span class="typename">int</span>:</div><div class="line">  printInt(i) <span class="comment">// i的类型 int</span></div><div class="line"><span class="keyword">case</span> <span class="typename">float64</span>:</div><div class="line">  printFloat64(i) <span class="comment">// i的类型是 float64</span></div><div class="line"><span class="keyword">case</span> <span class="keyword">func</span>(<span class="typename">int</span>) <span class="typename">float64</span>:</div><div class="line">  printFunction(i) <span class="comment">// i的类型是 func(int) float64</span></div><div class="line"><span class="keyword">case</span> <span class="typename">bool</span>, <span class="typename">string</span>:</div><div class="line">  printString(<span class="string">"type is bool or string"</span>) <span class="comment">// i的类型是 x (interface{})</span></div><div class="line"><span class="keyword">default</span>:</div><div class="line">  printString(<span class="string">"don't know the type"</span>) <span class="comment">// i的类型是 x的类型 (interface{})</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>也许你已经看到上面的例子中有一个case clause中的类型是nil,它用来匹配x为nil的interface{}的情况。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文介绍 类型转换(Conversion)、类型断言(type assertion) 和类型切换（type switch)。</p>
<p>这三个概念类似但是又完全不同。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入Go语言 - 5]]></title>
    <link href="http://colobu.com/2016/06/20/dive-into-go-5/"/>
    <id>http://colobu.com/2016/06/20/dive-into-go-5/</id>
    <published>2016-06-20T08:00:41.000Z</published>
    <updated>2016-06-21T08:57:05.000Z</updated>
    <content type="html"><![CDATA[<p>本文介绍Go语言的表达式。</p>
<p>表达式代表一个值的计算， 计算通过运算符和函数应用在操作数上(operand)。<br><a id="more"></a></p>
<p>操作数代表表达式中的基本值。它可以字面量，标识符。 标识符表示常量、变量、函数、方法表达式、或者一个括号表达式。</p>
<p>空标识符“_”只能出现在赋值语句的左边。</p>
<p>包代码块中定义的标识符通过 <code>package.identifier</code>访问。</p>
<p>表达式的形式有多种，可以参看官方文档: <a href="https://golang.org/ref/spec#Primary_expressions" target="_blank" rel="external">Primary expressions</a>。</p>
<p>以下都是合法的表达式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">x<span class="number"></span></div><div class="line">2</div><div class="line">(s + <span class="string">".txt"</span>)</div><div class="line">f<span class="number">(3.1415</span>, <span class="constant">true</span>)</div><div class="line">Point<span class="number">{1</span>,<span class="number"> 2</span>}</div><div class="line">m[<span class="string">"foo"</span>]</div><div class="line">s[i : j +<span class="number"> 1</span>]</div><div class="line">obj.color</div><div class="line">f.p[i].x()</div><div class="line">i.(<span class="typename">int</span>)</div></pre></td></tr></table></figure>

<p>重点介绍Go语言规范中的以下表达式。</p>
<h3 id="Selector">Selector</h3>
<p>假定x不是包名，selector表达式表示如下: <code>x.f</code>。<br>它表示f是x (或者*x)的字段或者方法。其中标识符f称为selector。</p>
<p>selector f可以是类型T的字段或者方法，也可以是T的匿名嵌套字段的字段和方法。 可以递归地通过匿名字段进行查找，匿名字段递归查找f的数量称之为它在T中的深度。T中声明的字段和方法的深度为0。</p>
<p>selector有以下特性：<br>1、对于类型为 <code>T</code> 或 <code>*T</code>的值x, 当 T 不是指针类型或者接口类型时，x.f 代表 T 的 最小深度的字段或者方法 f。 如果同一深度有多个f， 那么selector表达式就是错误的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> S1 <span class="keyword">struct</span> {</div><div class="line">}</div><div class="line"><span class="keyword">func</span> (s S1) Say() {</div><div class="line"></div><div class="line">}</div><div class="line"><span class="keyword">type</span> S2 <span class="keyword">struct</span> {</div><div class="line">}</div><div class="line"><span class="keyword">func</span> (s S2) Say() {</div><div class="line"></div><div class="line">}</div><div class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> {</div><div class="line">	S1</div><div class="line">	S2</div><div class="line">}</div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> s S</div><div class="line">	s.Say()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>2、对于类型为I的值x, 如果I是接口类型，那么 x.f 代表 x的动态类型的实际方法 f。 如果 I 接口的方法集中没有方法f, 则selector表达式非法。<br>3、一个特例。如果x的类型是一个命名的指针类型，并且(*x).f代表字段f(不是方法),可以简写为 x.f。<br>4、其它情况 x.f 都是非法的。<br>5、如果 x是一个指针类型，它的值是 nil。则 x.f 会导致运行时panic。<br>6、如果x的类型I是接口类型，并且值为 nil， 则x.f会导致运行时panic。</p>
<p>我们首先定义两个类型<code>T0</code>、<code>T1</code>,分别包含一个方法<code>M0</code>和<code>M1</code>，类型参数分别为<code>*T0</code>、<code>T1</code>。</p>
<p>然后定义一个类型<code>T2</code>，嵌入<code>T1</code>和<code>*T0</code>，还包含一个方法<code>M2</code>，类型参数为<code>*T2</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> T0 <span class="keyword">struct</span> {</div><div class="line">	x <span class="typename">int</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (*T0) M0() {}</div><div class="line"></div><div class="line"><span class="keyword">type</span> T1 <span class="keyword">struct</span> {</div><div class="line">	y <span class="typename">int</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (T1) M1() {}</div><div class="line"></div><div class="line"><span class="keyword">type</span> T2 <span class="keyword">struct</span> {</div><div class="line">	z <span class="typename">int</span></div><div class="line">	T1</div><div class="line">	*T0</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (*T2) M2() {}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Q *T2</div><div class="line"></div><div class="line"><span class="keyword">var</span> t T2 = T2{T1: T1{}, T0: &T0{}}</div><div class="line"><span class="keyword">var</span> p *T2 = &T2{T1: T1{}, T0: &T0{}}</div><div class="line"><span class="keyword">var</span> q Q = p</div></pre></td></tr></table></figure>

<p>则下面的表达式都是合法的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	_ = t.z <span class="comment">// t.z</span></div><div class="line">	_ = t.y <span class="comment">// t.T1.y</span></div><div class="line">	_ = t.x <span class="comment">// (*t.T0).x</span></div><div class="line"></div><div class="line">	_ = p.z <span class="comment">// (*p).z</span></div><div class="line">	_ = p.y <span class="comment">// (*p).T1.y</span></div><div class="line">	_ = p.x <span class="comment">// (*(*p).T0).x</span></div><div class="line"></div><div class="line">	_ = q.x <span class="comment">// (*(*q).T0).x        (*q).x is a valid field selector</span></div><div class="line"></div><div class="line">	p.M0() <span class="comment">// ((*p).T0).M0()      M0 expects *T0 receiver</span></div><div class="line">	p.M1() <span class="comment">// ((*p).T1).M1()      M1 expects T1 receiver</span></div><div class="line">	p.M2() <span class="comment">// p.M2()              M2 expects *T2 receiver</span></div><div class="line">	t.M2() <span class="comment">// (&t).M2()           M2 expects *T2 receiver, see section on Calls</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>但是下面的表达式非法(违反规则3)：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">q.M0()       <span class="comment">// (*q).M0 is valid but not a field selector</span></div></pre></td></tr></table></figure>

<h3 id="方法表达式">方法表达式</h3>
<p>如果M在类型T的方法集中，T.M可以当作一个普通的函数调用，它的第一个参数需要传入receiver的值。</p>
<p>考虑到下面的结构体S:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> {</div><div class="line">	Name <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s S) M1(i <span class="typename">int</span>) {</div><div class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, s)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s *S) M2(f <span class="typename">float32</span>) {</div><div class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, s)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>和变量 <code>var s = S{&quot;bird&quot;}</code>,下面的6组表达式都是等价的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">s.M1<span class="number">(1</span>)</div><div class="line">S.M1(s<span class="number">,1</span>)</div><div class="line">(S).M1(s<span class="number">,1</span>)</div><div class="line">f1 := S.M1;f1(s<span class="number">,1</span>)</div><div class="line">f2 := (S).M1;f2(s<span class="number">,1</span>)</div><div class="line">f3 := s.M1;f3<span class="number">(1</span>)</div></pre></td></tr></table></figure>

<p>类似地，<code>(*S).M2</code>也会产生下面的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span>(t *T, <span class="typename">float32</span>)</div></pre></td></tr></table></figure>

<p>对于receiver为value receiver的方法, <code>(*S).M1</code>还会产生下面的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span>(s *S, i <span class="typename">int</span>)</div></pre></td></tr></table></figure>

<p>注意这个方法会为传入的receiver创建一个值，这个方法不会覆盖传入的指针指向的值。</p>
<p>如果x的静态类型为T, M是T的方法集里面的一个方法。 则x.M称之为方法值(method value)。方法值是一个函数，参数和x.M的参数一样。T可以是接口类型或者非接口类型。</p>
<p>Go语言规定，一个指针可以调用value receiver的非接口方法：<code>pt.M1</code>等价于<code>(*pt).M1</code>。<br>而一个值可以调用pointer receiver的非接口方法:<code>s.M2</code>等价于<code>(&amp;s).M2</code>,它会把这个值的地址作为参数。</p>
<p>因此，对于非接口方法，不管它的reeiver是poiter还是value，值对象和指针对象都可以调用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> {</div><div class="line">	Name <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s S) M1() {</div><div class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, s)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s *S) M2() {</div><div class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, s)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> s1 = S{<span class="string">"bird"</span>}</div><div class="line">	<span class="keyword">var</span> s2 = &s1</div><div class="line"></div><div class="line">	s1.M1()</div><div class="line">	s1.M2()</div><div class="line">	s2.M1()</div><div class="line">	s2.M2()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>注意，前面已经讲到，通过指针调用value receiver的方法不会改变指针指向的对象的值，因为它会复制一份value,而不是把自己的value值传入方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> {</div><div class="line">	Name <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s S) M1() {</div><div class="line">	s.Name = <span class="string">"bird1"</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s *S) M2() {</div><div class="line">	s.Name = <span class="string">"bird2"</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> s1 = S{<span class="string">"bird"</span>}</div><div class="line">	<span class="keyword">var</span> s2 = &s1</div><div class="line">	s1.M2()</div><div class="line">	fmt.Printf(<span class="string">"%+v, %+v\n"</span>, s1, s2) <span class="comment">//{Name:bird2}, &{Name:bird2}</span></div><div class="line"></div><div class="line">	s1 = S{<span class="string">"bird"</span>}</div><div class="line">	s2 = &s1</div><div class="line">	s2.M1()</div><div class="line">	fmt.Printf(<span class="string">"%+v, %+v\n"</span>, s1, s2)<span class="comment">//{Name:bird}, &{Name:bird}</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>甚至，函数也可以有方法,比如常见的官方库中的<code>HandlerFunc</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> HandlerFunc <span class="keyword">func</span>(ResponseWriter, *Request)</div><div class="line"></div><div class="line"><span class="keyword">func</span> (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {</div><div class="line">	f(w, r)</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="索引表达式">索引表达式</h3>
<p>索引表达式<code>a[x]</code>可以用于数组、数组指针、slice、字符串和map。</p>
<p>对于非map的对象：</p>
<ul>
<li>索引值x必须是integer类型或者未声明类型的类型，并且 <code>0 &lt;= x &lt; len(a)</code></li>
<li>常数索引值必须非负，而且可以表现为int类型的值</li>
</ul>
<p>索引的以下内容你应该都很熟悉了，可以选择跳过去。</p>
<p>对于数组：</p>
<ul>
<li>索引不能越界</li>
<li>越界的话会发生运行时panic</li>
<li>a[x]是索引在x处的元素，索引值以0开始</li>
</ul>
<p>对于数组指针</p>
<ul>
<li>a[x] 是 (*a)[x]的简写</li>
</ul>
<p>对于slice类型S:</p>
<ul>
<li>x越界，运行时panic</li>
<li>a[x]是索引在x处的元素，索引值以0开始</li>
</ul>
<p>对于字符串类型：</p>
<ul>
<li>x不能越界</li>
<li>x越界，运行时panic</li>
<li>a[x]是索引在x处的非常量 byte值</li>
<li>不能给 a[x]赋值</li>
</ul>
<p>对于map类型：</p>
<ul>
<li>x必须可以赋值map的键类型，参照上一章的类型赋值规则</li>
<li>如果map包含键为x的entry,那么a[x]就是值对象</li>
<li>如果map是nil或者map不包含这个entry, a[x]是值类型的零值</li>
</ul>
<p>当然map类型还有一个特殊格式，就是可以同时返回x是否存在于map中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">v, ok = a[x]</div><div class="line">v, ok := a[x]</div><div class="line"><span class="keyword">var</span> v, ok = a[x]</div></pre></td></tr></table></figure>

<p>如果x存在于map中，则v返回它的值，ok 为 true,否则 ok 为 false。</p>
<h3 id="slice表达式">slice表达式</h3>
<p>字符串、数组、数组指针、slice可以通过下面的方式得到一个子字符串或者slice:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[low:high]</div></pre></td></tr></table></figure>

<p>当然其中<code>low</code>、<code>high</code>都可以忽略。默认low = 0, high = 操作数的最大长度。注意结果的范围是左闭右开的： a[low] &lt;= …… &lt; a[high],</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a<span class="number">[2</span>:]  <span class="comment">// same as a[2 : len(a)]</span></div><div class="line">a[<span class="number">:3</span>]  <span class="comment">// same as a[0 : 3]</span></div><div class="line">a[:]   <span class="comment">// same as a[0 : len(a)]</span></div></pre></td></tr></table></figure>

<p>对于数组、数组指针和slice (不包含字符串)，索引表达式还有下面的形式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[low : high : max]</div></pre></td></tr></table></figure>

<p>它和<code>a[low:high]</code>一样，产生同样的元素类型，同样长度和元素的slice,但是它会设置容量capacity,<br>产生的slice的容量为 <code>max-low</code>。在这个格式下，只有第一个索引low可以省略，默认为0。<br>索引的范围符合 <code>0 &lt;= low &lt;= high &lt;= max &lt;= cap(a)</code>。</p>
<h3 id="变参">变参</h3>
<p>对于函数和方法中的最后一个参数是变参p，类型是...T的情况，p的类型f等价于[]T。</p>
<p>如果没有实际参数传给变参，它的值是nil。</p>
<p>你可以讲一个slice传递给变参，如果想将slice的元素作为变参的各个值传递的话，可以在slice后面加...:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Greeting(prefix <span class="typename">string</span>, who ...<span class="typename">string</span>)</div><div class="line">Greeting(<span class="string">"nobody"</span>)</div><div class="line">Greeting(<span class="string">"hello:"</span>, <span class="string">"Joe"</span>, <span class="string">"Anna"</span>, <span class="string">"Eileen"</span>)</div><div class="line"></div><div class="line">s := []<span class="typename">string</span>{<span class="string">"James"</span>, <span class="string">"Jasmine"</span>}</div><div class="line">Greeting(<span class="string">"goodbye:"</span>, s...)</div></pre></td></tr></table></figure>

<p>加不加...是不一样的，比如下面的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> foo(p ...<span class="keyword">interface</span>{}) {</div><div class="line">	fmt.Println(<span class="built_in">len</span>(p))</div><div class="line">}</div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	s := []<span class="keyword">interface</span>{}<span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>,<span class="number"> 4</span>,<span class="number"> 5</span>}</div><div class="line"></div><div class="line">	foo(s)    <span class="comment">//1</span></div><div class="line">	foo(s...) <span class="comment">//5</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="运算符">运算符</h3>
<p>本节重要用于总结。</p>
<p>除了为移位运算符， 如果一个操作数是有类型的，另一个不是，则另一个会被转换成相同的类型。</p>
<p>移位操作的右边的运算符是无符号整数，或者可以转换成无符合整数的未声明的常量。</p>
<h4 id="运算符优先级">运算符优先级</h4>
<p><code>++</code>、<code>--</code>是语句，不是表达式， *p++等同于(*p)++。</p>
<p>运算符有5层优先级：</p>
<pre class="highlight">
Precedence    Operator
    5             *  /  %  <<  >>  &  &^
    4             +  -  |  ^
    3             ==  !=  <  <=>  >=
    2             &&
    1             ||
</=></pre>


<h4 id="算术运算符">算术运算符</h4>
<p>算术运算符应用于整数、浮点数、复数， + 也可以应用于字符串。</p>
<p>位运算和移位运算只适用于整数。</p>
<pre class="highlight">
+    sum                    integers, floats, complex values, strings
-    difference             integers, floats, complex values
*    product                integers, floats, complex values
/    quotient               integers, floats, complex values
%    remainder              integers

&    bitwise AND            integers
|    bitwise OR             integers
^    bitwise XOR            integers
&^   bit clear (AND NOT)    integers

<<   left shift             integer << unsigned integer
\>>   right shift            integer >> unsigned integer
</pre>

<p><code>^</code>是异或操作。<code>&amp;^</code>位清零操作，如果第二个操作数的二进制的某个位的值为1,那么对应的第一个操作数的位的值则设为0，也就是将第一个操作数上的相应的位清零。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">i1 :=<span class="number"> 0</span>x0F</div><div class="line">i2 := i1 &lt;&lt;<span class="number"> 2</span></div><div class="line"></div><div class="line">fmt.Printf(<span class="string">"0000%b\n00%b\n"</span>, i1, i2) <span class="comment">//00001111 00111100</span></div><div class="line">fmt.Printf(<span class="string">"%b\n"</span>, i1&i2) <span class="comment">//00001100</span></div><div class="line">fmt.Printf(<span class="string">"%b\n"</span>, i1|i2) <span class="comment">//00111111</span></div><div class="line">fmt.Printf(<span class="string">"%b\n"</span>, i1^i2) <span class="comment">//00110011</span></div><div class="line">fmt.Printf(<span class="string">"%b\n"</span>, i1&^i2) <span class="comment">//00000011</span></div></pre></td></tr></table></figure>

<p>对于移位操作，如果左边的操作符是无符号整数，则进行逻辑移位，如果左边的操作符是有符号整数，则进行的是算术移位。略记移位不考虑符号位，而算术移位要考虑符号位，这样能保证 移位操作 和 乘除的操作 一致。</p>
<p><img src="left_logically.png" alt="算术左移"></p>
<p><img src="right_arithmetically.png" alt="算术右移"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i <span class="typename">uint8</span> =<span class="number"> 1</span></div><div class="line">fmt.Printf(<span class="string">"%d: %b\n"</span>, i&lt;<span class="number">&lt;1</span>, i&lt;<span class="number">&lt;1</span>) <span class="comment">//2: 10</span></div><div class="line">fmt.Printf(<span class="string">"%d: %b\n"</span>, i&lt;<span class="number">&lt;7</span>, i&lt;<span class="number">&lt;7</span>) <span class="comment">//128: 10000000</span></div><div class="line">fmt.Printf(<span class="string">"%d: %b\n"</span>, i&lt;<span class="number">&lt;8</span>, i&lt;<span class="number">&lt;8</span>) <span class="comment">//0: 0</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> i2 <span class="typename">int8</span> =<span class="number"> 1</span></div><div class="line">fmt.Printf(<span class="string">"%d: %b\n"</span>, i2&lt;<span class="number">&lt;1</span>, i2&lt;<span class="number">&lt;1</span>) <span class="comment">//2: 10</span></div><div class="line">fmt.Printf(<span class="string">"%d: %b\n"</span>, i2&lt;<span class="number">&lt;7</span>, i2&lt;<span class="number">&lt;7</span>) <span class="comment">//-128: -10000000</span></div><div class="line">fmt.Printf(<span class="string">"%d: %b\n"</span>, i2&lt;<span class="number">&lt;8</span>, i2&lt;<span class="number">&lt;8</span>) <span class="comment">//0: 0</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> i3 <span class="typename">int8</span> =<span class="number"> -1</span></div><div class="line">fmt.Printf(<span class="string">"%d: %b\n"</span>, -i3&lt;<span class="number">&lt;1</span>, -i3&lt;<span class="number">&lt;1</span>) <span class="comment">//2: 10</span></div><div class="line">fmt.Printf(<span class="string">"%d: %b\n"</span>, -i3&lt;<span class="number">&lt;7</span>, -i3&lt;<span class="number">&lt;7</span>) <span class="comment">//-128: -10000000</span></div><div class="line">fmt.Printf(<span class="string">"%d: %b\n"</span>, -i3&lt;<span class="number">&lt;8</span>, -i3&lt;<span class="number">&lt;8</span>) <span class="comment">//0: 0</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> i4 <span class="typename">int8</span> =<span class="number"> -128</span></div><div class="line">fmt.Printf(<span class="string">"%d: %b\n"</span>, -i4&gt;<span class="number">&gt;0</span>, -i4&gt;<span class="number">&gt;0</span>) <span class="comment">//-64: -10000000</span></div><div class="line">fmt.Printf(<span class="string">"%d: %b\n"</span>, -i4&gt;<span class="number">&gt;1</span>, -i4&gt;<span class="number">&gt;1</span>) <span class="comment">//-64: -1000000</span></div><div class="line">fmt.Printf(<span class="string">"%d: %b\n"</span>, -i4&gt;<span class="number">&gt;2</span>, -i4&gt;<span class="number">&gt;2</span>) <span class="comment">//-32: -100000</span></div></pre></td></tr></table></figure>

<p>参考:</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/位操作#.E7.A7.BB.E4.BD.8D" target="_blank" rel="external">https://zh.wikipedia.org/wiki/位操作#.E7.A7.BB.E4.BD.8D</a></li>
</ul>
<p>一元操作符:</p>
<pre class="highlight">
+x                          is 0 + x
-x    negation              is 0 - x
^x    bitwise complement    is m ^ x  with m = "all bits set to 1" for unsigned x
                                      and  m = -1 for signed x
</pre>

<p><code>^x</code> 在C、C#、Java语言中中符号 <code>~</code>,在Go语言中用 <code>^</code>。对于无符号整数来说就是按位取反，对于有符号的整数来说,<br>是按照补码进行取反操作的。<code>-1</code>的补码为<code>11111111</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i1 <span class="typename">uint8</span> =<span class="number"> 3</span></div><div class="line"><span class="keyword">var</span> i2 <span class="typename">int8</span> =<span class="number"> 3</span></div><div class="line"><span class="keyword">var</span> i3 <span class="typename">int8</span> =<span class="number"> -3</span></div><div class="line"></div><div class="line">fmt.Printf(<span class="string">"^%b=%b %d\n"</span>, i1, ^i1, ^i1) <span class="comment">// ^11=11111100 252</span></div><div class="line">fmt.Printf(<span class="string">"^%b=%b %d\n"</span>, i2, ^i2, ^i2) <span class="comment">// ^11=-100 -4</span></div><div class="line">fmt.Printf(<span class="string">"^%b=%b %d\n"</span>, i3, ^i3, ^i3) <span class="comment">// ^-11=10 2</span></div></pre></td></tr></table></figure>

<p>无符号整数的+、-、*、&lt;&lt;的操作的结果会取模2^n， 也就是溢出的位会被丢掉， 比如uint8类型的数 &quot;255 + 2&quot; 会等于 1。</p>
<p>有符号整数的+、-、*、&lt;&lt;的操作的结果的溢出也不会导致异常，但是结果可能不是你想要的，比如x &lt; x+1并不总是成立。比如int8的两个值 &quot;127 + 2 = -127&quot;。</p>
<p>字符串也可以应用<code>+</code>、<code>+=</code>运算符：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s := <span class="string">"hi"</span> + <span class="typename">string</span>(c)</div><div class="line">s += <span class="string">" and good bye"</span></div></pre></td></tr></table></figure>

<h4 id="比较运算符">比较运算符</h4>
<pre class="highlight">
==    等于
!=    不等于
&lt     小于
&lt=    小于等于
&gt     大于
&gt=    大于等于
</pre>

<p><code>==</code>、<code>!=</code>比较相等性， 可比较comparable，<code>&lt;, &lt;=, &gt;, &gt;=</code>是有序运算符, ordered。</p>
<ul>
<li>布尔值: comparable</li>
<li>整数: comparable, ordered</li>
<li>浮点数: comparable, ordered</li>
<li>负数: comparable</li>
<li>字符串： comparable, ordered，根据字节比较</li>
<li>指针: comparable</li>
<li>Channel:  comparable</li>
<li>接口: comparable</li>
<li>一个非接口类型X的值x 可以和 一个接口类型T的值t进行比较: comparable</li>
<li>struct:  comparable 如果它的所有的字段都是comparable的话。<br>＊ 数组：comparable</li>
</ul>
<p>两个接口比较的时候可能导致运行时panic， 如果接口的动态类型的值不可比较的话。</p>
<p>slice、map和函数值都不可以比较，但是它们可以和预定义的零值nil进行比较。</p>
<h3 id="逻辑运算符">逻辑运算符</h3>
<pre class="highlight">
&&    conditional AND    p && q  is  "if p then q else false"
||    conditional OR     p || q  is  "if p then true else q"
!     NOT                !p      is  "not p"
</pre>

<h3 id="地址运算符">地址运算符</h3>
<p><code>&amp;x</code>取址</p>
<p><code>*x</code>取得指针指向的值</p>
<h3 id="receive运算符">receive运算符</h3>
<p>对于Channel类型的值ch, receive操作 <code>&lt;-ch</code>的值代表从ch中取出的一个值。<br>ch的声明时应该允许receive操作。</p>
<p>这个操作会阻塞，直到有值收到。</p>
<p>从一个nil channel中receive会一直阻塞。</p>
<p>从closed channel中的receive会以及处理，返回零值。</p>
<p>从ch中receive也可以用下面的格式:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">x, ok = &lt;-ch</div><div class="line">x, ok := &lt;-ch</div><div class="line"><span class="keyword">var</span> x, ok = &lt;-ch</div></pre></td></tr></table></figure>

<h3 id="Order_of_evaluation">Order of evaluation</h3>
<p>表达式的运算(评估)顺序。</p>
<p>包一级的变量声明中的表达式的运算顺序会根据它们的依赖，这个以后讲，其它的表达式的运算顺序都是从左向右计算。</p>
<p>比如一个函数内的下面的表达式:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">y[f()], ok = g(h(), i()+x[j()], &lt;-c), k()</div></pre></td></tr></table></figure>

<p>它的计算顺序为f(),  h(), i(), j(), &lt;-c, g(), k(),但是计算索引y[],x[]的顺序并没有指定。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a :=<span class="number"> 1</span></div><div class="line">f := <span class="keyword">func</span>() <span class="typename">int</span> { a++; <span class="keyword">return</span> a }</div><div class="line">x := []<span class="typename">int</span>{a, f()}            <span class="comment">// x may be [1, 2] or [2, 2]: evaluation order between a and f() is not specified</span></div><div class="line">m := <span class="keyword">map</span>[<span class="typename">int</span>]<span class="typename">int</span>{a:<span class="number"> 1</span>, a:<span class="number"> 2</span>}  <span class="comment">// m may be {2: 1} or {2: 2}: evaluation order between the two map assignments is not specified</span></div><div class="line">n := <span class="keyword">map</span>[<span class="typename">int</span>]<span class="typename">int</span>{a: f()}      <span class="comment">// n may be {2: 3} or {3: 3}: evaluation order between the key and the value is not specified</span></div></pre></td></tr></table></figure>

<p>对于包一级的变量声明中的表达式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a, b, c = f() + v(), g(), sqr(u()) + v()</div><div class="line"></div><div class="line"><span class="keyword">func</span> f() <span class="typename">int</span>        { <span class="keyword">return</span> c }</div><div class="line"><span class="keyword">func</span> g() <span class="typename">int</span>        { <span class="keyword">return</span> a }</div><div class="line"><span class="keyword">func</span> sqr(x <span class="typename">int</span>) <span class="typename">int</span> { <span class="keyword">return</span> x*x }</div></pre></td></tr></table></figure>

<p>顺序为 u(), sqr(), v(), f(), v(), g()。</p>
<p>下一章将介绍 类型转换(Conversion)、类型断言(type assertion) 和类型切换（type switch）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文介绍Go语言的表达式。</p>
<p>表达式代表一个值的计算， 计算通过运算符和函数应用在操作数上(operand)。<br>]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入Go语言 - 4]]></title>
    <link href="http://colobu.com/2016/06/20/dive-into-go-4/"/>
    <id>http://colobu.com/2016/06/20/dive-into-go-4/</id>
    <published>2016-06-20T04:35:19.000Z</published>
    <updated>2016-06-21T08:57:05.000Z</updated>
    <content type="html"><![CDATA[<p>本文介绍Go的声明和作用域。</p>
<a id="more"></a>
<p>声明用于常量、变量、类型、函数、标签和包。</p>
<p>每个非空标识符(identifier)必须声明。同一代码块中标识符只能声明一次。标识符不能同时声明在文件代码块和包代码块中。</p>
<p>空标识符为下划线 &quot;_&quot;，它可以做为匿名占位符。</p>
<p>一个声明的标识符的作用域总结如下：</p>
<ul>
<li>预声明的标识符的作用域是全局代码块如<code>int</code>、<code>true</code>等</li>
<li>顶层的(函数之外)的标识符， 用来声明常量、类型、变量或者函数(非方法), 这些标识符的作用域是包代码块</li>
<li>一个输入的包的包名的作用域是这个文件的文件代码块</li>
<li>用来表示方法 receiver、函数参数、结果变量的标识符的作用域是函数体</li>
<li>在一个函数内声明的常量或者变量的标识符的作用域起于ConstSpec 、 VarSpec之后(也就是标识符声明之后)， 结束于包含它的最内层的代码块尾部</li>
<li>函数内声明的类型标识符始于 TypeSpec， 结束于包含它的最内层的代码块尾部</li>
</ul>
<p>代码块中的标识符可以在内部的代码块中再次声明，但是内部的标识符和外部的标识符表示不同的对象，这个一定小心。</p>
<p><a href="https://golang.org/ref/spec#Package_clause" target="_blank" rel="external">package clause</a>并不是声明语句。<strong>包名不能出现在任何作用域中</strong>, 经常我们为了方便，声明一个变量的时候和包名一样，比如在引入<code>net/http</code>包的时候声明一个变量是<code>http</code>,这是不对的，这会导致变量名会隐藏(shadow)包名。</p>
<h3 id="标签作用域">标签作用域</h3>
<p>标签(label)作用域可以用于<code>break</code>、<code>continue</code>、<code>goto</code>语句，这在其它语言中也有定义，尽管不会推荐广泛应用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">i :=<span class="number"> 0</span></div><div class="line">回来:</div><div class="line">i++</div><div class="line">fmt.Println(i)</div><div class="line"><span class="keyword">if</span> i &lt;<span class="number"> 5</span> {</div><div class="line">  <span class="keyword">goto</span> 回来</div><div class="line">}</div></pre></td></tr></table></figure>

<p>定义一个未被使用的标签是非法的，这和函数内的定义未被使用的变量是一样的。</p>
<p>标签不会和其它同名的标识符冲突。</p>
<p>标签的作用域只在声明它的位置到函数体的尾部，不会作用于内部嵌套的函数。</p>
<h3 id="空标识符和预定义标识符">空标识符和预定义标识符</h3>
<p>空标识符前面已经提到了，下面是一些空标识符的应用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">	_ <span class="string">"net/http"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> _ = <span class="string">"hello world"</span></div><div class="line"><span class="keyword">var</span> _ =<span class="number"> 100</span></div><div class="line"><span class="keyword">type</span> _ []<span class="typename">int</span></div><div class="line"><span class="keyword">type</span> _ <span class="keyword">struct</span>{}</div><div class="line"><span class="keyword">type</span> _ <span class="keyword">interface</span>{}</div></pre></td></tr></table></figure>

<p>预定义的标识符<a href="http://colobu.com/2016/06/15/dive-into-go-1/" target="_blank" rel="external">第一章</a>中已经介绍了。</p>
<h3 id="输出标识符">输出标识符</h3>
<p>Go语言中没有 public、protect、private等关键字，如果想在其它包中访问当前包的标识符，<br>标识符应该具备下面两个条件,这和其它编程语言不太一样:<br>1、标识符名字的第一个字符应该是unicode upper case letter (Lu)<br>2、并且标识符声明在包代码块中，或者它是一个字段名或者方法名。</p>
<p>举个例子。<br>在当前的main程序所在的目录中创建一个目录p,在里面创建一个文件t.go,定义两个包作用域的变量:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> p</div><div class="line"></div><div class="line"><span class="keyword">var</span> str = <span class="string">"hello world"</span></div><div class="line"><span class="keyword">var</span> Str = <span class="string">"Hello World"</span></div></pre></td></tr></table></figure>

<p>然后在main程序中尝试访问package p下的这两个变量，会发现只能访问<code>Str</code>，<code>str</code>报错，说没有导出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line"></div><div class="line">	<span class="string">"./p"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	fmt.Println(p.str)</div><div class="line">	fmt.Println(p.Str)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>函数、常量、类型、struct、interface、方法都遵循这个法则。所以要想导出一个标识符，请首字母大写。</p>
<p>注意，这里要求的是首字母是unicode upper case letter,就是unicode分类为Lu的字符，对于Unicode字符，你需要知道哪些是大写字符,比如希腊字符也是有大小写的，中文不是大小写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> 一二三 = <span class="string">"123"</span> <span class="comment">//未输出</span></div><div class="line"><span class="keyword">var</span> Π =<span class="number"> 3.1415926</span> <span class="comment">//输出</span></div></pre></td></tr></table></figure>

<p>你可以在 <a href="http://www.fileformat.info/info/unicode/category/Lu/list.htm" target="_blank" rel="external">这里</a> 查看unicode 大写字符列表。</p>
<h3 id="iota">iota</h3>
<p>在常量定义中，<strong>iota</strong> 代表一个连续的未指定类型的整数常量。每当保留字const出现的时候，它都重置为0，后续的每个常量定义都会把它加一。 它常用来定义一组类似枚举的类型，比如月份、星期、颜色等。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ( <span class="comment">// iota is reset to 0</span></div><div class="line">	c0 = <span class="constant">iota</span>  <span class="comment">// c0 == 0</span></div><div class="line">	c1 = <span class="constant">iota</span>  <span class="comment">// c1 == 1</span></div><div class="line">	c2 = <span class="constant">iota</span>  <span class="comment">// c2 == 2</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> ( <span class="comment">// iota 重置为 0</span></div><div class="line">	a =<span class="number"> 1</span> &lt;&lt; <span class="constant">iota</span>  <span class="comment">// a == 1</span></div><div class="line">	b =<span class="number"> 1</span> &lt;&lt; <span class="constant">iota</span>  <span class="comment">// b == 2</span></div><div class="line">	c =<span class="number"> 3</span>          <span class="comment">// c == 3  (iota 虽然没有使用，但是还是会增加)</span></div><div class="line">	d =<span class="number"> 1</span> &lt;&lt; <span class="constant">iota</span>  <span class="comment">// d == 8</span></div><div class="line">)</div><div class="line"><span class="keyword">const</span> ( <span class="comment">// iota 重置为 0</span></div><div class="line">	u         = <span class="constant">iota</span> *<span class="number"> 42</span>  <span class="comment">// u == 0     (untyped integer constant)</span></div><div class="line">	v <span class="typename">float64</span> = <span class="constant">iota</span> *<span class="number"> 42</span>  <span class="comment">// v == 42.0  (float64 constant)</span></div><div class="line">	w         = <span class="constant">iota</span> *<span class="number"> 42</span>  <span class="comment">// w == 84    (untyped integer constant)</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> x = <span class="constant">iota</span>  <span class="comment">// x == 0  (iota 重置为 0)</span></div><div class="line"><span class="keyword">const</span> y = <span class="constant">iota</span>  <span class="comment">// y == 0  (iota 重置为 0)</span></div></pre></td></tr></table></figure>

<p>如果使用表达式列表，同一表达式的iota的值是相同的，因为只有遇到新的ConstSpec才会增加。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> (</div><div class="line">	bit0, mask0 =<span class="number"> 1</span> &lt;&lt; <span class="constant">iota</span>,<span class="number"> 1</span>&lt;&lt;<span class="constant">iota</span> -<span class="number"> 1</span>  <span class="comment">// bit0 == 1, mask0 == 0, iota = 0</span></div><div class="line">	bit1, mask1                           <span class="comment">// bit1 == 2, mask1 == 1, iota = 1</span></div><div class="line">	_, _                                  <span class="comment">// skips iota == 2</span></div><div class="line">	bit3, mask3                           <span class="comment">// bit3 == 8, mask3 == 7, iota =3</span></div><div class="line">)</div></pre></td></tr></table></figure>

<p>Go语言中没有枚举类型，所以一般通过下面的方式定义枚举类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Week <span class="typename">int</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> names = [...]<span class="typename">string</span>{<span class="string">"星期一"</span>, <span class="string">"星期二"</span>, <span class="string">"星期三"</span>, <span class="string">"星期四"</span>, <span class="string">"星期五"</span>, <span class="string">"星期六"</span>, <span class="string">"星期日"</span>}</div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">	Monday Week = <span class="constant">iota</span> +<span class="number"> 1</span></div><div class="line">	Tuesday</div><div class="line">	Wednesday</div><div class="line">	Thursday</div><div class="line">	Friday</div><div class="line">	Saturday</div><div class="line">	Sunday</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> (w Week) String() <span class="typename">string</span> {</div><div class="line">	<span class="keyword">if</span> w &gt;<span class="number"> 0</span> && w &lt;<span class="number"> 8</span> {</div><div class="line">		<span class="keyword">return</span> names[w<span class="number">-1</span>]</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="string">"非法的星期名"</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="函数声明">函数声明</h3>
<p>函数可以声明为签名，也可以定义方法体。</p>
<p>没有方法体的函数只有签名的函数可以声明在接口中，也可以声明包代码块中，此时标明方法是由外部实现的，比如汇编语言。</p>
<p>如果函数声明了返回类型，那么方法体中必须有相应的return语句。</p>
<p>匿名函数又叫函数字面量，它不包含函数名，可以用来赋值给变量(比如在一个函数内或者外赋值给一个变量)、或者直接调用(比如go语句中)。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">f := <span class="keyword">func</span>(x, y <span class="typename">int</span>) <span class="typename">int</span> { <span class="keyword">return</span> x + y }</div><div class="line"><span class="keyword">func</span>(ch <span class="keyword">chan</span> <span class="typename">int</span>) { ch &lt;- ACK }(replyChan)</div><div class="line"><span class="keyword">go</span> <span class="keyword">func</span>(ch <span class="keyword">chan</span> <span class="typename">int</span>) { ch &lt;- ACK }(replyChan)</div></pre></td></tr></table></figure>

<h3 id="方法声明">方法声明</h3>
<p>方法声明类似函数声明，但是它包含一个接受者receiver。</p>
<p>在方法名的前面要声明一个额外的参数，这个参数是单一的，不可变的，作为receiver，<br>它的类型为<code>T</code>或者<code>*T</code>，T叫做receiver base type。</p>
<p>注意<code>T</code>不能是指针类型或者皆苦类型，并且必须和方法声明在同一个包下。你想在自己的包下为标准库中的类型定义一个方法是不行的。</p>
<p>方法名仅仅在类型T 或者 *T的 selector中显示。</p>
<p>receiver名不能和参数名或者返回参数重名：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//错误</span></div><div class="line"><span class="keyword">func</span> (i IntArr) Say(i <span class="typename">int</span>) (i <span class="typename">int</span>) {</div><div class="line">	<span class="keyword">return</span><span class="number"> 0</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>方法名唯一。</p>
<p>对于struct类型，方法名和字段名必须唯一。</p>
<p>方法的特性和selector在下一章的表达式介绍。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文介绍Go的声明和作用域。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Scala集合技术手册出版了]]></title>
    <link href="http://colobu.com/2016/06/19/scala-collections-cookbook-is-available/"/>
    <id>http://colobu.com/2016/06/19/scala-collections-cookbook-is-available/</id>
    <published>2016-06-19T09:45:47.000Z</published>
    <updated>2016-06-21T08:57:05.000Z</updated>
    <content type="html"><![CDATA[<p>拙著《Scala集合技术手册》出版了，详细信息请看 <a href="/ScalaCollectionsCookbook/">这里</a>。</p>
<p>这是我在学习和使用Scala过程中的技术总结和探索。</p>
<p>市面上第一本全面介绍Scala集合框架的图书。</p>
<p>首部国人原创中文Scala图书。</p>
<p><strong>编辑推荐</strong><br>√ Scala集合库不可多得的中文资料<br>√ 作为Scala的制胜法宝本书教你如何驾驭<br>√ 面向实际问题用示例代码讲解类的使用和原理<br>√ 全新角度实现基本数据结构是提升功力的不二法门</p>
<p><strong>挖财架构师《 Scala 函数式编程》译者 王宏江 作序</strong></p>
<p><strong>推荐</strong><br>√ 极牛创始人 CEO 吴际超<br>√ 《快学Scala》译者 高宇翔<br>√ 阿里巴巴 善马(柴克斌)<br>√ 联想 柴明贵</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>拙著《Scala集合技术手册》出版了，详细信息请看 <a href="/ScalaCollectionsCookbook/">这里</a>。</p>
<p>这是我在学习和使用Scala过程中的技术总结和探索。</p>
<p>市面上第一本全面介绍Scala集合框架的图书。</]]>
    </summary>
    
      <category term="Scala" scheme="http://colobu.com/tags/Scala/"/>
    
      <category term="Scala" scheme="http://colobu.com/categories/Scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入Go语言 - 3]]></title>
    <link href="http://colobu.com/2016/06/16/dive-into-go-3/"/>
    <id>http://colobu.com/2016/06/16/dive-into-go-3/</id>
    <published>2016-06-16T05:24:22.000Z</published>
    <updated>2016-06-21T08:57:05.000Z</updated>
    <content type="html"><![CDATA[<p>本文介绍Go的类型系统,以及类型的比较和语句块。</p>
<p>Go语言包含11种类型，你应该很熟悉了，下面让我们再深入的了解一下每种类型的细节。</p>
<ul>
<li>布尔类型</li>
<li>数值类型</li>
<li>字符串类型</li>
<li>数组类型</li>
<li>Slice类型</li>
<li>Struct类型</li>
<li>指针类型</li>
<li>函数类型</li>
<li>接口类型</li>
<li>Map类型</li>
<li>Channel类型</li>
</ul>
<a id="more"></a>
<p>bool、数值型类型、rune、字符串都是预定义的类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="typename">bool</span> <span class="typename">byte</span> <span class="typename">complex64</span> <span class="typename">complex128</span> error <span class="typename">float32</span> <span class="typename">float64</span></div><div class="line"><span class="typename">int</span> <span class="typename">int8</span> <span class="typename">int16</span> <span class="typename">int32</span> <span class="typename">int64</span> <span class="typename">rune</span> <span class="typename">string</span></div><div class="line"><span class="typename">uint</span> <span class="typename">uint8</span> <span class="typename">uint16</span> <span class="typename">uint32</span> <span class="typename">uint64</span> <span class="typename">uintptr</span></div></pre></td></tr></table></figure>

<p>复合类型array, struct, pointer, function, interface, slice, map 和 channel 由类型字面量构造而成。</p>
<p>每一个类型都有一个底层类型(underlying type),比如下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> T1 <span class="typename">string</span></div><div class="line"><span class="keyword">type</span> T2 T1</div><div class="line"><span class="keyword">type</span> T3 []T1</div><div class="line"><span class="keyword">type</span> T4 T3</div></pre></td></tr></table></figure>

<p><code>string</code>、<code>T1</code>、<code>T2</code>的底层类型</p>
<ul>
<li><strong>命名类型(named type)</strong> : 由一个确定的类型的名称指定</li>
<li><strong>未命名类型(unamed type)</strong>:由类型字面量指定，类型字面量由既有的类型组成</li>
</ul>
<p>比如下面的例子中, x的类型就是未命名类型，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x <span class="keyword">struct</span>{ I <span class="typename">int</span> }</div></pre></td></tr></table></figure>

<p>而下面的例子中，y的类型就是命名类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span>{ I <span class="typename">int</span> }</div><div class="line"><span class="keyword">var</span> y Foo</div></pre></td></tr></table></figure>

<p>未命名类型的一个重要属性就是用同样类型的未命名类型声明的变量拥有相同的类型，而两个不同的命名类型，即使底层的类型相同，它们的类型也是不同的。<br>更详细的总结会在下一篇文章中介绍，比如我们再定义两个类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x2 <span class="keyword">struct</span>{ I <span class="typename">int</span> }</div><div class="line"><span class="keyword">type</span> Bar <span class="keyword">struct</span>{ I <span class="typename">int</span> }</div><div class="line"><span class="keyword">var</span> y2 Bar</div></pre></td></tr></table></figure>

<p>其中 <strong>x</strong> 和 <strong>x2</strong> 的类型相同， 而 <strong>y</strong> 和 <strong>y2</strong> 的类型却不相同。</p>
<p>命名类型可以定义自己的函数， 而未命名类型确不行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (f *Foo) Hello() {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (a []<span class="typename">int</span>) Hello() { <span class="comment">//错误, []int是未命名类型</span></div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>比如上例中，<code>[]int</code>是未命名类型，没办法为它定义方法,所以我们可以像下面的例子一样定义一个命名类型，它的底层类型是<code>[]int</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> IntArr []<span class="typename">int</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> (ia *IntArr) Hello() {</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>参考</p>
<ul>
<li><a href="https://github.com/golang/go/issues/5682" target="_blank" rel="external">https://github.com/golang/go/issues/5682</a></li>
<li><a href="http://stackoverflow.com/questions/32983546/named-and-unnamed-types" target="_blank" rel="external">http://stackoverflow.com/questions/32983546/named-and-unnamed-types</a></li>
<li><a href="http://blog.csdn.net/hittata/article/details/51250179" target="_blank" rel="external">http://blog.csdn.net/hittata/article/details/51250179</a></li>
</ul>
<h3 id="布尔类型">布尔类型</h3>
<p>很简单，类型名为<code>bool</code>,只有两个值： <code>true</code> 和 <code>false</code>。</p>
<p>参考</p>
<ul>
<li><a href="https://github.com/golang/go/issues/15171" target="_blank" rel="external">https://github.com/golang/go/issues/15171</a></li>
</ul>
<h3 id="数值类型">数值类型</h3>
<p>数值类型包括整数、浮点数和复数。总结如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>uint8</td>
<td>无符号8位整数，(0 to 255)｜</td>
</tr>
<tr>
<td>uint16</td>
<td>无符号16位整数， (0 to 65535)</td>
<td></td>
</tr>
<tr>
<td>uint32</td>
<td>无符号32位整数， (0 to 4294967295)</td>
</tr>
<tr>
<td>uint64</td>
<td>无符号64位整数， (0 to 18446744073709551615)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>int8</td>
<td>8位整数， (-128 to 127)</td>
</tr>
<tr>
<td>int16</td>
<td>16位整数， (-32768 to 32767)</td>
</tr>
<tr>
<td>int32</td>
<td>16位整数， (-2147483648 to 2147483647)</td>
</tr>
<tr>
<td>int64</td>
<td>64位整数， (-9223372036854775808 to 9223372036854775807)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>float32</td>
<td>IEEE-754 32位浮点数</td>
</tr>
<tr>
<td>float64</td>
<td>IEEE-754 64位浮点数</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>complex64</td>
<td>实部和虚部都是float32</td>
</tr>
<tr>
<td>complex128</td>
<td>实部和虚部都是float32</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>byte</td>
<td>uint8的别名</td>
</tr>
<tr>
<td>rune</td>
<td>int32的别名</td>
</tr>
</tbody>
</table>
<p>在不同的架构上，下面的几种类型可能的位数不同：<br><code>uint</code>可能是32位或者64位<br><code>int</code>可能是32位或者64位<br><code>uintptr</code> 是一个足够大的无符号整数，可以代表一个指针的值得</p>
<p><code>int</code>和<code>int32</code>并不是一个相同的类型，尽管在一些环境下它们的位数都是32位。</p>
<h3 id="数组类型">数组类型</h3>
<p>数组代表有限的同一元素类型的对象的序列。对象的数量就是数组的长度， 通过<code>len</code>方法得到。</p>
<p>数组是一维的，但是你可以构造多维数组：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">[3</span>]<span class="number">[5</span>]<span class="typename">int</span></div><div class="line"><span class="number">[2</span>]<span class="number">[2</span>]<span class="number">[2</span>]<span class="typename">float64</span>  <span class="comment">// 等价 [2]([2]([2]float64))</span></div></pre></td></tr></table></figure>

<p>数组可以通过下面的方式声明，需要指定它的长度：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> buffer <span class="number">[256</span>]<span class="typename">byte</span></div></pre></td></tr></table></figure>

<p>声明和初始化可以合在一起：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">buffer := <span class="number">[10</span>]<span class="typename">string</span>{}             <span class="comment">// len(buffer) == 10</span></div><div class="line">intSet := <span class="number">[6</span>]<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>,<span class="number"> 5</span>}       <span class="comment">// len(intSet) == 6</span></div><div class="line">days := [...]<span class="typename">string</span>{<span class="string">"Sat"</span>, <span class="string">"Sun"</span>}  <span class="comment">// len(days) == 2</span></div></pre></td></tr></table></figure>

<p><code>[...]</code>是根据初始化的元素的数量确定数组的长度。</p>
<h3 id="Slice类型">Slice类型</h3>
<p>实际在开发的过程中，我们使用数组的场合比较少，这是因为数组一旦定义，它的长度就不能再发生变化，这和很多其它编程语言的定义是一样的。<br>更多的情况下我们会使用slice。</p>
<p>Slice描述了数组的一个连续的片段。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> slice []<span class="typename">byte</span> = buffer<span class="number">[100</span><span class="number">:150</span>]</div></pre></td></tr></table></figure>

<p>上面的例子中<code>slice</code>对象代表数组的索引位置为100 ~149的元素。</p>
<p>其实slice数据结构是由<code>SliceHeader</code>描述的,所以我们可以看到slice是由三个数据描述的：<code>第0个元素的指针</code>、<code>长度</code>、<code>容量</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> {</div><div class="line">        Data <span class="typename">uintptr</span></div><div class="line">        Len  <span class="typename">int</span></div><div class="line">        Cap  <span class="typename">int</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>在后面的文章中我会介绍通过指针操作SliceHeader。</p>
<p>slice可以从数组中生成，如上面的例子，也可以直接生成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1 []<span class="typename">int</span></div><div class="line"><span class="keyword">var</span> s2 = <span class="built_in">make</span>([]<span class="typename">int</span>,<span class="number"> 10</span>)</div><div class="line"><span class="keyword">var</span> s3 = <span class="built_in">make</span>([]<span class="typename">int</span>,<span class="number"> 10</span>,<span class="number"> 20</span>)</div><div class="line"></div><div class="line">fmt.Printf(<span class="string">"len:%d, cap:%d\n"</span>, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</div><div class="line">fmt.Printf(<span class="string">"len:%d, cap:%d\n"</span>, <span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2))</div><div class="line">fmt.Printf(<span class="string">"len:%d, cap:%d\n"</span>, <span class="built_in">len</span>(s3), <span class="built_in">cap</span>(s3))</div></pre></td></tr></table></figure>

<p>在生成的时候可以指定slice的长度和容量，如果没有指定容量(make的第三个参数)，则容量和长度相同。<br>如果不是通过<code>make</code>创建，而是通过<code>var</code>的方式声明一个零值的slice，则它的长度和容量都为0。</p>
<p>一旦一个slice创建出来，它的底层元素是由一个数组保存着。slice的容量就是这个数组的长度，可以通过<code>cap</code>获得。<br>如果slice的元素的数量超过容量，就需要创建新的数组。这是一个值得注意的地方，如果你初始的时候就可以确定元素的最大数量的情况下，<br>最好设置slice的容量的值，这样避免数组的重新分配和数据拷贝，提高程序的性能。</p>
<h4 id="index,_append,_remove_和_copy">index, append, remove 和 copy</h4>
<p>slice和数组一样，都是可以通过索引得到某个位置的元素。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a := [...]<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>,<span class="number"> 4</span>,<span class="number"> 5</span>}</div><div class="line"><span class="keyword">var</span> s = a[:]</div><div class="line"></div><div class="line">fmt.Printf(<span class="string">"%d\n"</span>, s<span class="number">[0</span>])</div><div class="line">fmt.Printf(<span class="string">"%d/n"</span>, s<span class="number">[10</span>])<span class="comment">//panic: runtime error: index out of range</span></div></pre></td></tr></table></figure>

<p>如果超出slice的索引最大值，就会导致panic。</p>
<p>可以往slice增加元素：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">s2 := <span class="built_in">append</span>(s,<span class="number"> 6</span>)</div><div class="line">fmt.Printf(<span class="string">"s: %#v\ns2:%#v\n"</span>, s, s2)</div><div class="line"></div><div class="line"><span class="comment">//output:</span></div><div class="line"><span class="comment">//s: []int{1, 2, 3, 4, 5}</span></div><div class="line"><span class="comment">//s2:[]int{1, 2, 3, 4, 5, 6}</span></div></pre></td></tr></table></figure>

<p>通过<code>append</code>方法可以往slice增加元素，值得注意的是append的返回值是增加元素后的slice，和原始的slice不同，尽管它们底层的数组可能相同。<br>如果容量足够，元素就继续增加底层数组中，如果容量不够，则结果slice就会创建新的数组。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> <span class="built_in">append</span>(slice []Type, elems ...Type) []Type</div></pre></td></tr></table></figure>

<p>你可以往slice一次增加多个元素：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">slice = <span class="built_in">append</span>(slice, elem1, elem2)</div><div class="line">slice = <span class="built_in">append</span>(slice, anotherSlice...)</div></pre></td></tr></table></figure>

<p>注意<code>...</code>写法，它意味着你可以把一个slice中所有的元素全部增加到另外一个slice的尾部:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s3 := <span class="built_in">append</span>(s, s...)</div><div class="line">fmt.Printf(<span class="string">"s: %#v\ns3:%#v\n"</span>, s, s3)</div></pre></td></tr></table></figure>

<p>一个值得注意的技巧是可以将一个字符串的byte一次都增加到一个 []byte中:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s4 := <span class="built_in">append</span>([]<span class="typename">byte</span>(<span class="string">"hello "</span>), <span class="string">"world"</span>...)</div></pre></td></tr></table></figure>

<p>要删除slice某个索引的位置，可以通过下面的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s5 := <span class="built_in">append</span>(s[<span class="number">:2</span>], s<span class="number">[3</span>:]...)</div><div class="line">fmt.Printf(<span class="string">"s: %#v\ns5:%#v\n"</span>, s, s5)</div></pre></td></tr></table></figure>

<p>这个例子删除索引2处的元素。</p>
<p>slice的拷贝是通过<code>copy</code>方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> <span class="built_in">copy</span>(dst, src []Type) <span class="typename">int</span></div></pre></td></tr></table></figure>

<p>返回结果为 dst和src的长度的最小值。这也就是说，如果dst的长度大，则将src全部元素都复制到dst中。如果src的长度大，则将src的len(dst)个元素复制到dst中。</p>
<h4 id="slice类型再深入">slice类型再深入</h4>
<p>因为slice底层使用数组，而这个数组可能在数组和多个slice中共用，这会带来潜在的问题。</p>
<p>1、对数组中元素的更改会影响slice<br>下面的例子中我们将数组的第一个值改为100,可以看到slice的第一个值也变了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a := [...]<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>,<span class="number"> 4</span>,<span class="number"> 5</span>}</div><div class="line"><span class="keyword">var</span> s = a[:]</div><div class="line"></div><div class="line">a<span class="number">[0</span>] =<span class="number"> 100</span></div><div class="line">fmt.Printf(<span class="string">"a: %#v\ns:%#v\n"</span>, a, s)</div></pre></td></tr></table></figure>

<p>2、如果slice使用不同的数组，则不会有影响<br>这一条是显而易见的，既然数组都不相同了，当然也没有什么影响了。<br>但是有时候你不是很容易的发现:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a := [...]<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>,<span class="number"> 4</span>,<span class="number"> 5</span>}</div><div class="line"><span class="keyword">var</span> s = a[:]</div><div class="line">s = <span class="built_in">append</span>(s,<span class="number"> 6</span>)</div><div class="line"></div><div class="line">a<span class="number">[0</span>] =<span class="number"> 100</span></div><div class="line">fmt.Printf(<span class="string">"a: %#v\ns:%#v\n"</span>, a, s)</div></pre></td></tr></table></figure>

<p>第三行在增加6到数组的尾部的时候，其实slice的容量已经不够了，所以为返回结果的slice新建了数组。<br>因此对原始数组的更改不会影响s2,但是对s却有影响，s的第一个值也变了。</p>
<p>3、当两个slice有重叠时，可能会有影响</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">a := [...]<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>,<span class="number"> 4</span>,<span class="number"> 5</span>}</div><div class="line">s1 := a<span class="number">[0</span><span class="number">:1</span>]</div><div class="line">s2 := a<span class="number">[0</span><span class="number">:2</span>]</div><div class="line"></div><div class="line">s1 = <span class="built_in">append</span>(s1,<span class="number"> 100</span>)</div><div class="line"></div><div class="line">fmt.Printf(<span class="string">"a: %#v\ns1:%#v\ns2:%#v\n"</span>, a, s1, s2)</div></pre></td></tr></table></figure>

<p>这个例子s1和s2都使用相同的数组a,而且它们的容量都是5，不同的是它们的长度分别是2和3。</p>
<p>当往s1增加增加一个元素的时候，它事实上将元素放在的数组的索引为2的位置。这会对原始数组和s2都有影响，<br>看到检查输出的结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">a</span>: <span class="attr_selector">[5]</span><span class="tag">int</span><span class="rules">{<span class="rule">1, 100, 3, 4, 5}</span></span></div><div class="line"><span class="tag">s1</span>:<span class="attr_selector">[]</span><span class="tag">int</span><span class="rules">{<span class="rule">1, 100}</span></span></div><div class="line"><span class="tag">s2</span>:<span class="attr_selector">[]</span><span class="tag">int</span><span class="rules">{<span class="rule">1, 100}</span></span></div></pre></td></tr></table></figure>

<p>4、 copy的时候有重叠<br>调用<code>copy</code>方法的时候也可能会产生副作用，比如下面的例子，copy到s1的操作导致底层的数组改变了，影响了a,s1,s2的值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a := [...]<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>,<span class="number"> 4</span>,<span class="number"> 5</span>}</div><div class="line">s1 := a<span class="number">[0</span><span class="number">:3</span>]</div><div class="line">s2 := a<span class="number">[1</span><span class="number">:5</span>]</div><div class="line"><span class="built_in">copy</span>(s1, s2)</div><div class="line"></div><div class="line">fmt.Printf(<span class="string">"a: %#v\ns1:%#v\ns2:%#v\n"</span>, a, s1, s2)</div></pre></td></tr></table></figure>

<p>参考</p>
<ul>
<li><a href="https://blog.golang.org/slices" target="_blank" rel="external">https://blog.golang.org/slices</a></li>
<li><a href="https://golang.org/pkg/unsafe/" target="_blank" rel="external">https://golang.org/pkg/unsafe/</a></li>
</ul>
<h3 id="字符串类型">字符串类型</h3>
<p>字符串类型(string)是一个常用的类型，它的值是一组基本按照UTF-8编码的字节序列，可以为空。<br>在前一篇文章中我已经介绍了字符串类型，所以此处不再重复介绍了，我会介绍一些有趣的性能。</p>
<p>字符串是不可变的，一旦创建，它的值就不能修改了。</p>
<p>内建的<code>len</code>方法可以得到字符串的长度，每个字节可以根据索引得到，不能像 C 语言一样得到某个字节的地址，<code>&amp;s[i]</code>这样做是非法的。</p>
<p>你可以把字符串看成一个不可变的slice，比如根据索引得到某个位置的字节，copy操作, append 字符串到[]byte中等：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">s := <span class="string">"hello world"</span></div><div class="line">b := <span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number"> 5</span>)</div><div class="line"><span class="built_in">copy</span>(b, s)</div><div class="line">fmt.Println(s<span class="number">[0</span>])</div><div class="line">fmt.Println(b)</div><div class="line">fmt.Println(<span class="built_in">append</span>([]<span class="typename">byte</span>{}, s...))</div></pre></td></tr></table></figure>

<p>字符串和slices of bytes可以很方便的进行互转，因为它们的结构类似，底层都是通过一个数组保存元素的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">s := <span class="string">"hello world"</span></div><div class="line">b := []<span class="typename">byte</span>(s)</div><div class="line">s = <span class="typename">string</span>(b)</div></pre></td></tr></table></figure>

<p>通常情况下，这种转换是对底层数组的复制，所以对转换后的slice的更改不会影响原来的字符串，这也保证了字符串的不可变。</p>
<p>但是，数组的复制是有代价的，内存的分配和数据的拷贝以及垃圾回收都会带来性能等开销，所以在追求性能的场合，比如一些Web框架中，<br>采用来了一些&quot;花招&quot;实现&quot;零拷贝&quot;。</p>
<p>首先我们看看stirng和slice的数据结构是怎么样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> {</div><div class="line">        Data <span class="typename">uintptr</span></div><div class="line">        Len  <span class="typename">int</span></div><div class="line">        Cap  <span class="typename">int</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> {</div><div class="line">        Data <span class="typename">uintptr</span></div><div class="line">        Len  <span class="typename">int</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>看起来结构类似明知不过slice对string多了一个Cap字段。<br>所以我们可以根据它们的结构进行转换，不需要拷贝底层的数据Data:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"reflect"</span></div><div class="line">	<span class="string">"unsafe"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	s := <span class="string">"hello world"</span></div><div class="line">	b := StringToBytes(s)</div><div class="line">	s = BytesToString(b)</div><div class="line"></div><div class="line">	fmt.Printf(<span class="string">"%s\n"</span>, s)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> BytesToString(b []<span class="typename">byte</span>) <span class="typename">string</span> {</div><div class="line">	bytesHeader := (*reflect.SliceHeader)(unsafe.Pointer(&b))</div><div class="line">	strHeader := reflect.StringHeader{bytesHeader.Data, bytesHeader.Len}</div><div class="line">	<span class="keyword">return</span> *(*<span class="typename">string</span>)(unsafe.Pointer(&strHeader))</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> StringToBytes(s <span class="typename">string</span>) []<span class="typename">byte</span> {</div><div class="line">	strHeader := (*reflect.StringHeader)(unsafe.Pointer(&s))</div><div class="line">	bytesHeader := reflect.SliceHeader{strHeader.Data, strHeader.Len, strHeader.Len}</div><div class="line">	<span class="keyword">return</span> *(*[]<span class="typename">byte</span>)(unsafe.Pointer(&bytesHeader))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>整数之间、整数和字符串之间、slice和整数之间的转换放在数据转换一文中专门介绍。<br>参考</p>
<ul>
<li><a href="https://golang.org/src/runtime/string.go" target="_blank" rel="external">https://golang.org/src/runtime/string.go</a></li>
<li><a href="https://golang.org/pkg/reflect/#SliceHeader" target="_blank" rel="external">https://golang.org/pkg/reflect/#SliceHeader</a></li>
<li><a href="https://github.com/alecthomas/unsafeslice" target="_blank" rel="external">https://github.com/alecthomas/unsafeslice</a></li>
</ul>
<h3 id="Struct类型">Struct类型</h3>
<p>了解C语言的同学都知道struct(结构体)。</p>
<p>struct是一组命名的元素的序列，每个元素都有名字和类型，这些元素叫做结构体的字段(field)。字段名可能显示地指定，也可能隐式地指定。字段名不能重复。</p>
<p>struct类型有很多有趣的特性。</p>
<p>1、匿名字段<br>空字段、占位字段自不必说，你应该都已经了解了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> A <span class="keyword">struct</span>{}</div><div class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> {</div><div class="line">	i1 <span class="typename">uint16</span></div><div class="line">	_  <span class="typename">int16</span></div><div class="line">	i2 <span class="typename">int</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>struct还允许定义匿名字段。 匿名字段指声明了类型的字段，也叫嵌入字段或者嵌入类型。嵌入类型由类型名T或者指向非接口类型的指针*T指定。T本身不能再是指针类型。 类型名作为字段的名字。</p>
<p>下面的例子中的结构体包含四个匿名字段，可以看到包名不会作为字段名的一部分。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> {</div><div class="line">	T1        <span class="comment">// 字段名 T1</span></div><div class="line">	*T2       <span class="comment">// 字段名 T2</span></div><div class="line">	P.T3      <span class="comment">// 字段名 T3</span></div><div class="line">	*P.T4     <span class="comment">// 字段名 T4</span></div><div class="line">	x, y <span class="typename">int</span>  <span class="comment">// 字段名 x 和 y</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>下面的结构体的定义是非法的，因为三个字段重名了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> {</div><div class="line">	T     </div><div class="line">	*T    </div><div class="line">	*P.T  </div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果结构体x有一个嵌入字段E,并且E拥有字段或者方法f，那么你可以直接调用x.f (如果x.f是一个合法的selector的话)，<br>这叫做字段提升(promoted)。</p>
<p>提升的字段就像结构体的正常的字段一样，除了初始化的时候不能像普通的字段设置。</p>
<p>假设有一个struct S和一个类型T, 提升的方法有以下的特性：</p>
<ul>
<li>如果 <code>S</code> 包含一个嵌入字段 <code>T</code>, 那么 <code>S</code> 和 <code>*S</code> 的方法集包含 receiver <code>T</code>的方法. 而 <code>*S</code> 还包含 receiver <code>*T</code>的方法.</li>
<li>如果 <code>S</code> 包含一个嵌入字段 <code>*T</code>, 那么 <code>S</code> 和 <code>*S</code> 的方法集都包含 receiver <code>T</code> 和 <code>*T</code>的方法.</li>
</ul>
<p><code>*S</code> 可以直接访问 <code>S</code> 的方法，而不必求值后再访问。</p>
<p>关于方法集和receiver我们在以后再讲。</p>
<p>字段的声明中还可以包含一个缺省的字符串tag, 用来作为这个字段的属性，通过反射可以得到这个tag的值，在类型比较的时候会进行比较。经常用在结构体的序列化反序列化中,序列化库可以根据这些tag将相应的字段转换成合适的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> ColorGroup <span class="keyword">struct</span> {</div><div class="line">	Id     <span class="typename">int</span>      <span class="string">`json:"id" xml:"id,attr" msg:"id"`</span></div><div class="line">	Name   <span class="typename">string</span>   <span class="string">`json:"name" xml:"name" msg:"name"`</span></div><div class="line">	Colors []<span class="typename">string</span> <span class="string">`json:"colors" xml:"colors" msg:"colors"`</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>struct本身也可以是匿名的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">struct</span> {</div><div class="line">	Name <span class="typename">string</span></div><div class="line">}{<span class="string">"鸟窝"</span>}</div></pre></td></tr></table></figure>

<p>但是不能把一个匿名struct作为匿名字段，因为Go不知道如何命名此字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>

<p>所以必须为匿名struct字段命名，初始化的时候还挺麻烦：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> u = <span class="keyword">struct</span> {</div><div class="line">	Age  <span class="typename">int</span></div><div class="line">	Name <span class="keyword">struct</span> {</div><div class="line">		FirstName <span class="typename">string</span></div><div class="line">		LastName  <span class="typename">string</span></div><div class="line">	}</div><div class="line">}{Age:<span class="number"> 18</span>, Name: <span class="keyword">struct</span> {</div><div class="line">	FirstName <span class="typename">string</span></div><div class="line">	LastName  <span class="typename">string</span></div><div class="line">}{<span class="string">"鸟"</span>, <span class="string">"窝"</span>}}</div></pre></td></tr></table></figure>

<h3 id="指针类型">指针类型</h3>
<p>指针类型相对于于C语言，是一个简化版的指针，避免了C语言指针复杂的计算带来的陷阱。</p>
<p>指针类型就是在原有的类型前面加星号 <code>*</code>。</p>
<p>假设有个操作数x, 类型为T, 那么 <code>&amp;T</code>则为x的指针，类型为 <code>*T</code>。</p>
<p>你可以声明指向指针的指针:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x :=<span class="number"> 10</span></div><div class="line">p := &x</div><div class="line"><span class="keyword">var</span> pp **<span class="typename">int</span> = &p</div><div class="line">fmt.Printf(<span class="string">"%d\n"</span>, **pp)</div></pre></td></tr></table></figure>

<p>但是不能像C语言一样直接移动指针:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x := [...]<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>,<span class="number"> 4</span>,<span class="number"> 5</span>}</div><div class="line">p := &x</div><div class="line">p = p +<span class="number"> 1</span></div><div class="line">fmt.Printf(<span class="string">"%d\n"</span>, *p)</div></pre></td></tr></table></figure>

<p>虽然我们不能直接移动指针，但是我们可以通过曲折的方法操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">x := [...]<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>,<span class="number"> 4</span>,<span class="number"> 5</span>}</div><div class="line">p := &x<span class="number">[0</span>]</div><div class="line"></div><div class="line"><span class="comment">//p = p + 1</span></div><div class="line">index2Pointer := unsafe.Pointer(<span class="typename">uintptr</span>(unsafe.Pointer(p)) + unsafe.Sizeof(x<span class="number">[0</span>]))</div><div class="line">p = (*<span class="typename">int</span>)(index2Pointer) <span class="comment">//x[1]</span></div><div class="line">fmt.Printf(<span class="string">"%d\n"</span>, *p)    <span class="comment">//2</span></div></pre></td></tr></table></figure>

<p>这个例子中我们成功地将指针移动到第二个索引处，虽然它和 &amp;x[1]的功能是一样的，但却表明我们可以根据偏移量计算指针。<br>这种方法更多的应用到struct的字段值的读取中，一些序列化的库通过它来读取struct字段的值。</p>
<p>首先我们认识两个对象: <code>uintptr</code>和<code>unsafe.Pointer</code>。<br><code>uintptr</code>是一个足够大的整数，用来存放指针的位。</p>
<p><code>unsafe.Pointer</code>定义如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> ArbitraryType <span class="typename">int</span>  <span class="comment">// shorthand for an arbitrary Go type; it is not a real type</span></div><div class="line"><span class="keyword">type</span> Pointer *ArbitraryType</div></pre></td></tr></table></figure>

<p>Pointer代表指向任意类型的指针，它有四个独有的操作：<br>1) 任意类型的指针可以被转换成一个 Pointer对象.<br>2) 相反一个Pointer也可以转换成任意类型的指针.<br>3) 一个uintptr可以转换成一个Pointer.<br>4) 相反一个Pointer可以转换成uintptr.</p>
<p>通过Pointer我们就可以直接读取内存，使用起来要格外小心。<br>下面列出了几种转换：<br>1、*T -&gt;  Pointer to T2</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i <span class="typename">int64</span> =<span class="number"> 100</span></div><div class="line"><span class="keyword">var</span> p *<span class="typename">int64</span> = &i <span class="comment">//*int64</span></div><div class="line">P := unsafe.Pointer(p)</div></pre></td></tr></table></figure>

<p>2、Pointer to T2 -&gt; *T</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i <span class="typename">int64</span> =<span class="number"> 100</span></div><div class="line"><span class="keyword">var</span> p *<span class="typename">int64</span> = &i <span class="comment">//*int64</span></div><div class="line"></div><div class="line">P := unsafe.Pointer(p)</div><div class="line"></div><div class="line">p2 := (*<span class="typename">int32</span>)(P) <span class="comment">//*int32</span></div><div class="line">fmt.Println(*p2)</div></pre></td></tr></table></figure>

<p>3、Pointer -&gt; uintptr</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i <span class="typename">int64</span> =<span class="number"> 200</span>&lt;<span class="number">&lt;32</span> +<span class="number"> 100</span></div><div class="line"><span class="keyword">var</span> p = &i</div><div class="line">P0 := unsafe.Pointer(p)</div><div class="line"></div><div class="line">P := unsafe.Pointer(<span class="typename">uintptr</span>(P0) +<span class="number"> 4</span>)</div><div class="line">p2 := (*<span class="typename">int32</span>)(P)</div><div class="line"></div><div class="line">fmt.Println(*p2) <span class="comment">//200</span></div></pre></td></tr></table></figure>

<p>4、uintptr -&gt; Pointer<br>同上, Pointer(uintptr)转换即可。</p>
<p>内建的<code>new</code>函数可以为类型T创建零值的对象,它返回的对象类型为<code>*T</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i = <span class="built_in">new</span>(<span class="typename">int</span>)</div><div class="line"><span class="keyword">var</span> s = <span class="built_in">new</span>(<span class="typename">string</span>)</div><div class="line"><span class="keyword">var</span> j = <span class="built_in">new</span>(<span class="keyword">struct</span>{ <span class="typename">int</span> })</div><div class="line"></div><div class="line">fmt.Printf(<span class="string">"%T %T %T\n"</span>, i, s, j) <span class="comment">//*int *string *struct { int }</span></div></pre></td></tr></table></figure>

<p>参考</p>
<ul>
<li><a href="https://golang.org/pkg/unsafe/" target="_blank" rel="external">https://golang.org/pkg/unsafe/</a></li>
<li><a href="http://learngowith.me/gos-pointer-pointer-type/" target="_blank" rel="external">http://learngowith.me/gos-pointer-pointer-type/</a></li>
</ul>
<h3 id="函数类型">函数类型</h3>
<p>在Go语言中，函数是第一类的，可以赋值给变量，当做参数传入传出。</p>
<p>参数名和返回值名可以省略，但是如果要省略，必须所有的参数名或者返回值名全省略，部分省略是不行的。</p>
<p>通过<code>...</code>支持变参，但是变参只能作为最后一个参数。</p>
<p>如果不需要返回值，则不需要定义返回类型。</p>
<p>可以命名函数类型。</p>
<p>以下都是合法的函数类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span>()</div><div class="line"><span class="keyword">func</span>(x <span class="typename">int</span>) <span class="typename">int</span></div><div class="line"><span class="keyword">func</span>(a, _ <span class="typename">int</span>, z <span class="typename">float32</span>) <span class="typename">bool</span></div><div class="line"><span class="keyword">func</span>(a, b <span class="typename">int</span>, z <span class="typename">float32</span>) (<span class="typename">bool</span>)</div><div class="line"><span class="keyword">func</span>(prefix <span class="typename">string</span>, values ...<span class="typename">int</span>)</div><div class="line"><span class="keyword">func</span>(a, b <span class="typename">int</span>, z <span class="typename">float64</span>, opt ...<span class="keyword">interface</span>{}) (success <span class="typename">bool</span>)</div><div class="line"><span class="keyword">func</span>(<span class="typename">int</span>, <span class="typename">int</span>, <span class="typename">float64</span>) (<span class="typename">float64</span>, *[]<span class="typename">int</span>)</div><div class="line"><span class="keyword">func</span>(n <span class="typename">int</span>) <span class="keyword">func</span>(p *T)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Handler <span class="keyword">func</span>(ResponseWriter, *Request)</div></pre></td></tr></table></figure>

<p>注意此处介绍的是函数类型，函数的定义可以指定函数名称，也可以定义匿名函数。</p>
<h3 id="接口类型">接口类型</h3>
<p>Go并没有Java那样的完全的面向对象的类型系统， 而是通过接口和duck typing支持面向对象的编程,也就是会呱呱叫的我们都认为它是鸭子。</p>
<p>一个接口代表一组方法的集合。任何实现了这些方法的类型的值都可以赋值给这个接口变量，我们也可以说这些类型实现了这个接口。</p>
<p>特殊的， <code>interface{}</code>代表一个万能的接口，其它类型都实现了这个接口，有点像Java中的Object类。</p>
<p>接口也可以嵌入,只要保证方法名唯一即可：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> {</div><div class="line">	Read(b Buffer) <span class="typename">bool</span></div><div class="line">	Write(b Buffer) <span class="typename">bool</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> File <span class="keyword">interface</span> {</div><div class="line">	ReadWriter  <span class="comment">// same as adding the methods of ReadWriter</span></div><div class="line">	Locker      <span class="comment">// same as adding the methods of Locker</span></div><div class="line">	Close()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> LockedFile <span class="keyword">interface</span> {</div><div class="line">	Locker</div><div class="line">	File        <span class="comment">// illegal: Lock, Unlock not unique</span></div><div class="line">	Lock()      <span class="comment">// illegal: Lock not unique</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>但是接口不能嵌入它本身，或者递归地嵌入本身。</p>
<p>参考</p>
<ul>
<li><a href="https://medium.com/@matryer/golang-advent-calendar-day-one-duck-typing-a513aaed544d#.m5iuzvhjg" target="_blank" rel="external">https://medium.com/@matryer/golang-advent-calendar-day-one-duck-typing-a513aaed544d#.m5iuzvhjg</a></li>
</ul>
<h3 id="Map类型">Map类型</h3>
<p>Map类型在Go语言中提高到语言规范的级别，在Java只是作为类库中的类实现的。</p>
<p>Map是一组无序的键值对的集合。键的类型相同，值的类型也相同。</p>
<p>Map的变量的定义可以通过下面几种方式,中括号中是键的类型，后边接着是值的类型，键：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span>)</div><div class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span>,<span class="number"> 100</span>)</div><div class="line">m3 := <span class="built_in">new</span>(<span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span>)</div><div class="line"><span class="keyword">var</span> m4 <span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span></div></pre></td></tr></table></figure>

<p>一般通过｀make｀方法生成，可以设置map的初始容量，但是在增加元素的时候容量会快速增加，这也是一般map集合应对元素扩展的时候的方法。</p>
<p>注意， map的键类型是必须是可以比较的(comparable),比如下面的类型都不能作为键值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Func <span class="keyword">func</span>()</div><div class="line"><span class="keyword">type</span> SL []<span class="typename">int</span></div><div class="line"><span class="keyword">type</span> M <span class="keyword">map</span>[<span class="typename">int</span>]<span class="typename">int</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[Func]<span class="typename">int</span>) <span class="comment">//错误</span></div><div class="line">	m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[SL]<span class="typename">int</span>) <span class="comment">//错误</span></div><div class="line">	m3 := <span class="built_in">make</span>(<span class="keyword">map</span>[M]<span class="typename">int</span>) <span class="comment">//错误</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>只有以下类型可以比较，也就是可以应用比较操作符(&gt;、 &lt;、＝＝ 等):</p>
<ul>
<li>布尔型</li>
<li>整型</li>
<li>浮点型</li>
<li>复数</li>
<li>字符串</li>
<li>指针</li>
<li>Channel</li>
<li>接口</li>
<li>struct</li>
<li>数组</li>
</ul>
<p>内置函数<code>delete</code>可以根据key删除map对象的entry, 如果map为nil或者键不存在，delete相当于一个空操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">delete</span>(m, k)  <span class="comment">// remove element m[k] from map m</span></div></pre></td></tr></table></figure>

<p>而往map中增加元素或者查找元素都是通过索引实现的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">m[k] = v</div><div class="line"><span class="keyword">var</span> v = m[k]</div><div class="line">t, ok := m[k]</div></pre></td></tr></table></figure>

<p>参考</p>
<ul>
<li><a href="https://blog.golang.org/go-maps-in-action" target="_blank" rel="external">https://blog.golang.org/go-maps-in-action</a></li>
</ul>
<h3 id="Channel类型">Channel类型</h3>
<p>Channel类型我在另外一篇文章中专门介绍了，本文中就不再赘述: <a href="http://colobu.com/2016/04/14/Golang-Channels/" target="_blank" rel="external">Go Channel 详解</a></p>
<h3 id="类型的零值">类型的零值</h3>
<p>当一个值被创建的时候，无论你是用什么方法，声明或者new方法创建，如果没有显示地初始化，Go就会给它分配一个零值(zero value)。</p>
<ul>
<li>布尔型: false</li>
<li>整数: 0</li>
<li>浮点数: 0.0</li>
<li>字符串: &quot;&quot;</li>
<li>指针: nil</li>
<li>函数: nil</li>
<li>接口: nil</li>
<li>slice: nil</li>
<li>channel: nil</li>
<li>map: nil</li>
</ul>
<p>值得注意的是字符串，从Java转过来的程序员会以为字符串的零值是nil，其实不是，字符串的零值是空的字符串。</p>
<h3 id="类型的比较">类型的比较</h3>
<p>如何判断两个对象的类型是一样的？本节我们来讨论类型一致性(Type identity, 类型完全相同)。</p>
<p>两个类型，要么类型一致，要不类型不同。</p>
<p>1、如果两个命名类型传承自同样的<a href="https://golang.org/ref/spec#Type_declarations" target="_blank" rel="external">TypeSpec</a>)，则它们是类型一致的。这是显然地，因为是自己和自己比较<br>2、一个命名类型和一个未命名类型肯定是类型不一致</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> (</div><div class="line">	T0 []<span class="typename">string</span></div><div class="line">	T1 []<span class="typename">string</span></div><div class="line">	T2 <span class="keyword">struct</span>{ a, b <span class="typename">int</span> }</div><div class="line">)</div></pre></td></tr></table></figure>

<p><code>T0</code>、<code>T1</code>、 <code>T2</code>和 <code>[]string</code>都是不同的。</p>
<p>对于两个未命名类型，如果类型的声明一致，则类型一致，具体如下：<br>1、两个数组类型一致， 如果它们的元素的类型是类型一致并且数组长度相同<br>2、两个slice类型一致，如果它们的元素的类型是类型一致<br>3、两个struct类型一致，如果它们拥有相同的字段序列，并且相应的字段的名字相同而且类型一致，并且tag相同。两个匿名字段被认为有相同的名字。不同包下的Lower-case字段总是不同的<br>4、两个指针类型相同，如果它们指向的对象的类型是类型一致的<br>5、两个函数的类型相同，如果它们的参数和返回值的数量一致，并且类型一致，都有变参或者都没有。不要求参数名和返回名一致<br>6、两个接口类型相同，如果它们的方法集相同，方法名相同，方法的类型一致。不同包下的Lower-case方法名是不同的。方法声明的顺序无关<br>7、两个map类型相同，如果它们的key和value的类型一致<br>8、两个channel类型一致，如果它们的值的类型一致，并且有相同的方法(direction)</p>
<p>对于下列类型:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> (</div><div class="line">	T0 []<span class="typename">string</span></div><div class="line">	T1 []<span class="typename">string</span></div><div class="line">	T2 <span class="keyword">struct</span>{ a, b <span class="typename">int</span> }</div><div class="line">	T3 <span class="keyword">struct</span>{ a, c <span class="typename">int</span> }</div><div class="line">	T4 <span class="keyword">func</span>(<span class="typename">int</span>, <span class="typename">float64</span>) *T0</div><div class="line">	T5 <span class="keyword">func</span>(x <span class="typename">int</span>, y <span class="typename">float64</span>) *[]<span class="typename">string</span></div><div class="line">)</div></pre></td></tr></table></figure>

<p>下列的类型是一致的：</p>
<ul>
<li><code>T0</code> 和 <code>T0</code></li>
<li><code>[]int</code> 和<code>[]int</code></li>
<li><code>struct{ a, b *T5 }</code> 和 <code>struct{ a, b *T5 }</code></li>
<li><code>func(x int, y float64) *[]string</code> 和 <code>func(int, float64) (result *[]string)</code></li>
</ul>
<p>但是<code>T0</code> 和 <code>T1</code> 类型不同; <code>func(int, float64) *T0</code> 和 <code>func(x int, y float64) *[]string</code> 也不同， 因为 <code>T0</code> 和 <code>[]string</code>不同。</p>
<p>这也容易理解，不同的类型可以拥有不同的方法集。</p>
<h3 id="赋值">赋值</h3>
<p>一个值x只有在下述情况下才能指派给类型<code>T</code> (类型为T的一个变量):</p>
<ul>
<li>x的类型和<code>T</code>类型一致。 相同类型的值当然可以赋值给相同类型的变量。</li>
<li>x的类型<code>V</code>和 类型<code>T</code>的底层类型一致， 并且至少<code>V</code>和<code>T</code>中的一个是未命名类型。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> S1 <span class="keyword">struct</span> {</div><div class="line">	Name <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> s2 = <span class="keyword">struct</span> {</div><div class="line">	Name <span class="typename">string</span></div><div class="line">}{<span class="string">"hello"</span>}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> s1 S1 = s2</div><div class="line">	fmt.Printf(<span class="string">"%#v\n"</span>, s1)</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li><code>T</code> 是一个接口, 而 x 实现了接口<code>T</code>。</li>
<li>x 是双向的channel, 而 <code>T</code>是一个channel类型，并且 x 的类型 <code>V</code> 和 <code>T</code>的元素的类型是类型一致的，并且 <code>V</code> 和 <code>T</code>至少有一个是未命名类型。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> CH1 *(<span class="keyword">chan</span> <span class="typename">int</span>)</div><div class="line"></div><div class="line"><span class="keyword">var</span> ch2 = <span class="built_in">new</span>(<span class="keyword">chan</span> <span class="typename">int</span>)</div><div class="line"></div><div class="line"><span class="keyword">type</span> CH3 *(<span class="keyword">chan</span> <span class="typename">int</span>)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> ch1 CH1 = ch2</div><div class="line">	<span class="comment">//var ch3 CH3 = ch2</span></div><div class="line">	<span class="comment">//ch1 = ch3</span></div><div class="line">	fmt.Printf(<span class="string">"%#v\n"</span>, ch1)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上例中ch2可以赋值给<code>CH1</code>、<code>CH2</code>类型的变量，因为ch2的类型是未命令类型,但是ch3就不可以赋值ch1，因为它们两个的类型都是命名类型。</p>
<ul>
<li>x 是预声明的值 <code>nil</code>,  <code>T</code>是一个指针、函数、slice、map、channel 或者接口的话，可以赋值，<code>nil</code>是这些类型的零值。</li>
<li>x 是一个未标明类型的常量，可以作为类型<code>T</code>的值。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> c =<span class="number"> 100</span></div><div class="line"><span class="keyword">var</span> _ <span class="typename">int</span> = c</div><div class="line"><span class="keyword">var</span> _ <span class="typename">int64</span> = c</div><div class="line"><span class="keyword">var</span> _ <span class="typename">int8</span> = c</div><div class="line"><span class="keyword">var</span> _ <span class="typename">float32</span> = c</div><div class="line"><span class="keyword">var</span> _ <span class="typename">float64</span> = c</div></pre></td></tr></table></figure>

<h3 id="代码块(block)">代码块(block)</h3>
<p>代码块是用括号&quot;{}&quot;括起来的包含声明和语句的一段代码。可以为空。</p>
<p>事实上当你编写Go代码的时候，就包含了隐式的代码块:</p>
<ul>
<li>全局的语句块包含所有的源码</li>
<li>package包含本package中的源码</li>
<li>每个文件包含一个文件代码块,它包含本文件中的所有源码</li>
<li><code>if</code>、<code>for</code> 和 <code>switch</code>语句包含在它们的隐式代码块中</li>
<li><code>switch</code>、<code>select</code>中的每一个clause语句都是一个隐式代码块</li>
</ul>
<p>代码块最重要的特性就是scope,以后讲。</p>
<blockquote>
<p>声明一下， 本系列的第一部分基本是按照Go语言的规范编写的，大量参考了Go语言规范的内容</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文介绍Go的类型系统,以及类型的比较和语句块。</p>
<p>Go语言包含11种类型，你应该很熟悉了，下面让我们再深入的了解一下每种类型的细节。</p>
<ul>
<li>布尔类型</li>
<li>数值类型</li>
<li>字符串类型</li>
<li>数组类型</li>
<li>Slice类型</li>
<li>Struct类型</li>
<li>指针类型</li>
<li>函数类型</li>
<li>接口类型</li>
<li>Map类型</li>
<li>Channel类型</li>
</ul>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入Go语言 - 2]]></title>
    <link href="http://colobu.com/2016/06/16/dive-into-go-2/"/>
    <id>http://colobu.com/2016/06/16/dive-into-go-2/</id>
    <published>2016-06-16T01:40:43.000Z</published>
    <updated>2016-06-21T08:57:05.000Z</updated>
    <content type="html"><![CDATA[<p>本文介绍Go语言的常量和变量的语言细节。</p>
<a id="more"></a>
<h3 id="常量">常量</h3>
<p>只有数值类型和字符串类型才可以作为常量。</p>
<p>数值类型包括 布尔类型、rune类型、各种整型、浮点类型、复数。</p>
<p>常量值既可以是数值类型的字面量，也可以是字符串字面量，以及常量的等价形式， 如：</p>
<ol>
<li>常量表达式， 如 <code>4 * 5</code></li>
<li>转换结果是常量， 如 <code>int(10.0)</code></li>
<li>内建函数的返回值， 如<code>unsafe.Sizeof</code>、<code>cap</code>、<code>len</code></li>
<li>复数、实数和虚数的应用</li>
<li><code>true</code>和<code>false</code>赋值给bool类型的常量</li>
<li>内建的 <code>iota</code></li>
</ol>
<p>用变量赋值给常量是不允许的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> vs = <span class="string">"hello world"</span></div><div class="line"><span class="keyword">const</span> s = vs <span class="comment">//错误</span></div></pre></td></tr></table></figure>

<p>常量的命名还是遵循前一篇文章的介绍，所有你看到一些&quot;奇怪&quot;的常量名不要觉得奇怪:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> π =<span class="number"> 3.1415926</span></div><div class="line"><span class="keyword">const</span> Π =<span class="number"> 3.1415926</span></div></pre></td></tr></table></figure>

<p>常量可以不声明类型(untyped), 它会根据常量值设置默认的类型，默认类型为：</p>
<ul>
<li>bool</li>
<li>rune</li>
<li>int</li>
<li>float64</li>
<li>complex128</li>
<li>string</li>
</ul>
<p>在需要类型的上下文中，常量可以<strong>隐式</strong>转换成相应的类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> v1 <span class="typename">int</span> = i</div><div class="line"><span class="keyword">var</span> v2 <span class="typename">float32</span> = i</div><div class="line"><span class="keyword">var</span> v3 <span class="typename">complex64</span> = i</div></pre></td></tr></table></figure>

<p>注意不同类型的变量是不能转换的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> v4 <span class="typename">float64</span> = v2</div></pre></td></tr></table></figure>

<p>你不能将一个不能隐式转换成常量类型的值赋值给常量，比如下面的例子中<code>2147483648.0</code>不能赋值给int32, 溢出了:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> i2 <span class="typename">int32</span> =<span class="number"> 2147483648.0</span></div></pre></td></tr></table></figure>

<p>Go对常量的底层实现有限制：</p>
<ul>
<li>Represent integer constants with at least 256 bits.</li>
<li>Represent floating-point constants, including the parts of a complex constant, with a mantissa of at least 256 bits and a signed exponent of at least 32 bits.</li>
<li>Give an error if unable to represent an integer constant precisely.</li>
<li>Give an error if unable to represent a floating-point or complex constant due to overflow.</li>
<li>Round to the nearest representable constant if unable to represent a floating-point or complex constant due to limits on precision.</li>
</ul>
<p>声明多个变量的时候可以将声明放在一起：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> (</div><div class="line">	i =<span class="number"> 1</span></div><div class="line">	s = <span class="string">"hello word"</span></div><div class="line">)</div></pre></td></tr></table></figure>

<p>或者将多个常量的定义放在一行中:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> i1, i2, i3 =<span class="number"> 0</span>,<span class="number"> 1</span>, <span class="string">"hello world"</span></div></pre></td></tr></table></figure>

<p>常量也可以定义在函数中:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> G() {</div><div class="line">  <span class="keyword">const</span> t =<span class="number"> 100</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="变量">变量</h3>
<p>变量代表一个值的存储位置，每个值都有类型。</p>
<p>变量在声明的时候如果同时有赋值操作，那么类型可以省略，因为可以根据值推断出来：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i1 <span class="typename">int</span> =<span class="number"> 100</span></div><div class="line"><span class="keyword">var</span> i2 =<span class="number"> 100</span></div></pre></td></tr></table></figure>

<p>类似于常量定义，你可以同时声明多个变量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> (</div><div class="line">  i3 =<span class="number"> 120</span></div><div class="line">  i4 = <span class="string">"hello world"</span></div><div class="line">)</div></pre></td></tr></table></figure>

<p>或者一行声明多个变量:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i5, i6, i7 =<span class="number"> 100</span>, <span class="string">"hello world"</span>, <span class="constant">true</span></div><div class="line"><span class="keyword">var</span> i8, i9, i10 <span class="typename">int</span></div></pre></td></tr></table></figure>

<p>在上面的例子中i8、i9、i10都是 int类型,所以将类型写在最后面，下面的写法是不允许的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i11 <span class="typename">int</span>, i12 <span class="typename">int</span>, i13 <span class="typename">int</span> <span class="comment">//错误</span></div></pre></td></tr></table></figure>

<p>下面的语句也是非法的，因为声明的变量和赋值列表的数值数量必须一样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i14, i15, i16 =<span class="number"> 100</span>,<span class="number"> 200</span> <span class="comment">//错误</span></div><div class="line"><span class="keyword">var</span> i17, i18, i19 <span class="typename">int</span> =<span class="number"> 100</span>,<span class="number"> 200</span> <span class="comment">//错误</span></div></pre></td></tr></table></figure>

<h3 id="变量声明简化">变量声明简化</h3>
<p>如果变量在声明的时候同时初始化，那么它就可以简化。<br>比如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i1, i2 =<span class="number"> 100</span>, <span class="string">"hello world"</span></div></pre></td></tr></table></figure>

<p>可以简化为</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">i1, i2 :=<span class="number"> 100</span>, <span class="string">"hello world"</span></div></pre></td></tr></table></figure>

<p>记住，这个简写方法<strong>只能用在函数中</strong>，函数之外的变量声明不能简写，下面的写法是错误的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line">s := <span class="string">"中国"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">}</div></pre></td></tr></table></figure>

<p>不像普通的变量声明，简写方式声明的变量可以&quot;重新声明&quot;已有变量，只要保证有一个新的变量在变量列表中即可，当然“重新声明”的变量和原有变量的类型相同。<br>看下面的例子就容易理解了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> f *os.File</div><div class="line">	f, err := os.Open(<span class="string">"dive-into-go.pdf"</span>)</div><div class="line"></div><div class="line">	fmt.Println(f, err)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个例子中<code>f</code>变量重新被声明了，程序正常编译，没有错误，这是因为<code>err</code>是新的变量。<br>下面这个例子就编译不过，因为第4行没有新的变量定义。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> f *os.File</div><div class="line">	<span class="keyword">var</span> err error</div><div class="line">	f, err := os.Open(<span class="string">"dive-into-go.pdf"</span>)</div><div class="line"></div><div class="line">	fmt.Println(f, err)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>不能用简写方法赋值给一个结构体的字段(field):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> MyFile <span class="keyword">struct</span> {</div><div class="line">	<span class="keyword">var</span> F *os.File</div><div class="line">}</div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> mf MyFile</div><div class="line">	<span class="comment">//var err error</span></div><div class="line">	mf.F, err := os.Open(<span class="string">"dive-into-go.pdf"</span>)</div><div class="line"></div><div class="line">	fmt.Println(f, err)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>注意，简写方法有时候会迷惑你，因为它可能<code>shadow</code>一个变量，而且正常编译通过:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">x :=<span class="number"> 100</span></div><div class="line"><span class="keyword">func</span>() {</div><div class="line">  x :=<span class="number"> 200</span></div><div class="line">  fmt.Println(x) <span class="comment">//200</span></div><div class="line">}()</div><div class="line"></div><div class="line">fmt.Println(x) <span class="comment">//100</span></div></pre></td></tr></table></figure>

<p>在上面的例子中，如果本意是通过一个方法修改变量x的值为200的话，最终打印结果可能是100，因为第三行实际是声明了一个新的变量。</p>
<p>你可以通过<code>vet</code>工具检查代码中是否包含<code>shadow</code>的代码：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go tool vet -shadow main8.go</div></pre></td></tr></table></figure>

<p>输出结果为:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">main8</span><span class="class">.go</span><span class="pseudo">:8</span>: <span class="tag">declaration</span> <span class="tag">of</span> <span class="tag">x</span> <span class="tag">shadows</span> <span class="tag">declaration</span> <span class="tag">at</span> <span class="tag">main8</span><span class="class">.go</span><span class="pseudo">:6</span>:</div></pre></td></tr></table></figure>

<p>变量和常量都可以定义在函数内或者包下，但是如果函数内的变量没有被使用，则会编译出错，这是Go语言有意这样设计的。包下的变量和常量，函数内的常量没有这个限制。</p>
<p>参考<br>＊ <a href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html#short_vars" target="_blank" rel="external">http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html#short_vars</a></p>
<h3 id="静态类型和动态类型">静态类型和动态类型</h3>
<p>静态类型(static type)是变量声明的时候的声明类型，在变量声明、new方法创建对象时或者结构体(struct)的元素的类型定义，参数类型等。</p>
<p>接口(interface)类型的变量还有一个动态类型，它是运行时赋值给这个变量的具体的值的类型(当然值为nil的时候没有动态类型)。一个变量的动态类型在运行时可能改变，<br>这主要依赖它的赋值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>{}  <span class="comment">// x 为零值 nil,静态类型为 interface{}</span></div><div class="line"><span class="keyword">var</span> v *T           <span class="comment">// v 为零值 nil, 静态类型为 *T</span></div><div class="line">x =<span class="number"> 42</span>             <span class="comment">// x 的值为 42,动态类型为int, 静态类型为interface{}</span></div><div class="line">x = v              <span class="comment">// x 的值为 (*T)(nil)， 动态类型为 *T, 静态类型为 *T</span></div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>本文介绍Go语言的常量和变量的语言细节。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入Go语言 - 1]]></title>
    <link href="http://colobu.com/2016/06/15/dive-into-go-1/"/>
    <id>http://colobu.com/2016/06/15/dive-into-go-1/</id>
    <published>2016-06-15T06:49:48.000Z</published>
    <updated>2016-06-21T08:57:05.000Z</updated>
    <content type="html"><![CDATA[<p>准备写一个Go 语言深入开发的系列，分为三个部分。第一部分为Go 语言的深入剖析，第二部分为一些官方库的深入开发，第三部分为一些第三方库的介绍。</p>
<a id="more"></a>
<h3 id="奇怪的变量名">奇怪的变量名</h3>
<p>标志符用来命名变量、类型、函数名等，最常规的，我们使用普通的拉丁字母和数字作为标志符,或者以下划线开始。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">str := <span class="string">"hello world"</span></div><div class="line">fmt.Println(str)</div><div class="line"></div><div class="line">_str09 := <span class="string">"hello w0rld"</span></div><div class="line">fmt.Println(_str09)</div></pre></td></tr></table></figure>

<p>但是根据Go语言规范，任何Unicode编码的letter字符和下划线都可以作为标识符的第一个字母，之后可以是任意的Unicode的letter字符或者数字。<br>允许的unicode字符为Unicode分类中的Lu、Ll、Lt、Lm、Lo等字符，比如中文、希腊字母等。你可以在参考链接中查看相应的Unicode字符分类。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">一个变量 := <span class="string">"hello 世界"</span></div><div class="line">fmt.Println(一个变量)</div><div class="line"></div><div class="line">ÆõĦǗΩצˮ𝟡 := <span class="string">"hello ¾"</span></div><div class="line">fmt.Println(ÆõĦǗΩצˮ𝟡)</div></pre></td></tr></table></figure>

<p>标识符业可以是类型名、函数名等：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> 学生 <span class="keyword">struct</span> {</div><div class="line">	姓名 <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> 小学生 学生</div><div class="line"></div><div class="line"><span class="keyword">type</span> 조선말 <span class="keyword">interface</span> {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> 函数名() {</div><div class="line">	fmt.Println(<span class="string">"I am a function"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当然，我相信绝大部分的程序员都会以普通的拉丁字母和数字作为标识符的，这样阅读起来更符合大众的习惯。在搞怪的情况下，可以尝试一下这些&quot;奇怪&quot;字符。</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/List_of_Unicode_characters" target="_blank" rel="external">https://en.wikipedia.org/wiki/List_of_Unicode_characters</a></li>
<li><a href="http://www.unicode.org/Public/UNIDATA/UnicodeData.txt" target="_blank" rel="external">http://www.unicode.org/Public/UNIDATA/UnicodeData.txt</a></li>
<li><a href="http://www.fileformat.info/info/unicode/category/index.htm" target="_blank" rel="external">http://www.fileformat.info/info/unicode/category/index.htm</a></li>
</ul>
<h3 id="预定义标识符">预定义标识符</h3>
<p>首先看下面一段代码，看看是否能变易成功：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> i <span class="constant">nil</span> =<span class="number"> 100</span></div><div class="line">	fmt.Println(i)</div><div class="line"></div><div class="line">	<span class="keyword">var</span> isSuccess <span class="typename">bool</span> =<span class="number"> 100</span></div><div class="line">	fmt.Println(isSuccess)</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>你肯定会说，不可能成功，类型不对呀。</p>
<p>没错，不可能将一个整数赋值给布尔类型的变量的。 那么你能不能加在方法外面加几行，让代码编译成功？</p>
<p>请注意，以下标识符实预先定义的标识符，而不是关键字，这意味着我们可以&quot;覆盖&quot;这些标识符的定义。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Types:</div><div class="line">	<span class="typename">bool</span> <span class="typename">byte</span> <span class="typename">complex64</span> <span class="typename">complex128</span> error <span class="typename">float32</span> <span class="typename">float64</span></div><div class="line">	<span class="typename">int</span> <span class="typename">int8</span> <span class="typename">int16</span> <span class="typename">int32</span> <span class="typename">int64</span> <span class="typename">rune</span> <span class="typename">string</span></div><div class="line">	<span class="typename">uint</span> <span class="typename">uint8</span> <span class="typename">uint16</span> <span class="typename">uint32</span> <span class="typename">uint64</span> <span class="typename">uintptr</span></div><div class="line"></div><div class="line">Constants:</div><div class="line">	<span class="constant">true</span> <span class="constant">false</span> <span class="constant">iota</span></div><div class="line"></div><div class="line">Zero value:</div><div class="line">	<span class="constant">nil</span></div><div class="line"></div><div class="line">Functions:</div><div class="line">	<span class="built_in">append</span> <span class="built_in">cap</span> <span class="built_in">close</span> <span class="built_in">complex</span> <span class="built_in">copy</span> <span class="built_in">delete</span> <span class="built_in">imag</span> <span class="built_in">len</span></div><div class="line">	<span class="built_in">make</span> <span class="built_in">new</span> <span class="built_in">panic</span> <span class="built_in">print</span> <span class="built_in">println</span> <span class="built_in">real</span> <span class="built_in">recover</span></div></pre></td></tr></table></figure>

<p>比如加上下面几行代码，程序就可以编译通过。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> <span class="constant">nil</span> <span class="typename">int</span></div><div class="line"><span class="keyword">type</span> <span class="typename">bool</span> <span class="typename">uint8</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> i <span class="constant">nil</span> =<span class="number"> 100</span></div><div class="line">	fmt.Println(i)</div><div class="line"></div><div class="line">	<span class="keyword">var</span> isSuccess <span class="typename">bool</span> =<span class="number"> 100</span></div><div class="line">	fmt.Println(isSuccess)</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="整数字面量">整数字面量</h3>
<p>Go语言不像其它语言， 如C++、Java，在声明数值类型的时候可以通过后缀如ll等表明变量的类型， 目前Go语言不提供这个功能。</p>
<p>如果值以0开始，则代表8进制。</p>
<p>如果值以0x或者0X开始，则代表16进制。</p>
<p>浮点数和其它语言的表示法相同。</p>
<p>复数表示法业和其它语言一致。</p>
<h3 id="Rune">Rune</h3>
<p>其它语言如Java、C#，字符串的字符操作很直观，但是Go语言的字符串的实现比较特殊，这可能和Go设计者的几位大牛有关，它保留着Unix和C的痕迹。</p>
<p>Java语言规范规定，Java的char类型是UTF-16的code unit，也就是两个字节,字符串是UTF-16 code unit的序列，因此每个字符都是定长的，要想获得某个位置字符，很容易计算出它的字节在字符串中的位置。</p>
<p>Go语言使用UTF-8作为字符串的内部编码，所以在没有byte字面量的情况下，字符串都是使用UTF－8编码的。因此对于大部分字符串都是ascii字符的情况下，<br>占用的内存空间就会大大减少，但是带来的问题是，从字符串的字节slice中查找第n个字符比较麻烦，因为不能直接的计算出来。</p>
<p>这里通称所有字母都为字符，其实是不准确的，在Unicodde规范中，它们称之为<code>code point</code>， 比如code point U+2318代表 <code>⌘</code>。<br><code>A</code>既是一个字符，也是一个code point: U+00E0。</p>
<p>code point有点拗口，所以Go语言用<code>rune</code>来表示，你只需记住它们是等价的即可。</p>
<p>rune有单引号定义，它包含单一的一个 code point。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> r <span class="typename">rune</span> = <span class="string">'文'</span></div><div class="line">fmt.Printf(<span class="string">"%#U\n"</span>, r)</div></pre></td></tr></table></figure>

<p>通过<code>range</code>可以遍历一个字符串中所有的rune:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> nihongo = <span class="string">"one world世界大同"</span></div><div class="line"><span class="keyword">for</span> index, runeValue := <span class="keyword">range</span> nihongo {</div><div class="line">	fmt.Printf(<span class="string">"%#U starts at byte position %d\n"</span>, runeValue, index)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>因为字符串是以UTF-8编码的，通过输出可以看到ascii字母只用一个字节，而这几个中文汉字每个汉字用了3个字节。</p>
<p>要想获得字符串中包含几个字符(rune)，下面的方法是不对的,它返回的是字符处内部的字slice的长度((9 + 4*3 =21)：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> str = <span class="string">"one world世界大同"</span></div><div class="line">fmt.Println(<span class="built_in">len</span>(str))</div></pre></td></tr></table></figure>

<p>我记得有个Go语言写的框架，在获取一篇文章的前N个字符的时候，就直接用<code>len</code>方法计算，这对于中文文章来说，肯定不对，截取的字符要少于期望的字符数，而且可能截取半个字符。</p>
<p>要想在字符串中操作rune，可以使用 package <a href="https://golang.org/pkg/unicode/utf8/" target="_blank" rel="external">unicode/utf8</a>，它提供了一组处理字符串和rune的方法，<br>比如我们正确计算一个字符串中包含的rune的数量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fmt.Println(utf8.RuneCountInString(str))</div></pre></td></tr></table></figure>

<p>字符串以两端用双引号包含的方式定义，允许使用转义字符存在或者&quot;\&quot;＋byte方式包含rune。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="string">"Hello, world!\n"</span></div><div class="line"><span class="string">"世界"</span></div><div class="line"><span class="string">"\u65e5本\U00008a9e"</span></div><div class="line"><span class="string">"\xff\u00FF"</span></div><div class="line"><span class="string">"\uD800"</span>             <span class="comment">//非法</span></div><div class="line"><span class="string">"\U00110000"</span>         <span class="comment">//非法</span></div></pre></td></tr></table></figure>

<ul>
<li><a href="https://blog.golang.org/strings" target="_blank" rel="external">https://blog.golang.org/strings</a></li>
<li><a href="https://blog.golang.org/constants" target="_blank" rel="external">https://blog.golang.org/constants</a></li>
</ul>
<h3 id="Rune和字符串互转">Rune和字符串互转</h3>
<p>直接通过<code>T(x)</code>类型转换即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">r := []<span class="typename">rune</span>(str)</div><div class="line">fmt.Printf(<span class="string">"%#v\n"</span>, r)</div><div class="line">str = <span class="typename">string</span>(r)</div><div class="line">fmt.Printf(<span class="string">"%#v\n"</span>, str)</div></pre></td></tr></table></figure>

<p>另外 package <a href="https://golang.org/pkg/strconv/#AppendQuoteToASCII" target="_blank" rel="external">strconv</a>也提供了格式化rune为字符串的一些方法， 比如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s := strconv.QuoteRune(<span class="string">'☺'</span>)</div><div class="line">fmt.Println(s)</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>准备写一个Go 语言深入开发的系列，分为三个部分。第一部分为Go 语言的深入剖析，第二部分为一些官方库的深入开发，第三部分为一些第三方库的介绍。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[vscode-icons: 提高生产力的 Visual Studio Code插件]]></title>
    <link href="http://colobu.com/2016/06/15/vscode-icons-Icons-for-VS-Code-Explorer/"/>
    <id>http://colobu.com/2016/06/15/vscode-icons-Icons-for-VS-Code-Explorer/</id>
    <published>2016-06-15T03:02:50.000Z</published>
    <updated>2016-06-21T08:57:05.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/robertohuertasm/vscode-icons" target="_blank" rel="external">vscode-icons</a>可以为你的 Visual Studio Code的文件类型提供相应的图标。</p>
<p><img src="/2016/06/15/vscode-icons-Icons-for-VS-Code-Explorer/icons.png" alt=""></p>
<a id="more"></a>
<p>之前我一直使用<a href="https://atom.io/" target="_blank" rel="external">atom editor</a>做开发， atom的一些插件非常优秀，比如<a href="https://atom.io/packages/activate-power-mode" target="_blank" rel="external">activate-power-mode</a>、<a href="https://atom.io/packages/file-icons" target="_blank" rel="external">file-icons</a>等，<br>自从vscode 1.0发布之后，使用vscode开发 Go 程序更方便，所以目前基本上开发以vscode为主。而且atom的插件地址也被墙了，要想安装、更新插件还得翻墙，挺麻烦的。</p>
<p>但是vscode的功能和插件目前还不丰富，尤其是编辑窗口的<a href="https://github.com/Microsoft/vscode/issues/224" target="_blank" rel="external">标签显示</a>功能, 估计还药一段时间才能实现。<br>activate-power-mode对应的插件还没有实现，但是file-icons对应的插件终于有人做出来了，那就是文章开头的 vscode-icons。</p>
<p>这个插件的安装业很简单，通过以下命令久可以安装。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ext <span class="operator"><span class="keyword">install</span> vscode-icons</span></div></pre></td></tr></table></figure>

<p>如果你通过这个命令未能找到这个插件的话，可以试试下面的命令：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ext <span class="operator"><span class="keyword">install</span> icons</span></div></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ext <span class="operator"><span class="keyword">install</span> <span class="string">"vscode-icons"</span></span></div></pre></td></tr></table></figure>

<p>由于vscode的插件设计还不完善， vscode-icons通过暴力修改vscode的以下两个文件来显示图标：</p>
<ul>
<li>workbench.main.js</li>
<li>workbench.main.css</li>
</ul>
<p>当然，当你禁用这个插件的时候vscode-icons会把这两个文件恢复回来。</p>
<p>安装完这个插件你需要通过命令 启用、禁用、更新插件：</p>
<ul>
<li><strong>Icons Enable</strong> : 启用这个插件</li>
<li><strong>Icons Disable</strong>: 禁止显示图标</li>
<li><strong>Icons Update</strong>: 更新插件，更新图标</li>
</ul>
<p>为什么要推荐这个插件呢？它可以将同一类型的文件以相同图标的方式，让程序员可以直观的选择文件，提供生产效率。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://github.com/robertohuertasm/vscode-icons" target="_blank" rel="external">vscode-icons</a>可以为你的 Visual Studio Code的文件类型提供相应的图标。</p>
<p><img src="/2016/06/15/vscode-icons-Icons-for-VS-Code-Explorer/icons.png" alt=""></p>
]]>
    
    </summary>
    
      <category term="vscode" scheme="http://colobu.com/tags/vscode/"/>
    
      <category term="工具" scheme="http://colobu.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Go实现TLS 服务器和客户端]]></title>
    <link href="http://colobu.com/2016/06/07/simple-golang-tls-examples/"/>
    <id>http://colobu.com/2016/06/07/simple-golang-tls-examples/</id>
    <published>2016-06-07T03:37:05.000Z</published>
    <updated>2016-06-21T08:57:05.000Z</updated>
    <content type="html"><![CDATA[<p>传输层安全协议（Transport Layer Security，缩写：TLS），及其前身安全套接层（Secure Sockets Layer，缩写：SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。</p>
<p>SSL包含记录层（Record Layer）和传输层，记录层协议确定了传输层数据的封装格式。传输层安全协议使用X.509认证，之后利用非对称加密演算来对通信方做身份认证，之后交换对称密钥作为会谈密钥（Session key）。这个会谈密钥是用来将通信两方交换的数据做加密，保证两个应用间通信的保密性和可靠性，使客户与服务器应用之间的通信不被攻击者窃听。</p>
<p>本文并没有提供一个TLS的深度教程，而是提供了两个Go应用TLS的简单例子，用来演示使用Go语言快速开发安全网络传输的程序。</p>
<a id="more"></a>
<h3 id="TLS历史">TLS历史</h3>
<blockquote>
<p>1994年早期，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。<br>1994年11月，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。<br>1996年11月，SSL 3.0版问世，得到大规模应用。<br>1999年1月，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版<a href="https://www.ietf.org/rfc/rfc2246.txt" target="_blank" rel="external">TLS 1.0版</a>。<br>2006年4月和2008年8月，TLS进行了两次升级，分别为<a href="https://tools.ietf.org/html/rfc4346" target="_blank" rel="external">TLS 1.1</a>版和<a href="https://tools.ietf.org/html/rfc5246" target="_blank" rel="external">TLS 1.2</a>版。最新的变动是2011年TLS 1.2的修订版。<br>现在正在制定 <a href="https://github.com/tlswg/tls13-spec" target="_blank" rel="external">tls 1.3</a>。</p>
</blockquote>
<h3 id="证书生成">证书生成</h3>
<p>首先我们创建私钥和证书。</p>
<h4 id="服务器端的证书生成">服务器端的证书生成</h4>
<p>使用了&quot;服务端证书&quot;可以确保服务器不是假冒的。</p>
<p>1、 生成服务器端的私钥</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl genrsa -<span class="keyword">out</span> server.key <span class="number">2048</span></div></pre></td></tr></table></figure>

<p>2、 生成服务器端证书</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl req -<span class="keyword">new</span> -x509 -<span class="keyword">key</span> server.<span class="keyword">key</span> -out server.pem -days <span class="number">3650</span></div></pre></td></tr></table></figure>

<h4 id="客户端的证书生成">客户端的证书生成</h4>
<p>除了&quot;服务端证书&quot;，在某些场合中还会涉及到&quot;客户端证书&quot;。所谓的&quot;客户端证书&quot;就是用来证明客户端访问者的身份。<br>比如在某些金融公司的内网，你的电脑上必须部署&quot;客户端证书&quot;，才能打开重要服务器的页面。<br>我会在后面的例子中演示&quot;客户端证书&quot;的使用。</p>
<p>3、 生成客户端的私钥</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl genrsa -<span class="keyword">out</span> client.key <span class="number">2048</span></div></pre></td></tr></table></figure>

<p>4、 生成客户端的证书</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl req -<span class="keyword">new</span> -x509 -<span class="keyword">key</span> client.<span class="keyword">key</span> -out client.pem -days <span class="number">3650</span></div></pre></td></tr></table></figure>

<p>或者使用下面的脚本：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="shebang">#!/bin/bash</span></div><div class="line"><span class="comment"># call this script with an email address (valid or not).</span></div><div class="line"><span class="comment"># like:</span></div><div class="line"><span class="comment"># ./makecert.sh demo@random.com</span></div><div class="line">mkdir certs</div><div class="line">rm certs/*</div><div class="line"><span class="built_in">echo</span> <span class="string">"make server cert"</span></div><div class="line">openssl req -new -nodes -x509 -out certs/server.pem -keyout certs/server.key -days <span class="number">3650</span> -subj <span class="string">"/C=DE/ST=NRW/L=Earth/O=Random Company/OU=IT/CN=www.random.com/emailAddress=<span class="variable">$1</span>"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"make client cert"</span></div><div class="line">openssl req -new -nodes -x509 -out certs/client.pem -keyout certs/client.key -days <span class="number">3650</span> -subj <span class="string">"/C=DE/ST=NRW/L=Earth/O=Random Company/OU=IT/CN=www.random.com/emailAddress=<span class="variable">$1</span>"</span></div></pre></td></tr></table></figure>

<h3 id="Golang_例子">Golang 例子</h3>
<p>Go <a href="https://golang.org/pkg/crypto/tls/" target="_blank" rel="external">Package tls</a>部分实现了 tls 1.2的功能，可以满足我们日常的应用。<a href="https://golang.org/pkg/crypto/x509/" target="_blank" rel="external">Package crypto/x509</a>提供了证书管理的相关操作。</p>
<h4 id="服务器证书的使用">服务器证书的使用</h4>
<p>本节代码提供了服务器使用证书的例子。</p>
<p>下面的代码是服务器的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"bufio"</span></div><div class="line">	<span class="string">"crypto/tls"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"net"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	cert, err := tls.LoadX509KeyPair(<span class="string">"server.pem"</span>, <span class="string">"server.key"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Println(err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	config := &tls.Config{Certificates: []tls.Certificate{cert}}</div><div class="line">	ln, err := tls.Listen(<span class="string">"tcp"</span>, <span class="string">":443"</span>, config)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Println(err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line">	<span class="keyword">defer</span> ln.Close()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		conn, err := ln.Accept()</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			log.Println(err)</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		}</div><div class="line">		<span class="keyword">go</span> handleConn(conn)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> handleConn(conn net.Conn) {</div><div class="line">	<span class="keyword">defer</span> conn.Close()</div><div class="line">	r := bufio.NewReader(conn)</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		msg, err := r.ReadString(<span class="string">'\n'</span>)</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			log.Println(err)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="built_in">println</span>(msg)</div><div class="line"></div><div class="line">		n, err := conn.Write([]<span class="typename">byte</span>(<span class="string">"world\n"</span>))</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			log.Println(n, err)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>首先从上面我们创建的服务器私钥和pem文件中得到证书<code>cert</code>，并且生成一个tls.Config对象。这个对象有多个字段可以设置，本例中我们使用它的默认值。<br>然后用<code>tls.Listen</code>开始监听客户端的连接，accept后得到一个net.Conn，后续处理和普通的TCP程序一样。</p>
<p>然后，我们看看客户端是如何实现的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"crypto/tls"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	conf := &tls.Config{</div><div class="line">		InsecureSkipVerify: <span class="constant">true</span>,</div><div class="line">	}</div><div class="line"></div><div class="line">	conn, err := tls.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:443"</span>, conf)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Println(err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line">	<span class="keyword">defer</span> conn.Close()</div><div class="line"></div><div class="line">	n, err := conn.Write([]<span class="typename">byte</span>(<span class="string">"hello\n"</span>))</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Println(n, err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	buf := <span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number"> 100</span>)</div><div class="line">	n, err = conn.Read(buf)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Println(n, err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="built_in">println</span>(<span class="typename">string</span>(buf[:n]))</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>InsecureSkipVerify</code>用来控制客户端是否证书和服务器主机名。如果设置为true,则不会校验证书以及证书中的主机名和服务器主机名是否一致。<br>因为在我们的例子中使用自签名的证书，所以设置它为true,仅仅用于测试目的。</p>
<p>可以看到，整个的程序编写和普通的TCP程序的编写差不太多，只不过初始需要做一些TLS的配置。</p>
<p>你可以<code>go run server.go</code>和<code>go run client.go</code>测试这个例子。</p>
<h4 id="客户端证书的使用">客户端证书的使用</h4>
<p>在有的情况下，需要双向认证，服务器也需要验证客户端的真实性。在这种情况下，我们需要服务器和客户端进行一点额外的配置。</p>
<p>服务器端：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"bufio"</span></div><div class="line">	<span class="string">"crypto/tls"</span></div><div class="line">	<span class="string">"crypto/x509"</span></div><div class="line">	<span class="string">"io/ioutil"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"net"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	cert, err := tls.LoadX509KeyPair(<span class="string">"server.pem"</span>, <span class="string">"server.key"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Println(err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	certBytes, err := ioutil.ReadFile(<span class="string">"client.pem"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"Unable to read cert.pem"</span>)</div><div class="line">	}</div><div class="line">	clientCertPool := x509.NewCertPool()</div><div class="line">	ok := clientCertPool.AppendCertsFromPEM(certBytes)</div><div class="line">	<span class="keyword">if</span> !ok {</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"failed to parse root certificate"</span>)</div><div class="line">	}</div><div class="line"></div><div class="line">	config := &tls.Config{</div><div class="line">		Certificates: []tls.Certificate{cert},</div><div class="line">		ClientAuth:   tls.RequireAndVerifyClientCert,</div><div class="line">		ClientCAs:    clientCertPool,</div><div class="line">	}</div><div class="line">	ln, err := tls.Listen(<span class="string">"tcp"</span>, <span class="string">":443"</span>, config)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Println(err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line">	<span class="keyword">defer</span> ln.Close()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		conn, err := ln.Accept()</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			log.Println(err)</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		}</div><div class="line">		<span class="keyword">go</span> handleConn(conn)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> handleConn(conn net.Conn) {</div><div class="line">	<span class="keyword">defer</span> conn.Close()</div><div class="line">	r := bufio.NewReader(conn)</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		msg, err := r.ReadString(<span class="string">'\n'</span>)</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			log.Println(err)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="built_in">println</span>(msg)</div><div class="line"></div><div class="line">		n, err := conn.Write([]<span class="typename">byte</span>(<span class="string">"world\n"</span>))</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			log.Println(n, err)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>因为需要验证客户端，我们需要额外配置下面两个字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ClientAuth:   tls.RequireAndVerifyClientCert,</div><div class="line">ClientCAs:    clientCertPool,</div></pre></td></tr></table></figure>

<p>然后客户端也配置这个<code>clientCertPool</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"crypto/tls"</span></div><div class="line">	<span class="string">"crypto/x509"</span></div><div class="line">	<span class="string">"io/ioutil"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	cert, err := tls.LoadX509KeyPair(<span class="string">"client.pem"</span>, <span class="string">"client.key"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Println(err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	certBytes, err := ioutil.ReadFile(<span class="string">"client.pem"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"Unable to read cert.pem"</span>)</div><div class="line">	}</div><div class="line"></div><div class="line">	clientCertPool := x509.NewCertPool()</div><div class="line">	ok := clientCertPool.AppendCertsFromPEM(certBytes)</div><div class="line">	<span class="keyword">if</span> !ok {</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"failed to parse root certificate"</span>)</div><div class="line">	}</div><div class="line"></div><div class="line">	conf := &tls.Config{</div><div class="line">		RootCAs:            clientCertPool,</div><div class="line">		Certificates:       []tls.Certificate{cert},</div><div class="line">		InsecureSkipVerify: <span class="constant">true</span>,</div><div class="line">	}</div><div class="line"></div><div class="line">	conn, err := tls.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:443"</span>, conf)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Println(err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line">	<span class="keyword">defer</span> conn.Close()</div><div class="line"></div><div class="line">	n, err := conn.Write([]<span class="typename">byte</span>(<span class="string">"hello\n"</span>))</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Println(n, err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	buf := <span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number"> 100</span>)</div><div class="line">	n, err = conn.Read(buf)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Println(n, err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="built_in">println</span>(<span class="typename">string</span>(buf[:n]))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>运行这两个代码<code>go run server2.go</code>和<code>go run client2.go</code>,可以看到两者可以正常的通讯，如果用前面的客户端<code>go run client.go</code>，不能正常通讯，因为前面的客户端并没有提供客户端证书。</p>
<h3 id="参考文档和代码">参考文档和代码</h3>
<ol>
<li><a href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E5%8D%94%E8%AD%B0" target="_blank" rel="external">https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E5%8D%94%E8%AD%B0</a></li>
<li><a href="http://drops.wooyun.org/tips/6002" target="_blank" rel="external">http://drops.wooyun.org/tips/6002</a></li>
<li><a href="http://www.levigross.com/2015/11/21/mutual-tls-authentication-in-go/" target="_blank" rel="external">http://www.levigross.com/2015/11/21/mutual-tls-authentication-in-go/</a></li>
<li><a href="https://github.com/nareix/blog/blob/master/posts/golang-tls-guide.md" target="_blank" rel="external">https://github.com/nareix/blog/blob/master/posts/golang-tls-guide.md</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></li>
<li><a href="https://gist.github.com/spikebike/2232102" target="_blank" rel="external">https://gist.github.com/spikebike/2232102</a></li>
<li><a href="https://github.com/nareix/tls-example" target="_blank" rel="external">https://github.com/nareix/tls-example</a></li>
<li><a href="http://seanlook.com/2015/01/07/tls-ssl/" target="_blank" rel="external">http://seanlook.com/2015/01/07/tls-ssl/</a></li>
<li><a href="https://golang.org/pkg/crypto/tls/" target="_blank" rel="external">https://golang.org/pkg/crypto/tls/</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>传输层安全协议（Transport Layer Security，缩写：TLS），及其前身安全套接层（Secure Sockets Layer，缩写：SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。</p>
<p>SSL包含记录层（Record Layer）和传输层，记录层协议确定了传输层数据的封装格式。传输层安全协议使用X.509认证，之后利用非对称加密演算来对通信方做身份认证，之后交换对称密钥作为会谈密钥（Session key）。这个会谈密钥是用来将通信两方交换的数据做加密，保证两个应用间通信的保密性和可靠性，使客户与服务器应用之间的通信不被攻击者窃听。</p>
<p>本文并没有提供一个TLS的深度教程，而是提供了两个Go应用TLS的简单例子，用来演示使用Go语言快速开发安全网络传输的程序。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转]Java 8：StampedLock，ReadWriteLock以及synchronized的比较]]></title>
    <link href="http://colobu.com/2016/06/01/Java-8-StampedLocks-vs-ReadWriteLocks-and-Synchronized/"/>
    <id>http://colobu.com/2016/06/01/Java-8-StampedLocks-vs-ReadWriteLocks-and-Synchronized/</id>
    <published>2016-06-01T01:55:46.000Z</published>
    <updated>2016-06-21T08:57:04.000Z</updated>
    <content type="html"><![CDATA[<p>原文出处：<a href="http://blog.takipi.com/java-8-stampedlocks-vs-readwritelocks-and-synchronized/" target="_blank" rel="external">Tal Weiss</a>, 译文出处: <a href="http://it.deepinmind.com/%E5%B9%B6%E5%8F%91/2014/06/06/java-8-stampedlocks-vs-readwritelocks-and-synchronized.html" target="_blank" rel="external">有孚</a></p>
<p>同步区域有点像拜访你的公公婆婆。你当然是希望待的时间越短越好。说到锁的话情况也是一样的，你希望获取锁以及进入临界区域的时间越短越好，这样才不会造成瓶颈。</p>
<p>synchronized关键字是语言层面的加锁机制，它可以用于方法以及代码块。这个关键字是由HotSpot JVM来实现的。我们在代码中分配的每一个对象，比如String, Array或者一个JSON文档，在GC的层面的对象头部，都内建了一个加锁的机制。JIT编译器也是类似的，它在进行字节码的编译和反编译的时候，都取决于特定的某个锁的具体的状态和竞争级别。</p>
<p>同步块的一个问题在于——进入临界区域内的线程不能超过一个。这对生产者消费者场景是一个很大的打击，尽管这里有些线程会尝试进行独占式的数据编辑，而另外一些线程只是希望读取一下数据，这个是可以和别的线程同时进行的。</p>
<p>读写锁（<a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html" target="_blank" rel="external">ReadWriteLock</a>）是一个理想的解决方案。你可以指定哪些线程会阻塞别的操作（写线程），哪些线程可以和别人共同进行内容的消费（读线程）。一个美满的结局？恐怕不是。</p>
<p>读写锁不像同步块，它并不是JVM中内建支持的，它只不过是段普通的代码。同样的，要想实现锁机制，它得引导CPU原子地或者按某个特定的顺序来执行某些特定的操作，以避免竞争条件。这通常都是通过JVM预留的一个后门来实现的——<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/sun/misc/Unsafe.java" target="_blank" rel="external">unsafe</a>类。读写锁使用的是CAS操作来将值直接<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/java/util/concurrent/locks/AbstractQueuedSynchronizer.java#AbstractQueuedSynchronizer.compareAndSetState%28int%2Cint%29" target="_blank" rel="external">设置</a>到内存中去，这是它们线程排队算法中的一部分。</p>
<p>尽管这样，读写锁也还不够快，有时候甚至会表现得<a href="http://blog.takipi.com/2014/04/16/java-8-longadders-the-fastest-way-to-add-numbers-concurrently/" target="_blank" rel="external">非常慢</a>，慢到你压根儿就不应该使用它。然而JDK的这帮家伙们没有放弃治疗，现在他们带来了一个全新的<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/concurrent/locks/StampedLock.java#StampedLock" target="_blank" rel="external">StampedLock</a>。这个读写锁使用了一组新的算法以及Java 8 JDK中引入的<a href="http://openjdk.java.net/jeps/171" target="_blank" rel="external">内存屏障</a>的特性，这使得这个锁更高效也更健壮。</p>
<p>它兑现了自己的诺言了吗？让我们拭目以待。</p>
<a id="more"></a>
<h3 id="使用锁">使用锁</h3>
<p>StampedLock的用法 更为复杂。它使用了一个戳（stamp)的概念，这是一个long值，它用作加锁解锁操作的一个标签。这意味着想要解锁一个操作你得将它对应的戳给传递进去。如果你传入的戳是错误的，那么可能会抛出一个异常，或者更糟糕的是，无法预知的行为。</p>
<p>另外一个值得关注的重要问题是，StampedLock并不像ReadWriteLock，它不是可重入的。因此它虽然更快，但也有一个坏处是线程可能会自己产生死锁。在实践中，这意味着你应该始终确保锁以及对应的戳不要逃逸出所在的代码块。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> stamp = lock.writeLock();  <span class="comment">//blocking lock, returns a stamp</span></div><div class="line"><span class="keyword">try</span> {</div><div class="line">  write(stamp); <span class="comment">// this is a bad move, you’re letting the stamp escape</span></div><div class="line">} </div><div class="line"><span class="keyword">finally</span> {</div><div class="line">  lock.unlock(stamp);<span class="comment">// release the lock in the same block - way better</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个设计还有个让人无法忍受的地方是这个long类型的戳对你而言没有任何意义。我还是希望锁操作能返回一个描述这个戳的对象——包括它的类型，锁的时间，owner线程，等等。这让调试和跟踪日志变得更简单。不过这么做很有可能是故意的，以便阻止开发人员不要将这个戳在代码里传来传去，同时也减少了分配对象的开销。</p>
<h3 id="乐观锁">乐观锁</h3>
<p>这个锁最重要的一个新功能就是它的乐观锁模式。研究和实践表明，读操作占了绝大数，并且很少和写操作竞争 。因此，使用一个成熟的读锁有点浪费。更好的方式是直接去读，结束之后再看一下这段时间内这个值有没有被改动过。如果有的话，你再进行重试，或者升级成一个更重的锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> stamp = lock.tryOptimisticRead(); <span class="comment">// non blocking</span></div><div class="line">read();</div><div class="line"><span class="keyword">if</span>(!lock.validate(stamp)){ <span class="comment">// if a write occurred, try again with a read lock</span></div><div class="line">  <span class="keyword">long</span> stamp = lock.readLock();</div><div class="line">  <span class="keyword">try</span> {</div><div class="line">    read();</div><div class="line">  }</div><div class="line">  <span class="keyword">finally</span> {</div><div class="line">    lock.unlock(stamp);</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>使用锁最大的麻烦在于，它在生产环境的实际表现取决于应用的状态。这意味着你不能凭空选择使用何种锁，而是得将代码执行的具体环境也考虑进来 。</p>
<p>并发的读写线程数会影响到你具体使用哪种锁——同步区还是读写锁。如果这些线程数在JVM的执行生命周期内发生改变的话，这个问题就更棘手了，这取决于应用的状态以及线程的竞争级别。</p>
<p>为了能说明这点，我对四种模式下的锁进行了压测——synchronized，读写锁，StampedLock的读写锁，以及读写乐观锁，分别使用了不同的竞争级别以及不同读写线程数的组合。读线程会去消费一个计数器的值，而写线程会将它从0增加到1M。</p>
<h3 id="5个读线程，5个写线程">5个读线程，5个写线程</h3>
<p>5个读写线程分别在并发地执行，可以看到StampedLock明显胜出了，它的性能要比synchronized高出3倍。读写锁的性能也不错。奇怪的是，乐观锁，表面看起来应该是最快的，实际上这里却是最慢的。<br><img src="04.png" alt=""></p>
<h3 id="10个读线程，10个写线程">10个读线程，10个写线程</h3>
<p>下面，我将竞争级别提高到10个写线程和10个读线程。现在情况开始发生变化了。读写锁要比StampedLock以及synchronized<strong>慢了一个数量级</strong>。说到乐观锁还是很让人意外，它比StampedLock的读写锁还要慢。<br><img src="01.png" alt=""></p>
<h3 id="16个读线程，4个写线程">16个读线程，4个写线程</h3>
<p>下面，我保持同样的竞争级别，不过将读线程的比重调整了下：16个读，4个写。读写锁再说次说明了为什么它要被替换掉了——它<strong>慢了百倍以上</strong>。Stamped以及乐观锁都表现得不错，synchronized也紧随其后。<br><img src="02.png" alt=""></p>
<h3 id="19个读，1个写">19个读，1个写</h3>
<p>最后，我只留了一个写线程，剩下19个全是读。注意到结果更慢了，因为单个线程完成任务的时间会更长。这里的结果非常有意思。读定锁看起来像是完成不了了。StampedLock的话也不太理想——乐观锁在这里明显胜出，百倍于读写锁。需要记住的是这个模式下它可能会失败，因为写操作可能会在你读的时候出现。synchronized，我们忠实的老伙伴，依旧保持着很稳定的表现。</p>
<p><img src="03.png" alt=""></p>
<p>完整的结果可以在<a href="https://docs.google.com/spreadsheets/d/1ro6rLZCoGoTvtITLOHf7nGaI3kK6iNWduQaQz0AOggc/edit#gid=310836513" target="_blank" rel="external">这里</a>下载。硬件：Macbook Pro i7</p>
<p>测试代码见<a href="https://www.google.com/url?q=https%3A%2F%2Fgithub.com%2Ftakipi%2Fcounters-benchmark&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNHYM0s5o4bLoZznXrREiUSuR2Nb_g" target="_blank" rel="external">这里</a>。</p>
<h3 id="结论">结论</h3>
<p>看起来平均表现最佳的还是内部实现的synchronized锁。尽管如此，并不是说它在所有情况下都是表现得最好的。主要是想告诉你，采用哪种锁，应该在你的代码上线前在不同的竞争级别下，并且使用不同的读写线程数来进行详细的测试，根据结果来选择。否则你会面临线上故障的<a href="http://www.veritasstrength.com/Websites/veritasstrength/images/Peter_Griffin_in_Pain.jpg" target="_blank" rel="external">风险</a>。</p>
<p>更多的关于StampedLock的资料见<a href="http://javaspecialists.eu/talks/jfokus13/PhaserAndStampedLock.pdf" target="_blank" rel="external">这里</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文出处：<a href="http://blog.takipi.com/java-8-stampedlocks-vs-readwritelocks-and-synchronized/" target="_blank" rel="external">Tal Weiss</a>, 译文出处: <a href="http://it.deepinmind.com/%E5%B9%B6%E5%8F%91/2014/06/06/java-8-stampedlocks-vs-readwritelocks-and-synchronized.html" target="_blank" rel="external">有孚</a></p>
<p>同步区域有点像拜访你的公公婆婆。你当然是希望待的时间越短越好。说到锁的话情况也是一样的，你希望获取锁以及进入临界区域的时间越短越好，这样才不会造成瓶颈。</p>
<p>synchronized关键字是语言层面的加锁机制，它可以用于方法以及代码块。这个关键字是由HotSpot JVM来实现的。我们在代码中分配的每一个对象，比如String, Array或者一个JSON文档，在GC的层面的对象头部，都内建了一个加锁的机制。JIT编译器也是类似的，它在进行字节码的编译和反编译的时候，都取决于特定的某个锁的具体的状态和竞争级别。</p>
<p>同步块的一个问题在于——进入临界区域内的线程不能超过一个。这对生产者消费者场景是一个很大的打击，尽管这里有些线程会尝试进行独占式的数据编辑，而另外一些线程只是希望读取一下数据，这个是可以和别的线程同时进行的。</p>
<p>读写锁（<a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html" target="_blank" rel="external">ReadWriteLock</a>）是一个理想的解决方案。你可以指定哪些线程会阻塞别的操作（写线程），哪些线程可以和别人共同进行内容的消费（读线程）。一个美满的结局？恐怕不是。</p>
<p>读写锁不像同步块，它并不是JVM中内建支持的，它只不过是段普通的代码。同样的，要想实现锁机制，它得引导CPU原子地或者按某个特定的顺序来执行某些特定的操作，以避免竞争条件。这通常都是通过JVM预留的一个后门来实现的——<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/sun/misc/Unsafe.java" target="_blank" rel="external">unsafe</a>类。读写锁使用的是CAS操作来将值直接<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/java/util/concurrent/locks/AbstractQueuedSynchronizer.java#AbstractQueuedSynchronizer.compareAndSetState%28int%2Cint%29" target="_blank" rel="external">设置</a>到内存中去，这是它们线程排队算法中的一部分。</p>
<p>尽管这样，读写锁也还不够快，有时候甚至会表现得<a href="http://blog.takipi.com/2014/04/16/java-8-longadders-the-fastest-way-to-add-numbers-concurrently/" target="_blank" rel="external">非常慢</a>，慢到你压根儿就不应该使用它。然而JDK的这帮家伙们没有放弃治疗，现在他们带来了一个全新的<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/concurrent/locks/StampedLock.java#StampedLock" target="_blank" rel="external">StampedLock</a>。这个读写锁使用了一组新的算法以及Java 8 JDK中引入的<a href="http://openjdk.java.net/jeps/171" target="_blank" rel="external">内存屏障</a>的特性，这使得这个锁更高效也更健壮。</p>
<p>它兑现了自己的诺言了吗？让我们拭目以待。</p>
]]>
    
    </summary>
    
      <category term="StampedLock" scheme="http://colobu.com/tags/StampedLock/"/>
    
      <category term="Java" scheme="http://colobu.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RPCX: 一个用Go实现的类似Dubbo的分布式RPC框架]]></title>
    <link href="http://colobu.com/2016/05/26/RPCX-a-distributed-rpc-dubbo-like-framework-by-Go/"/>
    <id>http://colobu.com/2016/05/26/RPCX-a-distributed-rpc-dubbo-like-framework-by-Go/</id>
    <published>2016-05-26T08:24:58.000Z</published>
    <updated>2016-06-21T08:57:04.000Z</updated>
    <content type="html"><![CDATA[<p>rpcx是一个类似阿里巴巴 <a href="http://dubbo.io/" target="_blank" rel="external">Dubbo</a> 和微博 <a href="https://github.com/weibocom/motan" target="_blank" rel="external">Motan</a> 的分布式的RPC服务框架，基于Golang net/rpc实现。 </p>
<p>谈起分布式的RPC框架，比较出名的是阿里巴巴的dubbo,包括由当当网维护的dubbox。<br>不知道dubbo在阿里的内部竞争中败给了HSF，还是阿里有意将其闭源了，官方的代码使用的spring还停留在2.5.6.SEC03的版本，dubbox的spring也只升级到3.2.9.RELEASE。<br>不管怎样，dubbo还是在电商企业得到广泛的应用，京东也有部分在使用dubbo开发。</p>
<blockquote>
<p>DUBBO是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，是阿里巴巴SOA服务化治理方案的核心框架，每天为2,000+个服务提供3,000,000,000+次访问量支持，并被广泛应用于阿里巴巴集团的各成员站点。<br>微博的RPC框架 Motan 也正式开源了，如张雷所说：</p>
<p>2013 年微博 RPC 框架 Motan 在前辈大师们（福林、fishermen、小麦、王喆等）的精心设计和辛勤工作中诞生，向各位大师们致敬，也得到了微博各个技术团队的鼎力支持及不断完善，如今 Motan 在微博平台中已经广泛应用，每天为数百个服务完成近千亿次的调用。</p>
</blockquote>
<p>这两个个优秀的框架都是使用Java开发的，国外的互联网企业也有非常出名的的RPC框架如<a href="https://thrift.apache.org/" target="_blank" rel="external">thrift</a>、<a href="https://github.com/twitter/finagle" target="_blank" rel="external">finagle</a>。</p>
<p>本项目<a href="https://github.com/smallnest/rpcx" target="_blank" rel="external">rpcx</a>的目标就是实现一个Go生态圈的Dubbo，为Go生态圈提供一个分布式的、多插件的、带有服务治理功能的产品级的RPC框架。</p>
<p>Go生态圈已经有一些RPC库，如官方的<a href="https://golang.org/pkg/net/rpc/" target="_blank" rel="external">net/rpc</a>、<a href="https://github.com/grpc/grpc-go" target="_blank" rel="external">grpc-go</a>、<a href="http://www.gorillatoolkit.org/pkg/rpc" target="_blank" rel="external">gorilla-rpc</a>等，为什么还要开发<strong>rpcx</strong>呢？</p>
<p>原因在于尽管这些框架都是为Go实现的RPC库，但是它们的功能比较单一，只是实现了点对点(End-to-End)的通讯框架。缺乏服务治理的功能，比如服务注册和发现、<br>负载均衡、容灾、服务监控等功能。因此我基于Go net/rpc框架实现了一个类似Dubbo的分布式框架。</p>
<p>和rpcx比较类似的Go RPC框架是<a href="https://github.com/micro/go-micro" target="_blank" rel="external">go-micro</a>，但是rpcx提供了更丰富的功能，基于TCP的通讯协议性能更好。</p>
<a id="more"></a>
<h2 id="RPC是什么">RPC是什么</h2>
<p>远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用，例：Java RMI。<br>简单地说就是能使应用像调用本地方法一样的调用远程的过程或服务。很显然，这是一种client-server的交互形式，调用者(caller)是client,执行者(executor)是server。典型的实现方式就是request–response通讯机制。</p>
<p>RPC 是进程之间的通讯方式(inter-process communication, IPC), 不同的进程有不同的地址空间。<br>如果client和server在同一台机器上，尽管物理地址空间是相同的，但是虚拟地址空间不同。<br>如果它们在不同的主机上，物理地址空间也不同。</p>
<p>RPC的实现的技术各不相同，也不一定兼容。</p>
<p>一个正常的RPC过程可以分成下面几步：</p>
<ol>
<li>client调用client stub，这是一次本地过程调用</li>
<li>client stub将参数打包成一个消息，然后发送这个消息。打包过程也叫做 marshalling</li>
<li>client所在的系统将消息发送给server</li>
<li>server的的系统将收到的包传给server stub</li>
<li>server stub解包得到参数。 解包也被称作 unmarshalling</li>
<li>最后server stub调用服务过程. 返回结果按照相反的步骤传给client</li>
</ol>
<p>RPC只是描绘了 Client 与 Server 之间的点对点调用流程，包括 stub、通信、RPC 消息解析等部分，在实际应用中，还需要考虑服务的高可用、负载均衡等问题，所以产品级的 RPC 框架除了点对点的 RPC 协议的具体实现外，还应包括服务的发现与注销、提供服务的多台 Server 的负载均衡、服务的高可用等更多的功能。<br>目前的 RPC 框架大致有两种不同的侧重方向，一种偏重于服务治理，另一种偏重于跨语言调用。</p>
<p>服务治理型的 RPC 框架有 Dubbo、DubboX、Motan 等，这类的 RPC 框架的特点是功能丰富，提供高性能的远程调用以及服务发现及治理功能，适用于大型服务的微服务化拆分以及管理，对于特定语言（Java）的项目可以十分友好的透明化接入。但缺点是语言耦合度较高，跨语言支持难度较大。</p>
<p>跨语言调用型的 RPC 框架有 Thrift、gRPC、Hessian、Hprose 等，这一类的 RPC 框架重点关注于服务的跨语言调用，能够支持大部分的语言进行语言无关的调用，非常适合于为不同语言提供通用远程服务的场景。但这类框架没有服务发现相关机制，实际使用时一般需要代理层进行请求转发和负载均衡策略控制。</p>
<p>本项目 rpcx 属于服务治理类型，是一个基于 Go 开发的高性能的轻量级 RPC 框架，Motan 提供了实用的服务治理功能和基于插件的扩展能力。</p>
<h2 id="RPCX的特点">RPCX的特点</h2>
<p>rpcx使用Go实现，适合使用Go语言实现RPC的功能。</p>
<ul>
<li>基于net/rpc,可以将net/rpc实现的RPC项目轻松的转换为分布式的RPC</li>
<li>插件式设计，可以配置所需的插件，比如服务发现、日志、统计分析等</li>
<li>基于TCP长连接,只需很小的额外的消息头</li>
<li>支持多种编解码协议，如Gob、Json、MessagePack、gencode、ProtoBuf等</li>
<li>服务发现：服务发布、订阅、通知等，支持多种发现方式如ZooKeeper、Etcd等</li>
<li>高可用策略：失败重试（Failover）、快速失败（Failfast）</li>
<li>负载均衡：支持随机请求、轮询、低并发优先、一致性 Hash等</li>
<li>规模可扩展，可以根据性能的需求增减服务器</li>
<li>其他：调用统计、访问日志等</li>
</ul>
<p>rpcx目标是轻量级的，小而简单，但是期望所有的功能都可以通过插件的方式搭积木的方式完成。</p>
<h2 id="RPCX架构">RPCX架构</h2>
<p>rpcx中有服务提供者 RPC Server，服务调用者 RPC Client 和服务注册中心 Registry 三个角色。</p>
<ul>
<li>Server 向 Registry 注册服务，并向注册中心发送心跳汇报状态(基于不同的registry有不同的实现)。</li>
<li>Client 需要向注册中心查询 RPC 服务者列表，Client 根据 Registry 返回的服务者列表，选取其中一个 Sever 进行 RPC 调用。</li>
<li>当 Server 发生宕机时，Registry 会监测到服务者不可用(zookeeper session机制或者手工心跳)，Client 感知后会对本地的服务列表作相应调整。client可能被动感知(zookeeper)或者主动定时拉取。</li>
<li>可选地，Server可以定期向Registry汇报调用统计信息，Client可以根据调用次数选择压力最小的Server</li>
</ul>
<p><img src="component.png" alt=""></p>
<p>当前rpcx支持zookeeper, etcd等注册中心，Consul注册中心正在开发中。</p>
<p>rpcx基于Go net/rpc的底层实现， Client和Server之间通讯是通过TCP进行通讯的，它们之间通过Client发送Request，Server返回Response实现。<br>Request和Response消息的格式都是<code>Header+Body</code>的格式。Header和Body具体的格式根据编码方式的不同而不同，可以是二进制，也可以是结构化数据如JSON。</p>
<h2 id="RPCX的特性">RPCX的特性</h2>
<p>rpcx拥有众多特性。</p>
<h3 id="服务器特性">服务器特性</h3>
<h4 id="编码_(序列化)">编码 (序列化)</h4>
<p>rpcx当前支持多种序列化/反序列化的方式，可以根据需求选择合适的编码库。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://golang.org/pkg/encoding/gob/" target="_blank" rel="external">gob</a></td>
<td>官方提供的序列化方式，基于一个包含元数据的流</td>
</tr>
<tr>
<td><a href="https://golang.org/pkg/net/rpc/jsonrpc/" target="_blank" rel="external">jsonrpc</a></td>
<td>也是官方提供的编码库，以JSON格式传输</td>
</tr>
<tr>
<td><a href="http://msgpack.org/" target="_blank" rel="external">msgp</a></td>
<td>类似json格式的编码，但是更小更快，可以直接编码struct</td>
</tr>
<tr>
<td><a href="https://github.com/andyleap/gencode" target="_blank" rel="external">gencode</a></td>
<td>一个超级快的序列化库，需要定义schema,但是定义方式和struct类似</td>
</tr>
<tr>
<td><a href="https://github.com/google/protobuf" target="_blank" rel="external">protobuf</a></td>
<td>Google推出的广受关注的序列化库，推荐使用<a href="https://github.com/gogo/protobuf" target="_blank" rel="external">gogo-protobuf</a>，可以获得更高的性能</td>
</tr>
</tbody>
</table>
<p>在数据结构简单的情况下，这几种库都可以满足需求，参照本文中的benchmark测试。但是如果追求性能，建议采用后面三种序列化库。</p>
<p>序列化库的选择对于RPC服务的影响是巨大的，我创建了另外一个项目专门比较各序列化库的性能： <a href="https://github.com/smallnest/gosercomp" target="_blank" rel="external">gosercomp</a>。</p>
<p>新的序列化库的实现也非常简单，只需实现下面两个方法即可：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> NewXXXXXServerCodec(conn io.ReadWriteCloser) rpc.ServerCodec {</div><div class="line">    ……</div><div class="line">}</div><div class="line"><span class="keyword">func</span> NewXXXXXClientCodec(conn io.ReadWriteCloser) rpc.ClientCodec {</div><div class="line">    ……</div><div class="line">}</div></pre></td></tr></table></figure>

<p>编码库负责marshal/unmarshal Reuqest/Response， 包括消息中的Header和Body。<br>如果你想，你也可以对Header和Body实现不同的编码。</p>
<h4 id="注册中心">注册中心</h4>
<p>目前提供了两种注册中心:</p>
<ul>
<li><strong>ZooKeeperRegisterPlugin</strong><br>通过ZooKeeper实现服务发现。<br>服务在注册的时候会自动在ZooKeeper上创建一个Ephemeral节点，因此当服务宕机的时候此节点就被删除，Client也会感知到。<br>同时，Server也会把调用次数定时更新到ZooKeeper，这样Client可以根据一段时间的调用次数选择压力较小的服务器节点进行连接。</li>
</ul>
<p>注册中心的配置只需在服务器初始化的时候增加以下代码，服务的实现无需做任何的改动，也不需要额外的配置。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">plugin := &ZooKeeperRegisterPlugin{</div><div class="line">	ServiceAddress:   <span class="string">"tcp@127.0.0.1:1234"</span>,</div><div class="line">	ZooKeeperServers: []<span class="typename">string</span>{<span class="string">"127.0.0.1:2181"</span>},</div><div class="line">	BasePath:         <span class="string">"/betterrpc"</span>,</div><div class="line">	metrics:          metrics.NewRegistry(),</div><div class="line">	Services:         <span class="built_in">make</span>([]<span class="typename">string</span>,<span class="number"> 1</span>),</div><div class="line">	updateInterval:   time.Minute,</div><div class="line">}</div><div class="line">   server.PluginContainer.Add(plugin)</div></pre></td></tr></table></figure>

<p>其中ServiceAddress为本机(Server)要暴露给Client地址。因为ZooKeeper的节点名不支持&quot;/&quot;，<br>所以此处用&quot;@&quot;代替&quot;://&quot;。</p>
<p>ZooKeeperServers为ZK集群的地址。</p>
<p>BasePath为一个服务组，此组下的服务对于Client都是可见的。</p>
<ul>
<li><strong>EtcdRegisterPlugin</strong><br>通过etcd也可以实现服务发现。</li>
</ul>
<p>etcd可以通过TTL判断服务器的存活，另外此插件也会定时把调用次数定时更新到etcd。</p>
<p>此插件可以使用下面的代码配置：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">plugin := &EtcdRegisterPlugin{</div><div class="line">	ServiceAddress: <span class="string">"tcp@127.0.0.1:1234"</span>,</div><div class="line">	EtcdServers:    []<span class="typename">string</span>{<span class="string">"http://127.0.0.1:2379"</span>},</div><div class="line">	BasePath:       <span class="string">"/betterrpc"</span>,</div><div class="line">	metrics:        metrics.NewRegistry(),</div><div class="line">	Services:       <span class="built_in">make</span>([]<span class="typename">string</span>,<span class="number"> 1</span>),</div><div class="line">	updateInterval: time.Minute,</div><div class="line">}</div><div class="line">   server.PluginContainer.Add(plugin)</div></pre></td></tr></table></figure>

<p>注意注册中心插件必须在配置服务之前设置，否则注册中心无法获取要注册的服务信息。</p>
<h4 id="扩展点">扩展点</h4>
<p>当前rpcx为server提供了以下扩展点：</p>
<ul>
<li>服务注册时</li>
<li>Client连接时</li>
<li>读取Request Header的前后</li>
<li>读取Request Body的前后</li>
<li>返回Response的前后</li>
</ul>
<p>你可以根据这些扩展点编写自己的插件，只需实现相应的接口即可。<br>定义的接口你可以看godoc的IXXXXXXPlugin的定义。</p>
<p>上面介绍的注册中心就是通过插件的方式实现。同时rpcx还实现了其它的插件，如下面的介绍。</p>
<ul>
<li>LogRegisterPlugin: 记录服务注册日志</li>
<li>MetricsPlugin: 统计服务调用次数和处理时间</li>
<li>RateLimitingPlugin: 限流操作，限定服务器的TPS</li>
</ul>
<h3 id="客户端特性">客户端特性</h3>
<h4 id="负载均衡">负载均衡</h4>
<p>负载均衡是通过不同的ClientSelector来实现的。</p>
<table>
<thead>
<tr>
<th>负载均衡器</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>DirectClientSelector</td>
<td>点对点的直连，客户端直接连接一个服务器</td>
</tr>
<tr>
<td>MultiClientSelector</td>
<td>多对多的直连，一个客户端可以从一组固定的服务器中选择一个直连，无需注册中心</td>
</tr>
<tr>
<td>ZooKeeperClientSelector</td>
<td>从ZK注册中心选择一个服务器连接</td>
</tr>
<tr>
<td>EtcdClientSelector</td>
<td>从Etcd注册中心选择一个服务器连接</td>
</tr>
</tbody>
</table>
<p>一个Selector需要实现ClientSelector接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> ClientSelector <span class="keyword">interface</span> {</div><div class="line">	Select(clientCodecFunc ClientCodecFunc) (*rpc.Client, error)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>Client的序列化方式必须和服务器的序列化方式保持一致。</p>
<h4 id="容错">容错</h4>
<p>Client提供了两种容错方式: <code>Failfast</code>、<code>Failover</code>、<code>Failtry</code>:</p>
<ul>
<li>Failfast: 如果Client调用失败，立即返回，不会重试</li>
<li>Failover: 如果Client调用失败，会尝试从服务列表中选择另外一个服务器调用，直到成功或者到达重试次数</li>
<li>Failtry： 如果Client调用失败，会继续这个服务器重试，直到成功或者到达重试次数</li>
</ul>
<h4 id="重选算法">重选算法</h4>
<p>对于多个服务器，重选发送支持：</p>
<ul>
<li>随机选择： 随机选择一个服务器并返回，可能和上一次的重复</li>
<li>RoundRobin: 按顺序选择一个服务器</li>
<li>一致性哈希 [TODO]:使用<a href="https://arxiv.org/ftp/arxiv/papers/1406/1406.2294.pdf" target="_blank" rel="external">Jump Consistent Hash algorithm</a></li>
<li>CallLeast [TODO]: 根据调用次数选择压力最小的服务器</li>
</ul>
<h4 id="扩展点-1">扩展点</h4>
<p>Client的扩展点如下：</p>
<ul>
<li>读取Response Header的前后</li>
<li>读取Response Body的前后</li>
<li>写Request的前后</li>
</ul>
<h2 id="RPCX例子">RPCX例子</h2>
<h3 id="点对点">点对点</h3>
<p>点对点的实现和Go net/rpc的使用基本一致。</p>
<h4 id="Server">Server</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"github.com/smallnest/rpcx"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Args <span class="keyword">struct</span> {</div><div class="line">	A <span class="typename">int</span> <span class="string">`msg:"a"`</span></div><div class="line">	B <span class="typename">int</span> <span class="string">`msg:"b"`</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Reply <span class="keyword">struct</span> {</div><div class="line">	C <span class="typename">int</span> <span class="string">`msg:"c"`</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Arith <span class="typename">int</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> (t *Arith) Mul(args *Args, reply *Reply) error {</div><div class="line">	reply.C = args.A * args.B</div><div class="line">	<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (t *Arith) Error(args *Args, reply *Reply) error {</div><div class="line">	<span class="built_in">panic</span>(<span class="string">"ERROR"</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	server := rpcx.NewServer()</div><div class="line">	server.RegisterName(<span class="string">"Arith"</span>, <span class="built_in">new</span>(Arith))</div><div class="line">	server.Serve(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8972"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="Client">Client</h4>
<p>同步方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/smallnest/rpcx"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Args <span class="keyword">struct</span> {</div><div class="line">	A <span class="typename">int</span> <span class="string">`msg:"a"`</span></div><div class="line">	B <span class="typename">int</span> <span class="string">`msg:"b"`</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Reply <span class="keyword">struct</span> {</div><div class="line">	C <span class="typename">int</span> <span class="string">`msg:"c"`</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	s := &rpcx.DirectClientSelector{Network: <span class="string">"tcp"</span>, Address: <span class="string">"127.0.0.1:8972"</span>, Timeout:<span class="number"> 10</span> * time.Second}</div><div class="line">	client := rpcx.NewClient(s)</div><div class="line"></div><div class="line">	args := &Args<span class="number">{7</span>,<span class="number"> 8</span>}</div><div class="line">	<span class="keyword">var</span> reply Reply</div><div class="line">	err := client.Call(<span class="string">"Arith.Mul"</span>, args, &reply)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		fmt.Printf(<span class="string">"error for Arith: %d*%d, %v \n"</span>, args.A, args.B, err)</div><div class="line">	} <span class="keyword">else</span> {</div><div class="line">		fmt.Printf(<span class="string">"Arith: %d*%d=%d \n"</span>, args.A, args.B, reply.C)</div><div class="line">	}</div><div class="line"></div><div class="line">	client.Close()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>异步方式(通过Channel获得执行结果):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/smallnest/rpcx"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Args <span class="keyword">struct</span> {</div><div class="line">	A <span class="typename">int</span> <span class="string">`msg:"a"`</span></div><div class="line">	B <span class="typename">int</span> <span class="string">`msg:"b"`</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Reply <span class="keyword">struct</span> {</div><div class="line">	C <span class="typename">int</span> <span class="string">`msg:"c"`</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	s := &rpcx.DirectClientSelector{Network: <span class="string">"tcp"</span>, Address: <span class="string">"127.0.0.1:8972"</span>, Timeout:<span class="number"> 10</span> * time.Second}</div><div class="line">	client := rpcx.NewClient(s)</div><div class="line"></div><div class="line">	args := &Args<span class="number">{7</span>,<span class="number"> 8</span>}</div><div class="line">	<span class="keyword">var</span> reply Reply</div><div class="line">	divCall := client.Go(<span class="string">"Arith.Mul"</span>, args, &reply, <span class="constant">nil</span>)</div><div class="line">	replyCall := &lt;-divCall.Done <span class="comment">// will be equal to divCall</span></div><div class="line">	<span class="keyword">if</span> replyCall.Error != <span class="constant">nil</span> {</div><div class="line">		fmt.Printf(<span class="string">"error for Arith: %d*%d, %v \n"</span>, args.A, args.B, replyCall.Error)</div><div class="line">	} <span class="keyword">else</span> {</div><div class="line">		fmt.Printf(<span class="string">"Arith: %d*%d=%d \n"</span>, args.A, args.B, reply.C)</div><div class="line">	}</div><div class="line"></div><div class="line">	client.Close()</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="多服务器">多服务器</h3>
<h4 id="Server-1">Server</h4>
<p>这里例子启动了两个服务器，其中一个服务器故意将 <code>7 * 8</code>计算成 <code>560</code>，以便和另外一个服务器进行区分，我们可以观察计算结果。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"github.com/smallnest/rpcx"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Args <span class="keyword">struct</span> {</div><div class="line">	A <span class="typename">int</span> <span class="string">`msg:"a"`</span></div><div class="line">	B <span class="typename">int</span> <span class="string">`msg:"b"`</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Reply <span class="keyword">struct</span> {</div><div class="line">	C <span class="typename">int</span> <span class="string">`msg:"c"`</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Arith <span class="typename">int</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> (t *Arith) Mul(args *Args, reply *Reply) error {</div><div class="line">	reply.C = args.A * args.B</div><div class="line">	<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (t *Arith) Error(args *Args, reply *Reply) error {</div><div class="line">	<span class="built_in">panic</span>(<span class="string">"ERROR"</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Arith2 <span class="typename">int</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> (t *Arith2) Mul(args *Args, reply *Reply) error {</div><div class="line">	reply.C = args.A * args.B *<span class="number"> 10</span></div><div class="line">	<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (t *Arith2) Error(args *Args, reply *Reply) error {</div><div class="line">	<span class="built_in">panic</span>(<span class="string">"ERROR"</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	server1 := rpcx.NewServer()</div><div class="line">	server1.RegisterName(<span class="string">"Arith"</span>, <span class="built_in">new</span>(Arith))</div><div class="line">	server1.Start(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8972"</span>)</div><div class="line"></div><div class="line">	server2 := rpcx.NewServer()</div><div class="line">	server2.RegisterName(<span class="string">"Arith"</span>, <span class="built_in">new</span>(Arith2))</div><div class="line">	server2.Serve(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8973"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="Client-1">Client</h4>
<p><strong>随机选取服务器的例子</strong>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/smallnest/rpcx"</span></div><div class="line">	<span class="string">"github.com/smallnest/rpcx/clientselector"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Args <span class="keyword">struct</span> {</div><div class="line">	A <span class="typename">int</span> <span class="string">`msg:"a"`</span></div><div class="line">	B <span class="typename">int</span> <span class="string">`msg:"b"`</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Reply <span class="keyword">struct</span> {</div><div class="line">	C <span class="typename">int</span> <span class="string">`msg:"c"`</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	server1 := clientselector.ServerPair{Network: <span class="string">"tcp"</span>, Address: <span class="string">"127.0.0.1:8972"</span>}</div><div class="line">	server2 := clientselector.ServerPair{Network: <span class="string">"tcp"</span>, Address: <span class="string">"127.0.0.1:8973"</span>}</div><div class="line"></div><div class="line">	servers := []clientselector.ServerPair{server1, server2}</div><div class="line"></div><div class="line">	s := clientselector.NewMultiClientSelector(servers, rpcx.RandomSelect,<span class="number"> 10</span>*time.Second)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 10</span>; i++ {</div><div class="line">		callServer(s)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> callServer(s rpcx.ClientSelector) {</div><div class="line">	client := rpcx.NewClient(s)</div><div class="line"></div><div class="line">	args := &Args<span class="number">{7</span>,<span class="number"> 8</span>}</div><div class="line">	<span class="keyword">var</span> reply Reply</div><div class="line">	err := client.Call(<span class="string">"Arith.Mul"</span>, args, &reply)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		fmt.Printf(<span class="string">"error for Arith: %d*%d, %v \n"</span>, args.A, args.B, err)</div><div class="line">	} <span class="keyword">else</span> {</div><div class="line">		fmt.Printf(<span class="string">"Arith: %d*%d=%d \n"</span>, args.A, args.B, reply.C)</div><div class="line">	}</div><div class="line"></div><div class="line">	client.Close()</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>RoundRobin选取服务器的例子</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/smallnest/rpcx"</span></div><div class="line">	<span class="string">"github.com/smallnest/rpcx/clientselector"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Args <span class="keyword">struct</span> {</div><div class="line">	A <span class="typename">int</span> <span class="string">`msg:"a"`</span></div><div class="line">	B <span class="typename">int</span> <span class="string">`msg:"b"`</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Reply <span class="keyword">struct</span> {</div><div class="line">	C <span class="typename">int</span> <span class="string">`msg:"c"`</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	server1 := clientselector.ServerPair{Network: <span class="string">"tcp"</span>, Address: <span class="string">"127.0.0.1:8972"</span>}</div><div class="line">	server2 := clientselector.ServerPair{Network: <span class="string">"tcp"</span>, Address: <span class="string">"127.0.0.1:8973"</span>}</div><div class="line"></div><div class="line">	servers := []clientselector.ServerPair{server1, server2}</div><div class="line"></div><div class="line">	s := clientselector.NewMultiClientSelector(servers, rpcx.RoundRobin,<span class="number"> 10</span>*time.Second)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 10</span>; i++ {</div><div class="line">		callServer(s)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> callServer(s rpcx.ClientSelector) {</div><div class="line">	client := rpcx.NewClient(s)</div><div class="line">	args := &Args<span class="number">{7</span>,<span class="number"> 8</span>}</div><div class="line">	<span class="keyword">var</span> reply Reply</div><div class="line">	err := client.Call(<span class="string">"Arith.Mul"</span>, args, &reply)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		fmt.Printf(<span class="string">"error for Arith: %d*%d, %v \n"</span>, args.A, args.B, err)</div><div class="line">	} <span class="keyword">else</span> {</div><div class="line">		fmt.Printf(<span class="string">"Arith: %d*%d=%d \n"</span>, args.A, args.B, reply.C)</div><div class="line">	}</div><div class="line"></div><div class="line">	client.Close()</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>Failover</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/smallnest/rpcx"</span></div><div class="line">	<span class="string">"github.com/smallnest/rpcx/clientselector"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Args <span class="keyword">struct</span> {</div><div class="line">	A <span class="typename">int</span> <span class="string">`msg:"a"`</span></div><div class="line">	B <span class="typename">int</span> <span class="string">`msg:"b"`</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Reply <span class="keyword">struct</span> {</div><div class="line">	C <span class="typename">int</span> <span class="string">`msg:"c"`</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	server1 := clientselector.ServerPair{Network: <span class="string">"tcp"</span>, Address: <span class="string">"127.0.0.1:8972"</span>}</div><div class="line">	server2 := clientselector.ServerPair{Network: <span class="string">"tcp"</span>, Address: <span class="string">"127.0.0.1:8973"</span>}</div><div class="line">	server3 := clientselector.ServerPair{Network: <span class="string">"tcp"</span>, Address: <span class="string">"127.0.0.1:8974"</span>}</div><div class="line"></div><div class="line">	servers := []clientselector.ServerPair{server1, server2, server3}</div><div class="line"></div><div class="line">	s := clientselector.NewMultiClientSelector(servers, rpcx.RoundRobin,<span class="number"> 10</span>*time.Second)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 10</span>; i++ {</div><div class="line">		callServer(s)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> callServer(s rpcx.ClientSelector) {</div><div class="line">	client := rpcx.NewClient(s)</div><div class="line">	client.FailMode = rpcx.Failover</div><div class="line">	args := &Args<span class="number">{7</span>,<span class="number"> 8</span>}</div><div class="line">	<span class="keyword">var</span> reply Reply</div><div class="line">	err := client.Call(<span class="string">"Arith.Mul"</span>, args, &reply)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		fmt.Printf(<span class="string">"error for Arith: %d*%d, %v \n"</span>, args.A, args.B, err)</div><div class="line">	} <span class="keyword">else</span> {</div><div class="line">		fmt.Printf(<span class="string">"Arith: %d*%d=%d \n"</span>, args.A, args.B, reply.C)</div><div class="line">	}</div><div class="line"></div><div class="line">	client.Close()</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Benchmark">Benchmark</h2>
<p>rpcx基于Go net/rpc框架实现，它的插件机制并不会带来多少性能的损失，如下面的测试，rpcx性能和官方的Go net/rpc持平。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[root<span class="variable">@localhost</span> rpcx]<span class="comment"># go test -bench . -test.benchmem</span></div><div class="line"><span class="constant">PASS</span></div><div class="line"><span class="constant">BenchmarkNetRPC_gob</span>-<span class="number">16</span>            <span class="number">100000</span>             <span class="number">18742</span> ns/op             <span class="number">321</span> <span class="constant">B</span>/op          <span class="number">9</span> allocs/op</div><div class="line"><span class="constant">BenchmarkNetRPC_jsonrpc</span>-<span class="number">16</span>        <span class="number">100000</span>             <span class="number">21360</span> ns/op            <span class="number">1170</span> <span class="constant">B</span>/op         <span class="number">31</span> allocs/op</div><div class="line"><span class="constant">BenchmarkNetRPC_msgp</span>-<span class="number">16</span>           <span class="number">100000</span>             <span class="number">18617</span> ns/op             <span class="number">776</span> <span class="constant">B</span>/op         <span class="number">35</span> allocs/op</div><div class="line"><span class="constant">BenchmarkRPCX_gob</span>-<span class="number">16</span>              <span class="number">100000</span>             <span class="number">18718</span> ns/op             <span class="number">320</span> <span class="constant">B</span>/op          <span class="number">9</span> allocs/op</div><div class="line"><span class="constant">BenchmarkRPCX_json</span>-<span class="number">16</span>             <span class="number">100000</span>             <span class="number">21238</span> ns/op            <span class="number">1170</span> <span class="constant">B</span>/op         <span class="number">31</span> allocs/op</div><div class="line"><span class="constant">BenchmarkRPCX_msgp</span>-<span class="number">16</span>             <span class="number">100000</span>             <span class="number">18635</span> ns/op             <span class="number">776</span> <span class="constant">B</span>/op         <span class="number">35</span> allocs/op</div><div class="line"><span class="constant">BenchmarkRPCX_gencodec</span>-<span class="number">16</span>         <span class="number">100000</span>             <span class="number">18454</span> ns/op            <span class="number">4485</span> <span class="constant">B</span>/op         <span class="number">17</span> allocs/op</div><div class="line"><span class="constant">BenchmarkRPCX_protobuf</span>-<span class="number">16</span>         <span class="number">100000</span>             <span class="number">17234</span> ns/op             <span class="number">733</span> <span class="constant">B</span>/op         <span class="number">13</span> allocs/op</div></pre></td></tr></table></figure>

<h2 id="参考文档">参考文档</h2>
<ol>
<li><a href="https://www.zhihu.com/question/25536695" target="_blank" rel="external">谁能用通俗的语言解释一下什么是RPC框架？</a></li>
<li><a href="http://dubbo.io/" target="_blank" rel="external">DUBBO</a></li>
<li><a href="http://weibo.com/ttarticle/p/show?id=2309403951077522312320" target="_blank" rel="external">支撑微博千亿调用的轻量级RPC框架：Motan</a></li>
<li><a href="http://blog.jobbole.com/92290/" target="_blank" rel="external">你应该知道的 RPC 原理</a></li>
<li><a href="http://www.infoq.com/cn/news/2014/05/twitter-finagle-intro" target="_blank" rel="external">Twitter的RPC框架Finagle简介</a></li>
<li><a href="https://github.com/line/armeria" target="_blank" rel="external">armeria: Netty的作者正在开发的一个RPC库</a></li>
<li><a href="https://en.wikipedia.org/wiki/Remote_procedure_call" target="_blank" rel="external">wikipedia RPC</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>rpcx是一个类似阿里巴巴 <a href="http://dubbo.io/" target="_blank" rel="external">Dubbo</a> 和微博 <a href="https://github.com/weibocom/motan" target="_blank" rel="external">Motan</a> 的分布式的RPC服务框架，基于Golang net/rpc实现。 </p>
<p>谈起分布式的RPC框架，比较出名的是阿里巴巴的dubbo,包括由当当网维护的dubbox。<br>不知道dubbo在阿里的内部竞争中败给了HSF，还是阿里有意将其闭源了，官方的代码使用的spring还停留在2.5.6.SEC03的版本，dubbox的spring也只升级到3.2.9.RELEASE。<br>不管怎样，dubbo还是在电商企业得到广泛的应用，京东也有部分在使用dubbo开发。</p>
<blockquote>
<p>DUBBO是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，是阿里巴巴SOA服务化治理方案的核心框架，每天为2,000+个服务提供3,000,000,000+次访问量支持，并被广泛应用于阿里巴巴集团的各成员站点。<br>微博的RPC框架 Motan 也正式开源了，如张雷所说：</p>
<p>2013 年微博 RPC 框架 Motan 在前辈大师们（福林、fishermen、小麦、王喆等）的精心设计和辛勤工作中诞生，向各位大师们致敬，也得到了微博各个技术团队的鼎力支持及不断完善，如今 Motan 在微博平台中已经广泛应用，每天为数百个服务完成近千亿次的调用。</p>
</blockquote>
<p>这两个个优秀的框架都是使用Java开发的，国外的互联网企业也有非常出名的的RPC框架如<a href="https://thrift.apache.org/" target="_blank" rel="external">thrift</a>、<a href="https://github.com/twitter/finagle" target="_blank" rel="external">finagle</a>。</p>
<p>本项目<a href="https://github.com/smallnest/rpcx" target="_blank" rel="external">rpcx</a>的目标就是实现一个Go生态圈的Dubbo，为Go生态圈提供一个分布式的、多插件的、带有服务治理功能的产品级的RPC框架。</p>
<p>Go生态圈已经有一些RPC库，如官方的<a href="https://golang.org/pkg/net/rpc/" target="_blank" rel="external">net/rpc</a>、<a href="https://github.com/grpc/grpc-go" target="_blank" rel="external">grpc-go</a>、<a href="http://www.gorillatoolkit.org/pkg/rpc" target="_blank" rel="external">gorilla-rpc</a>等，为什么还要开发<strong>rpcx</strong>呢？</p>
<p>原因在于尽管这些框架都是为Go实现的RPC库，但是它们的功能比较单一，只是实现了点对点(End-to-End)的通讯框架。缺乏服务治理的功能，比如服务注册和发现、<br>负载均衡、容灾、服务监控等功能。因此我基于Go net/rpc框架实现了一个类似Dubbo的分布式框架。</p>
<p>和rpcx比较类似的Go RPC框架是<a href="https://github.com/micro/go-micro" target="_blank" rel="external">go-micro</a>，但是rpcx提供了更丰富的功能，基于TCP的通讯协议性能更好。</p>
]]>
    
    </summary>
    
      <category term="RPC" scheme="http://colobu.com/tags/RPC/"/>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Scala DSL教程: 实现一个web框架路由器]]></title>
    <link href="http://colobu.com/2016/05/24/scala-dsl-tutorial-writing-web-framework-router/"/>
    <id>http://colobu.com/2016/05/24/scala-dsl-tutorial-writing-web-framework-router/</id>
    <published>2016-05-24T04:44:11.000Z</published>
    <updated>2016-06-21T08:57:05.000Z</updated>
    <content type="html"><![CDATA[<p>原文: <a href="http://codetunes.com/2012/scala-dsl-tutorial-writing-web-framework-router/" target="_blank" rel="external">Scala DSL tutorial - writing a web framework router</a>, 作者: Tymon Tobolski </p>
<p><strong>译者按:</strong><br>Scala非常适合实现DSL(<a href="https://en.wikipedia.org/wiki/Domain-specific_language" target="_blank" rel="external">Domain-specific language</a>)。我在使用Scala的过程中印象深刻的是<a href="http://www.scalatest.org/" target="_blank" rel="external">scalatest</a>和<a href="http://spray.io/documentation/1.2.3/spray-routing/" target="_blank" rel="external">spray-routing</a>,</p>
<p>比如scalatest的测试代码的编写：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> collection.mutable.Stack</div><div class="line"><span class="keyword">import</span> org.scalatest._</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleSpec</span> <span class="keyword">extends</span> <span class="title">FlatSpec</span> <span class="keyword">with</span> <span class="title">Matchers</span> </span>{</div><div class="line"></div><div class="line">  <span class="string">"A Stack"</span> should <span class="string">"pop values in last-in-first-out order"</span> in {</div><div class="line">    <span class="keyword">val</span> stack = <span class="keyword">new</span> Stack[Int]</div><div class="line">    stack.push(<span class="number">1</span>)</div><div class="line">    stack.push(<span class="number">2</span>)</div><div class="line">    stack.pop() should be (<span class="number">2</span>)</div><div class="line">    stack.pop() should be (<span class="number">1</span>)</div><div class="line">  }</div><div class="line"></div><div class="line">  it should <span class="string">"throw NoSuchElementException if an empty stack is popped"</span> in {</div><div class="line">    <span class="keyword">val</span> emptyStack = <span class="keyword">new</span> Stack[Int]</div><div class="line">    a [NoSuchElementException] should be thrownBy {</div><div class="line">      emptyStack.pop()</div><div class="line">    } </div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>或者 <a href="http://doc.akka.io/docs/akka/2.4.6/scala/http/routing-dsl/overview.html" target="_blank" rel="external">akka-http</a>的路由(route)的配置 (akka-http可以看作是spray 2.0的版本,因为作者现在在lightbend,也就是原先的typesafe公司开发akka-http)：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> route =</div><div class="line">  get {</div><div class="line">    pathSingleSlash {</div><div class="line">      complete(HttpEntity(ContentTypes.`text/html(UTF-<span class="number">8</span>)`,<span class="string">"&lt;html&gt;&lt;body&gt;Hello world!&lt;/body&gt;&lt;/html&gt;"</span>))</div><div class="line">    } ~</div><div class="line">      path(<span class="string">"ping"</span>) {</div><div class="line">        complete(<span class="string">"PONG!"</span>)</div><div class="line">      } ~</div><div class="line">      path(<span class="string">"crash"</span>) {</div><div class="line">        sys.error(<span class="string">"BOOM!"</span>)</div><div class="line">      }</div><div class="line">  }</div></pre></td></tr></table></figure>

<p>可以看到，使用Scala实现的DSL非常简洁，也符合人类便于阅读的方式。但是我们如何实现自己的DSL呢？文末有几篇参考文档，介绍了使用Scala实现DSL的技术，但是本文翻译的这篇文章，使用Scala实现了一个鸡蛋的web路由DSL，步骤详细，代码简单，所以我特意翻译了一下。以下内容（除了参考文档）是对原文的翻译。</p>
<a id="more"></a>
<h3 id="目标">目标</h3>
<p>Play 2.0的发布给Java社区带来了新的创建web service的方式。尽管非常美好，但是有些组件缺不是我的菜，其中之一它的router定义，它使用定制的route文件，独立的编译器和难以捉摸的逻辑。作为一个Riby程序员，我开始想能否使用Scala实现一个简单的DSL.需求很简单:</p>
<ul>
<li>静态编译</li>
<li>静态类型</li>
<li>易于使用</li>
<li>可扩展</li>
<li>反向路由</li>
<li>尽可能的类型推断</li>
<li>不使用圆括号</li>
</ul>
<h3 id="设计">设计</h3>
<p>所以第一个问题是：什么是路由器(router)? 它可以表示为<code>PartialFunction[Request, Handler]</code>,这就是Play框架中实现的方式。让我们花几秒钟先看看Play的原始的路由器。</p>
<p>在编译的过程中， conf/routes文件下的文件被解析并转换成target/src_managed文件夹下的.scala文件。有两个文件会被产生<code>routing.scala</code> 和 <code>reverse_routing.scala</code>。 <code>routing.scala</code>是一个巨大的<code>PartialFunction</code>,每一个路由使用一个case语句。 <code>reverse_routing.scala</code>对象结构。我真的不喜欢这种方式。</p>
<p>让我们开始探索 <em>如何使用Scala创建一个有用的DSL</em>。</p>
<h4 id="最终用户ui">最终用户ui</h4>
<p>我不知道DSL设计的最佳实践，我也从没读过一本关于这方面的书。我用我的方式来实现它。</p>
<p>实现的结果应该自然而直接。首先，描述你想要的，然后实现它。</p>
<p>开始的例子很简单，<code>GET /foo</code>可以路由到<code>Application.foo()</code>方法:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET <span class="string">"/foo"</span> Application.foo</div></pre></td></tr></table></figure>

<p>这个DSL非常好，但不幸的是，不使用括号的话，无法用Scala按这种方式实现。</p>
<p>当然，你已经知道Scala可是使用<code>infix notation</code>和<code>suffix notation</code>去掉括号：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A.op(B)</div></pre></td></tr></table></figure>

<p>可以写成</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A op B</div></pre></td></tr></table></figure>

<p>同样</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A.op(B).opp(C)</div></pre></td></tr></table></figure>

<p>可以写成</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A op B opp C</div></pre></td></tr></table></figure>

<p>但是这种写法仅仅适用于只有一个参数的方法， 如<code>objectA method objectB</code>。但是在我们上面的DSL例子中(GET &quot;/foo&quot; Application.foo),中间的不是是一个字符串，而不是一个方法名，所以我们不能使用<code>infix notation</code>。增加一些中间单词如何:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">GET on <span class="string">"/foo"</span> to Application.foo </div><div class="line">GET.on(<span class="string">"/foo"</span>).to(Application.foo) <span class="comment">//等价于上面的写法</span></div></pre></td></tr></table></figure>

<p>编译通过。 <code>GET</code>可以是一个代表HTTP method的对象， <code>on</code>是一个方法， <code>/foo</code>是这个方法的参数，然后<code>to</code>是另外一个方法，而<code>Application.foo</code>是一个<code>Function0[Handler]</code>。 我犯了一个错误，开始去实现它，然后我不得不扔掉了大段代码，因为实现并不能满足我前面定义的需求。</p>
<p>我来把坑挖的更深，来看看路径参数。怎么写一个路由来匹配 <code>GET /foo/{id}</code>然后调用<code>Application.show(id)</code>?，我的初始想法是:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET on <span class="string">"foo"</span> / * to Application.show</div></pre></td></tr></table></figure>

<p>看起来很好，<code>/</code>作为路径分隔符，<code>*</code>作为参数，而<code>Application.show</code>作为<code>Function1[Int, Handler]</code>。<code>/</code>作为方法实现，而<code>*</code>可以作为一个对象，因此上面的语句等价于:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET.on(<span class="string">"foo"</span>)./(*).to(Application.show) <span class="comment">// 错误!</span></div></pre></td></tr></table></figure>

<p>事实上， 由于<a href="http://stackoverflow.com/questions/2922347/operator-precedence-in-scala" target="_blank" rel="external">Scala操作符优先级的问题</a>，它实际等价于:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET.on( <span class="string">"foo"</span>./(*) ).to(Application.show)</div></pre></td></tr></table></figure>

<p>好消息，路径可以组合在一起作为<code>on</code>的参数。</p>
<p>更多的例子:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">GET on <span class="string">"foo"</span> to Application.foo</div><div class="line">PUT on <span class="string">"show"</span> / * to Application.show</div><div class="line">POST on <span class="string">"bar"</span> / * / * / <span class="string">"blah"</span> / * to Application.bar</div></pre></td></tr></table></figure>

<p>最后一件事，反向路由(reverse routing)。Play框架默认的路由器有一个限制，一个路由一个action。如果已经定义了一个路由，为什么不把它赋值给val变量用来反向路由呢：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> foo = GET on <span class="string">"foo"</span> to Application.foo</div></pre></td></tr></table></figure>

<p>然后把路由放在一个对象中：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">routes</span> </span>{</div><div class="line">  <span class="keyword">val</span> foo = GET on <span class="string">"foo"</span> to Application.foo</div><div class="line">  <span class="keyword">val</span> show = PUT on <span class="string">"show"</span> / * to Application.show</div><div class="line">  <span class="keyword">val</span> bar = POST on <span class="string">"bar"</span> / * / * / <span class="string">"blah"</span> / * to Application.bar</div><div class="line">}</div></pre></td></tr></table></figure>

<p>现在可以调用<code>routes.foo()</code> 或者 <code>routes.show(5)</code>可以得到路径。</p>
<p>本文的下一部分描述内部实现。现在你可以自己去实现它，或者参考我的实现 <a href="http://github.com/teamon/play-navigator" target="_blank" rel="external">http://github.com/teamon/play-navigator</a>, 但我强烈推荐你继续阅读实现部分。</p>
<h3 id="实现">实现</h3>
<p>这里有两个难点:<code>type</code>和<code>arity</code>。Scala中的<code>Function</code>可以有0到22个参数，代表[Function0]到<a href="">Function22</a>,后面我会介绍到。</p>
<p>我的实现<code>play-navigator</code> Route有几个参数:</p>
<ul>
<li>HTTP method</li>
<li>path definition</li>
<li>handler function</li>
</ul>
<p>用下面的例子描述各个部分：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> foo = GET on <span class="string">"foo"</span> / * to Application.show</div></pre></td></tr></table></figure>

<p>我们已经知道它等价于:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> foo = GET.on( <span class="string">"foo"</span>./(*) ).to(Application.shows)</div></pre></td></tr></table></figure>

<p>从左边开始，首先<code>GET</code>还没有实现，让我们实现它：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">Method</span></span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">ANY</span> <span class="keyword">extends</span> <span class="title">Method</span></span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">GET</span> <span class="keyword">extends</span> <span class="title">Method</span></span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">POST</span> <span class="keyword">extends</span> <span class="title">Method</span></span></div></pre></td></tr></table></figure>

<p>我定义了两个HTTP method和<code>ANY</code>对应所有的HTTP method。接下来应该实现<code>on</code>方法，但是我们还不知道它使用什么参数。让我们先看看<code>&quot;foo&quot; / *</code>。</p>
<p>路径可以有多个变种：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"foo"</span> / <span class="string">"bar"</span> / <span class="string">"baz"</span> <span class="string">"foo"</span> / * / <span class="string">"blah"</span> * / * / *</div></pre></td></tr></table></figure>

<p>幸好路径的各个部分可以用有限的几个类型来表示，它可以是静态路径，也可能是占位符。如此说来，我们可以使用Scala直接实现：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">PathElem</span></span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Static</span><span class="params">(name: String)</span> <span class="keyword">extends</span> <span class="title">PathElem</span></span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> * <span class="keyword">extends</span> <span class="title">PathElem</span></span></div></pre></td></tr></table></figure>

<p><code>case class</code>包装了一个字符串，而<code>*</code>是一个case object。不幸的的是，因为每个部分都有关联，我不得不描述更多的数据结构。先前我说过Scala有23种不同类型的<code>Function</code>，它们有不同数量的参数。我想让类型系统比较 路径占位符的数量和函数参数的数量，如果不匹配就抛出错误。因此我定义了不同版本的<code>RouteDefN</code>，我将数量减少到3：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">RouteDef</span>[<span class="title">Self</span>] </span>{</div><div class="line">  <span class="keyword">def</span> withMethod(method: Method): Self</div><div class="line">  <span class="keyword">def</span> method: Method</div><div class="line">  <span class="keyword">def</span> elems: List[PathElem]</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">RouteDef0</span><span class="params">(method: Method, elems: List[PathElem])</span> <span class="keyword">extends</span> <span class="title">RouteDef</span>[<span class="title">RouteDef0</span>]</span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">RouteDef1</span><span class="params">(method: Method, elems: List[PathElem])</span> <span class="keyword">extends</span> <span class="title">RouteDef</span>[<span class="title">RouteDef1</span>]</span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">RouteDef2</span><span class="params">(method: Method, elems: List[PathElem])</span> <span class="keyword">extends</span> <span class="title">RouteDef</span>[<span class="title">RouteDef2</span>]</span></div></pre></td></tr></table></figure>

<p><code>Self</code>类型和<code>withMethod</code>稍候解释。注意<code>RouteDefN</code>并没有类型参数（我说过我想尽可能地在编译的时候检查）。事实是<code>RouteDefN</code>仅仅知道它的HTTP method和 path elements，并不会理会handler函数本身。</p>
<p>目前的挑战是如何将</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET on <span class="string">"foo"</span> / * / <span class="string">"bar"</span></div></pre></td></tr></table></figure>

<p>转换为</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RouteDef1(GET, List(Static(<span class="string">"foo"</span>), *, Static(<span class="string">"bar"</span>)))</div></pre></td></tr></table></figure>

<p>靠隐式函数来救驾了。</p>
<p>首先我们需要将<code>String</code>转换成<code>RouteDef0</code>:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">implicit <span class="keyword">def</span> stringToRouteDef0(name: String) = RouteDef0(ANY, Static(name) :: Nil)</div></pre></td></tr></table></figure>

<p>任意一个字符串都转换成一个<code>RouteDef0</code>，拥有<code>ANY</code> method,下一步，同样的技巧应用与<code>*</code>类型:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">implicit <span class="keyword">def</span> asterixToRoutePath1(ast: *.<span class="keyword">type</span>) = RouteDef1(ANY, ast :: Nil)</div></pre></td></tr></table></figure>

<p>之所以是<code>RouteDef1</code>是因为已经有一个参数占位符。我们需要实现<code>/</code>方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">RouteDef0</span><span class="params">(method: Method, elems: List[PathElem])</span> <span class="keyword">extends</span> <span class="title">RouteDef</span>[<span class="title">RouteDef0</span>] </span>{</div><div class="line">  <span class="keyword">def</span> /(static: Static) = RouteDef0(method, elems :+ static)</div><div class="line">  <span class="keyword">def</span> /(p: PathElem) = RouteDef1(method, elems :+ p)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">RouteDef1</span><span class="params">(method: Method, elems: List[PathElem])</span> <span class="keyword">extends</span> <span class="title">RouteDef</span>[<span class="title">RouteDef1</span>]</span>{</div><div class="line">  <span class="keyword">def</span> /(static: Static) = RouteDef1(method, elems :+ static)</div><div class="line">  <span class="keyword">def</span> /(p: PathElem) = RouteDef2(method, elems :+ p)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">RouteDef2</span><span class="params">(method: Method, elems: List[PathElem])</span> <span class="keyword">extends</span> <span class="title">RouteDef</span>[<span class="title">RouteDef2</span>]</span>{</div><div class="line">  <span class="keyword">def</span> /(static: Static) = RouteDef2(method, elems :+ static)</div><div class="line">}</div></pre></td></tr></table></figure>



<p><code>/</code>方法的逻辑很简单。如果它得到Static参数，那么它返回的类型还是相同的类型。如果得到<code>*</code>参数，它返回一个更&quot;高&quot;的路由。<code>RouteDef2</code>并不允许传递<code>*</code>参数，所以我们没有定义<code>RouteDef3</code>。我们还需要实现一个字符串到<code>Static</code>的隐式转换。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">implicit <span class="keyword">def</span> stringToStatic(name: String) = Static(name)</div></pre></td></tr></table></figure>

<p>现在我们定义的DSL可以处理:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET on someRouteDef</div></pre></td></tr></table></figure>

<p>现在是<code>on</code>方法如何实现？</p>
<p>让我们返回<code>Method</code>定义，它的<code>on</code>方法需要类型参数<code>R</code>，它会调用routeDef的withMethod方法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">Method</span> </span>{</div><div class="line">  <span class="keyword">def</span> on[R](routeDef: RouteDef[R]): R = routeDef.withMethod(<span class="keyword">this</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>还记得<code>RouteDef</code>特质的<code>withMethod</code>方法的实现么？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">RouteDef</span>[<span class="title">Self</span>] </span>{</div><div class="line">  <span class="keyword">def</span> withMethod(method: Method): Self</div><div class="line">}</div></pre></td></tr></table></figure>

<p>现在<code>RouteDefN</code>可以写做:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">RouteDef0</span><span class="params">(method: Method, elems: List[PathElem])</span> <span class="keyword">extends</span> <span class="title">RouteDef</span>[<span class="title">RouteDef0</span>] </span>{</div><div class="line">  <span class="keyword">def</span> withMethod(method: Method) = RouteDef0(method, elems)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">RouteDef1</span><span class="params">(method: Method, elems: List[PathElem])</span> <span class="keyword">extends</span> <span class="title">RouteDef</span>[<span class="title">RouteDef1</span>]</span>{</div><div class="line">  <span class="keyword">def</span> withMethod(method: Method) = RouteDef1(method, elems)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">RouteDef2</span><span class="params">(method: Method, elems: List[PathElem])</span> <span class="keyword">extends</span> <span class="title">RouteDef</span>[<span class="title">RouteDef2</span>]</span>{</div><div class="line">  <span class="keyword">def</span> withMethod(method: Method) = RouteDef2(method, elems)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这样<code>on</code>方法就是返回正确的类型。</p>
<p>最后就是和handler拼装起来：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">someRouteDef to Application.show</div></pre></td></tr></table></figure>

<p>我说过我想让编译器检查路径参数中的参数数量是否和handler需要的参数数量一致。现在隆重转为疯狂的类<code>RouteN</code>出场。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">sealed trait Route[RD] {</div><div class="line">  def routeDef: RouteDef[RD]</div><div class="line">}</div><div class="line"></div><div class="line">case class Route0(routeDef: RouteDef0, f0: () ⇒ Out) extends Route[RouteDef0]</div><div class="line">case class Route1[A: PathParam : Manifest](routeDef: RouteDef1, f1: (A) ⇒ Out) extends Route[RouteDef1]</div><div class="line">case class Route2[A: PathParam : Manifest, B: PathParam : Manifest](routeDef: RouteDef2, f2: (A, B) ⇒ Out) extends Route[RouteDef2]</div></pre></td></tr></table></figure>

<p>呜呼哀哉， 类型、更多的类型、更多坨的类型，保持胃口继续看。<code>Route0</code>需要<code>RouteDef0</code>和<code>() ⇒ Out</code>参数。 <code>Route1</code> 需要<code>RouteDef1</code>和<code>function (A) ⇒ Out</code>,A为类型参数:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[A: PathParam : Manifest]</div></pre></td></tr></table></figure>


<p>是下面代码的简写：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[A](implicit pp: PathParam[A], mf: Manifest[A])</div></pre></td></tr></table></figure>

<p><code>PathParam[A]</code> 和 <code>Manifest[A]</code>稍后解释。</p>
<p>你也可能已经推断出<code>Route2</code>使用<code>RouteDef2</code> 和 <code>function (A,B) ⇒ Out</code>做参数,  A 和 B 都是类型参数。</p>
<p>返回到<code>RouteDef</code>,增加<code>to</code>方法:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">RouteDef0</span><span class="params">(method: Method, elems: List[PathElem])</span> <span class="keyword">extends</span> <span class="title">RouteDef</span>[<span class="title">RouteDef0</span>] </span>{</div><div class="line">  <span class="keyword">def</span> to(f0: () ⇒ Out) = Route0(<span class="keyword">this</span>, f0)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">RouteDef1</span><span class="params">(method: Method, elems: List[PathElem])</span> <span class="keyword">extends</span> <span class="title">RouteDef</span>[<span class="title">RouteDef1</span>]</span>{</div><div class="line">  <span class="keyword">def</span> to[A: PathParam : Manifest](f1: (A) ⇒ Out) = Route1(<span class="keyword">this</span>, f1)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">RouteDef2</span><span class="params">(method: Method, elems: List[PathElem])</span> <span class="keyword">extends</span> <span class="title">RouteDef</span>[<span class="title">RouteDef2</span>]</span>{</div><div class="line">  <span class="keyword">def</span> to[A: PathParam : Manifest, B: PathParam : Manifest](f2: (A, B) ⇒ Out) = Route2(<span class="keyword">this</span>, f2)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>编译器会检查参数的匹配问题,<code>RouteDefN</code>的<code>to</code>方法只会允许正确的Handler作为参数。</p>
<p>我们可以为<code>RouteN</code>增加<code>def apply</code>来来检查参数的数量和正确的类型。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">case class Route1[A: PathParam : Manifest](routeDef: RouteDef1, f2: (A) ⇒ Out) extends Route[RouteDef1] {</div><div class="line">  def apply(a: A) = PathMatcher1(routeDef.elems)(a)</div><div class="line">}</div><div class="line"></div><div class="line">case class Route2[A: PathParam : Manifest, B: PathParam : Manifest](routeDef: RouteDef2, f2: (A, B) ⇒ Out) extends Route[RouteDef2] {</div><div class="line">  def apply(a: A, b: B) = PathMatcher2(routeDef.elems)(a, b)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>所以如果我们定义了一个路由：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> foo = GET on <span class="string">"foo"</span> / * to Application.show</div></pre></td></tr></table></figure>

<p>这里<code>foo</code>是一个类型为<code>Route1[Int](RouteDef1(GET, Static(&quot;foo&quot;) :: * :: Nil), Application.show)</code>的对象，同时<code>foo</code>还是<code>(Int) ⇒ String</code>类型。</p>
<p>关于<code>PathMatcherN</code>用来匹配request uri到正确的路由。因为在本文中我只想介绍DSL相关的实现，所以我不想多介绍它。你可以把它看成一个解析和构造url的函数。</p>
<p>现在只剩下一件事。既然所有的路由都是类型安全的，那么我们需要一个类型安全的方式匹配路径和action。一种方式是硬编码，比较傻。既然我们已经有了类型敏感的路由，Scala拥有强大的类型系统，为什么不让工作好上加好呢？</p>
<p>我们需要做什么？</p>
<ul>
<li>解析路径(字符串)为我们的类型</li>
<li>转换路径参数为字符串 (for 反向路由)</li>
</ul>
<p>如何实现呢？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PathParam</span>[<span class="title">T</span>]</span>{</div><div class="line">  <span class="keyword">def</span> apply(t: T): String</div><div class="line">  <span class="keyword">def</span> unapply(s: String): Option[T]</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>apply</code>将类型T转换成字符串。而<code>unapply</code>将字符串转换成<code>T</code>。</p>
<p>下面是两个将路径参数转换成相应类型的例子。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">implicit <span class="keyword">val</span> StringPathParam: PathParam[String] = <span class="keyword">new</span> PathParam[String] {</div><div class="line">  <span class="keyword">def</span> apply(s: String) = s</div><div class="line">  <span class="keyword">def</span> unapply(s: String) = Some(s)</div><div class="line">}</div><div class="line"></div><div class="line">implicit <span class="keyword">val</span> BooleanPathParam: PathParam[Boolean] = <span class="keyword">new</span> PathParam[Boolean] {</div><div class="line">  <span class="keyword">def</span> apply(b: Boolean) = b.toString</div><div class="line">  <span class="keyword">def</span> unapply(s: String) = s.toLowerCase <span class="keyword">match</span> {</div><div class="line">    <span class="keyword">case</span> <span class="string">"1"</span> | <span class="string">"true"</span> | <span class="string">"yes"</span> ⇒ Some(<span class="keyword">true</span>)</div><div class="line">    <span class="keyword">case</span> <span class="string">"0"</span> | <span class="string">"false"</span> | <span class="string">"no"</span> ⇒ Some(<span class="keyword">false</span>)</div><div class="line">    <span class="keyword">case</span> _ ⇒ None</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>因此可以定制类型作为action (handler)的参数。</p>
<p>上文中一个秘密就是RouteN中的PathParam[A]，Route类只关心PathParam,所以使用其它类型创建route是不允许的，编译器出错。</p>
<p>Manifest[A]是Scala编译器提供的一个特殊的类，为类型提供运行时的类型信息。</p>
<p>再提供一个java.util.UUID的路径参数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">implicit <span class="keyword">val</span> UUIDPathParam: PathParam[UUID] = <span class="keyword">new</span> PathParam[UUID] {</div><div class="line">  <span class="keyword">def</span> apply(uuid: UUID) = uuid.toString</div><div class="line">  <span class="keyword">def</span> unapply(s: String) = <span class="keyword">try</span> {</div><div class="line">    Some(UUID.fromString(s))</div><div class="line">  } <span class="keyword">catch</span> {</div><div class="line">    <span class="keyword">case</span> _ ⇒ None</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>现在，让我们检查一下我们的需求：</p>
<ul>
<li>静态编译 √</li>
<li>静态类型 √</li>
<li>易于使用 √</li>
<li>可扩展 √</li>
<li>反向路由 √</li>
<li>尽可能的类型推断 √</li>
<li>不使用圆括号 √</li>
</ul>
<p>所有需求都实现。</p>
<p>如果你发现文中有遗漏的地方，或者错误，可以和作者联系 <a href="http://twitter.com/iteamon" target="_blank" rel="external">twitter (@iteamon)</a>, teamon on <a href="irc://irc.freenode.net/#scala" target="_blank" rel="external">#scala @ irc.freenode.net</a>。</p>
<p>你也可以看完整的项目实现: <a href="http://teamon.github.com/play-navigator" target="_blank" rel="external">play-navigator</a></p>
<p>翻译完毕。</p>
<h3 id="其它参考资料">其它参考资料</h3>
<ol>
<li><a href="http://www.scala-lang.org/old/node/1403" target="_blank" rel="external">DSLs - A powerful Scala feature</a></li>
<li><a href="http://blog.scalac.io/2015/05/07/encog-dsl.html" target="_blank" rel="external">Creating Domain Specific Languages with Scala - Part 1</a></li>
<li><a href="https://stanford-ppl.github.io/Delite/myfirstdsl.html" target="_blank" rel="external">My First DSL</a></li>
<li><a href="https://www.manning.com/books/dsls-in-action" target="_blank" rel="external">DSLs in Action</a></li>
<li><a href="http://blog.siddhuw.info/writing-dsls-using-scala-part-1-underlying-concepts/" target="_blank" rel="external">Writing DSLs using Scala. Part 1 — Underlying Concepts</a></li>
<li><a href="http://blog.siddhuw.info/writing-dsls-using-scala-part-ii-a-simple-matcher-dsl/" target="_blank" rel="external">Writing DSLs using Scala. Part II - A simple matcher DSL</a></li>
<li><a href="https://www.safaribooksonline.com/library/view/programming-scala/9780596801908/ch11.html" target="_blank" rel="external">Domain-Specific Languages in Scala</a></li>
<li><a href="https://github.com/p3t0r/scala-sql-dsl" target="_blank" rel="external">scala-sql-dsl</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文: <a href="http://codetunes.com/2012/scala-dsl-tutorial-writing-web-framework-router/" target="_blank" rel="external">Scala DSL tutorial - writing a web framework router</a>, 作者: Tymon Tobolski </p>
<p><strong>译者按:</strong><br>Scala非常适合实现DSL(<a href="https://en.wikipedia.org/wiki/Domain-specific_language" target="_blank" rel="external">Domain-specific language</a>)。我在使用Scala的过程中印象深刻的是<a href="http://www.scalatest.org/" target="_blank" rel="external">scalatest</a>和<a href="http://spray.io/documentation/1.2.3/spray-routing/" target="_blank" rel="external">spray-routing</a>,</p>
<p>比如scalatest的测试代码的编写：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> collection.mutable.Stack</div><div class="line"><span class="keyword">import</span> org.scalatest._</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleSpec</span> <span class="keyword">extends</span> <span class="title">FlatSpec</span> <span class="keyword">with</span> <span class="title">Matchers</span> </span>{</div><div class="line"></div><div class="line">  <span class="string">"A Stack"</span> should <span class="string">"pop values in last-in-first-out order"</span> in {</div><div class="line">    <span class="keyword">val</span> stack = <span class="keyword">new</span> Stack[Int]</div><div class="line">    stack.push(<span class="number">1</span>)</div><div class="line">    stack.push(<span class="number">2</span>)</div><div class="line">    stack.pop() should be (<span class="number">2</span>)</div><div class="line">    stack.pop() should be (<span class="number">1</span>)</div><div class="line">  }</div><div class="line"></div><div class="line">  it should <span class="string">"throw NoSuchElementException if an empty stack is popped"</span> in {</div><div class="line">    <span class="keyword">val</span> emptyStack = <span class="keyword">new</span> Stack[Int]</div><div class="line">    a [NoSuchElementException] should be thrownBy {</div><div class="line">      emptyStack.pop()</div><div class="line">    } </div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>或者 <a href="http://doc.akka.io/docs/akka/2.4.6/scala/http/routing-dsl/overview.html" target="_blank" rel="external">akka-http</a>的路由(route)的配置 (akka-http可以看作是spray 2.0的版本,因为作者现在在lightbend,也就是原先的typesafe公司开发akka-http)：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> route =</div><div class="line">  get {</div><div class="line">    pathSingleSlash {</div><div class="line">      complete(HttpEntity(ContentTypes.`text/html(UTF-<span class="number">8</span>)`,<span class="string">"&lt;html&gt;&lt;body&gt;Hello world!&lt;/body&gt;&lt;/html&gt;"</span>))</div><div class="line">    } ~</div><div class="line">      path(<span class="string">"ping"</span>) {</div><div class="line">        complete(<span class="string">"PONG!"</span>)</div><div class="line">      } ~</div><div class="line">      path(<span class="string">"crash"</span>) {</div><div class="line">        sys.error(<span class="string">"BOOM!"</span>)</div><div class="line">      }</div><div class="line">  }</div></pre></td></tr></table></figure>

<p>可以看到，使用Scala实现的DSL非常简洁，也符合人类便于阅读的方式。但是我们如何实现自己的DSL呢？文末有几篇参考文档，介绍了使用Scala实现DSL的技术，但是本文翻译的这篇文章，使用Scala实现了一个鸡蛋的web路由DSL，步骤详细，代码简单，所以我特意翻译了一下。以下内容（除了参考文档）是对原文的翻译。</p>
]]>
    
    </summary>
    
      <category term="DSL" scheme="http://colobu.com/tags/DSL/"/>
    
      <category term="Scala" scheme="http://colobu.com/categories/Scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[更好的Scala I/O: better-files]]></title>
    <link href="http://colobu.com/2016/05/11/better-files-Simple-safe-and-intuitive-Scala-I-O/"/>
    <id>http://colobu.com/2016/05/11/better-files-Simple-safe-and-intuitive-Scala-I-O/</id>
    <published>2016-05-11T08:09:21.000Z</published>
    <updated>2016-06-21T08:57:04.000Z</updated>
    <content type="html"><![CDATA[<p>对于使用Scala的程序员来说， I/O操作如文件的读写通常使用<a href="http://www.scala-lang.org/api/current/#scala.io.Source$" target="_blank" rel="external">scala.io.Source</a>来实现。但是这个类功能还是欠缺的，而且功能混乱，因此在Scala类库的增强提案(<a href="https://github.com/scala/slip/issues/19" target="_blank" rel="external">Scala IO fix-up/overhaul</a>)中如何改进它争论相当的大，甚至有些开发者提议将这个库废掉，让社区实现的第三方来完成这方面的工作，或者引导开发者使用<code>java.nio</code>来实现I/O操作。</p>
<p>当然，作为一个使用Scala的公司来说，可能会自己实现了辅助的I/O操作的方法， 比如类似FileUtils等名称的一些类。Java程序员可能已经熟悉了使用<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html" target="_blank" rel="external">java.nio.file.Files</a>、<a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/io/Files.html" target="_blank" rel="external">Guava</a>、<a href="https://commons.apache.org/proper/commons-io/" target="_blank" rel="external">Apache common-io</a>、<a href="http://jodd.org/api/jodd/io/FileUtil.html" target="_blank" rel="external">jodd FileUtil</a>等开源I/O库，但是如果使用Scala进行I/O操作时，虽然还是可以使用这些Java I/O库,但是毕竟还是不是那么纯粹，因此，我们可以关注一下Scala实现的I/O库，比如<a href="https://github.com/sbt/io" target="_blank" rel="external">sbt io</a>、<a href="http://www.lihaoyi.com/Ammonite/#Ammonite-Ops" target="_blank" rel="external">Ammonite-Ops</a>、<a href="https://github.com/pathikrit/better-files" target="_blank" rel="external">better-files</a>等。</p>
<p>本文为你推荐<a href="https://github.com/pathikrit/better-files" target="_blank" rel="external">better-files</a>。</p>
<a id="more"></a>
<p>为什么推荐<a href="https://github.com/pathikrit/better-files" target="_blank" rel="external">better-files</a>呢？让我们看看它的功能，就明白它的简单而强大了，就像一把I/O操作的瑞士军刀。</p>
<p>要使用better-files,只需加入下面的依赖：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">libraryDependencies += <span class="string">"com.github.pathikrit"</span> %% <span class="string">"better-files"</span> % <span class="keyword">version</span></div></pre></td></tr></table></figure>

<p>它对Java NIO库进行了包装，不依赖其它的第三方库。</p>
<blockquote>
<p>以下介绍摘译自better-files的<a href="https://github.com/pathikrit/better-files#tutorial-" target="_blank" rel="external">官方文档</a>。</p>
</blockquote>
<h3 id="实例化">实例化</h3>
<p>下面的实例都是等价的，才可以采用多种方式得到File对象。可以通过字符串、String interpolator, Java File、隐式转换、定义的常量和操作符&quot;/&quot;等产生File对象。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> better.files._</div><div class="line"><span class="keyword">import</span> java.io.{File =&gt; JFile}</div><div class="line"></div><div class="line"><span class="keyword">val</span> f = File(<span class="string">"/User/johndoe/Documents"</span>)                      <span class="comment">// using constructor</span></div><div class="line"><span class="keyword">val</span> f1: File = file<span class="string">"/User/johndoe/Documents"</span>                 <span class="comment">// using string interpolator</span></div><div class="line"><span class="keyword">val</span> f2: File = <span class="string">"/User/johndoe/Documents"</span>.toFile              <span class="comment">// convert a string path to a file</span></div><div class="line"><span class="keyword">val</span> f3: File = <span class="keyword">new</span> JFile(<span class="string">"/User/johndoe/Documents"</span>).toScala  <span class="comment">// convert a Java file to Scala</span></div><div class="line"><span class="keyword">val</span> f4: File = root/<span class="string">"User"</span>/<span class="string">"johndoe"</span>/<span class="string">"Documents"</span>             <span class="comment">// using root helper to start from root</span></div><div class="line"><span class="keyword">val</span> f5: File = `~` / <span class="string">"Documents"</span>                             <span class="comment">// also equivalent to `home / "Documents"`</span></div><div class="line"><span class="keyword">val</span> f6: File = <span class="string">"/User"</span>/<span class="string">"johndoe"</span>/<span class="string">"Documents"</span>                 <span class="comment">// using file separator DSL</span></div><div class="line"><span class="keyword">val</span> f7: File = home/<span class="string">"Documents"</span>/<span class="string">"presentations"</span>/`..`         <span class="comment">// Use `..` to navigate up to parent</span></div></pre></td></tr></table></figure>

<h3 id="文件读写">文件读写</h3>
<p>可以一行搞定：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> file = root/<span class="string">"tmp"</span>/<span class="string">"test.txt"</span></div><div class="line">file.overwrite(<span class="string">"hello"</span>)</div><div class="line">file.appendLine().append(<span class="string">"world"</span>)</div><div class="line">assert(file.contentAsString == <span class="string">"hello\nworld"</span>)</div></pre></td></tr></table></figure>

<p>类似C++/Shell风格的读写，和上面的功能一样：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">file &lt; <span class="string">"hello"</span>     <span class="comment">// same as file.overwrite("hello")</span></div><div class="line">file &lt;&lt; <span class="string">"world"</span>    <span class="comment">// same as file.appendLines("world")</span></div><div class="line">assert(file! == <span class="string">"hello\nworld"</span>)</div></pre></td></tr></table></figure>

<p>或者这样：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"hello"</span> `&gt;:` file</div><div class="line"><span class="string">"world"</span> &gt;&gt;: file</div><div class="line"><span class="keyword">val</span> bytes: Array[Byte] = file.loadBytes</div></pre></td></tr></table></figure>

<p><strong>流式接口风格：</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(root/<span class="string">"tmp"</span>/<span class="string">"diary.txt"</span>)</div><div class="line"> .createIfNotExists()  </div><div class="line"> .appendLine()</div><div class="line"> .appendLines(<span class="string">"My name is"</span>, <span class="string">"Inigo Montoya"</span>)</div><div class="line"> .moveTo(home/<span class="string">"Documents"</span>)</div><div class="line"> .renameTo(<span class="string">"princess_diary.txt"</span>)</div><div class="line"> .changeExtensionTo(<span class="string">".md"</span>)</div><div class="line"> .lines</div></pre></td></tr></table></figure>


<h3 id="Stream和编码">Stream和编码</h3>
<p>产生迭代器：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> bytes  : Iterator[Byte]            = file.bytes</div><div class="line"><span class="keyword">val</span> chars  : Iterator[Char]            = file.chars</div><div class="line"><span class="keyword">val</span> lines  : Iterator[String]          = file.lines</div><div class="line"><span class="keyword">val</span> source : scala.io.BufferedSource   = file.newBufferedSource <span class="comment">// needs to be closed, unlike the above APIs which auto closes when iterator ends</span></div></pre></td></tr></table></figure>

<p>编解码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> content: String = file.contentAsString  <span class="comment">// default codec</span></div><div class="line"><span class="comment">// custom codec:</span></div><div class="line"><span class="keyword">import</span> scala.io.Codec</div><div class="line">file.contentAsString(Codec.ISO8859)</div><div class="line"><span class="comment">//or</span></div><div class="line"><span class="keyword">import</span> scala.io.Codec.string2codec</div><div class="line">file.write(<span class="string">"hello world"</span>)(codec = <span class="string">"US-ASCII"</span>)</div></pre></td></tr></table></figure>

<h3 id="与Java交互">与Java交互</h3>
<p>转换成Java对象：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> file: File = tmp / <span class="string">"hello.txt"</span></div><div class="line"><span class="keyword">val</span> javaFile     : java.io.File                 = file.toJava</div><div class="line"><span class="keyword">val</span> uri          : java.net.uri                 = file.uri</div><div class="line"><span class="keyword">val</span> reader       : java.io.BufferedReader       = file.newBufferedReader </div><div class="line"><span class="keyword">val</span> outputstream : java.io.OutputStream         = file.newOutputStream </div><div class="line"><span class="keyword">val</span> writer       : java.io.BufferedWriter       = file.newBufferedWriter </div><div class="line"><span class="keyword">val</span> inputstream  : java.io.InputStream          = file.newInputStream</div><div class="line"><span class="keyword">val</span> path         : java.nio.file.Path           = file.path</div><div class="line"><span class="keyword">val</span> fs           : java.nio.file.FileSystem     = file.fileSystem</div><div class="line"><span class="keyword">val</span> channel      : java.nio.channel.FileChannel = file.newFileChannel</div><div class="line"><span class="keyword">val</span> ram          : java.io.RandomAccessFile     = file.newRandomAccess</div><div class="line"><span class="keyword">val</span> fr           : java.io.FileReader           = file.newFileReader</div><div class="line"><span class="keyword">val</span> fw           : java.io.FileWriter           = file.newFileWriter(append = <span class="keyword">true</span>)</div><div class="line"><span class="keyword">val</span> printer      : java.io.PrintWriter          = file.newPrintWriter</div></pre></td></tr></table></figure>

<p>以及</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">file1.reader &gt; file2.writer       <span class="comment">// pipes a reader to a writer</span></div><div class="line">System.in &gt; file2.out             <span class="comment">// pipes an inputstream to an outputstream</span></div><div class="line">src.pipeTo(sink)                  <span class="comment">// if you don't like symbols</span></div><div class="line"></div><div class="line"><span class="keyword">val</span> bytes   : Iterator[Byte]        = inputstream.bytes</div><div class="line"><span class="keyword">val</span> bis     : BufferedInputStream   = inputstream.buffered  </div><div class="line"><span class="keyword">val</span> bos     : BufferedOutputStream  = outputstream.buffered   </div><div class="line"><span class="keyword">val</span> reader  : InputStreamReader     = inputstream.reader</div><div class="line"><span class="keyword">val</span> writer  : OutputStreamWriter    = outputstream.writer</div><div class="line"><span class="keyword">val</span> printer : PrintWriter           = outputstream.printWriter</div><div class="line"><span class="keyword">val</span> br      : BufferedReader        = reader.buffered</div><div class="line"><span class="keyword">val</span> bw      : BufferedWriter        = writer.buffered</div><div class="line"><span class="keyword">val</span> mm      : MappedByteBuffer      = fileChannel.toMappedByteBuffer</div></pre></td></tr></table></figure>

<h3 id="模式匹配">模式匹配</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * <span class="property">@return</span> <span class="literal">true</span> <span class="keyword">if</span> file <span class="keyword">is</span> a directory <span class="reserved">with</span> <span class="literal">no</span> children <span class="keyword">or</span> a file <span class="reserved">with</span> <span class="literal">no</span> contents</div><div class="line"> */</div><div class="line">def isEmpty(<span class="attribute">file</span>: File): Boolean = file match {</div><div class="line">  <span class="reserved">case</span> File.Type.SymbolicLink<span class="function"><span class="params">(to)</span> =&gt;</span> isEmpty(to)  <span class="regexp">//</span> <span class="keyword">this</span> must be first <span class="reserved">case</span> statement <span class="keyword">if</span> you want to handle symlinks specially; <span class="keyword">else</span> will follow link</div><div class="line">  <span class="reserved">case</span> File.Type.Directory<span class="function"><span class="params">(files)</span> =&gt;</span> files.isEmpty</div><div class="line">  <span class="reserved">case</span> File.Type.RegularFile<span class="function"><span class="params">(content)</span> =&gt;</span> content.isEmpty</div><div class="line">  <span class="reserved">case</span> _<span class="function"> =&gt;</span> file.notExists    <span class="regexp">//</span> a file may <span class="keyword">not</span> be one <span class="keyword">of</span> the above e.g. UNIX pipes, sockets, devices etc</div><div class="line">}</div><div class="line"><span class="regexp">//</span> <span class="keyword">or</span> as extractors <span class="literal">on</span> <span class="attribute">LHS</span>:</div><div class="line">val File.Type.Directory(researchDocs) = home<span class="regexp">/"Downloads"/</span><span class="string">"research"</span></div></pre></td></tr></table></figure>

<h3 id="通配符">通配符</h3>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> dir = <span class="string">"src"</span>/<span class="string">"test"</span></div><div class="line"><span class="keyword">val</span> matches: Iterator[File] = dir.glob(<span class="string">"**/*.{java,scala}"</span>)</div><div class="line"><span class="comment">// above code is equivalent to:</span></div><div class="line">dir.listRecursively.filter(f =&gt; f.extension == Some(<span class="string">".java"</span>) || f.extension == Some(<span class="string">".scala"</span>))</div></pre></td></tr></table></figure>

<p>甚至使用正则表达式：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> matches = dir.glob(<span class="string">"^\\w*$"</span>)(syntax = File.PathMatcherSyntax.regex)</div></pre></td></tr></table></figure>

<h3 id="文件系统操作">文件系统操作</h3>
<p>文件系统操作也非常的便利：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">file</span>.touch()</div><div class="line"><span class="keyword">file</span>.<span class="keyword">delete</span>()     <span class="comment">// unlike the Java API, also works on directories as expected (deletes children recursively)</span></div><div class="line"><span class="keyword">file</span>.clear()      <span class="comment">// If directory, deletes all children; if file clears contents</span></div><div class="line"><span class="keyword">file</span>.renameTo(newName: String)</div><div class="line"><span class="keyword">file</span>.moveTo(destination)</div><div class="line"><span class="keyword">file</span>.copyTo(destination)       <span class="comment">// unlike the default API, also works on directories (copies recursively)</span></div><div class="line"><span class="keyword">file</span>.linkTo(destination)                     <span class="comment">// ln file destination</span></div><div class="line"><span class="keyword">file</span>.symbolicLinkTo(destination)             <span class="comment">// ln -s file destination</span></div><div class="line"><span class="keyword">file</span>.{checksum, md5, sha1, sha256, sha512, digest}   <span class="comment">// also works for directories</span></div><div class="line"><span class="keyword">file</span>.setOwner(user: String)    <span class="comment">// chown user file</span></div><div class="line"><span class="keyword">file</span>.setGroup(<span class="keyword">group</span>: String)   <span class="comment">// chgrp group file</span></div><div class="line">Seq(file1, file2) &gt;: file3     <span class="comment">// same as cat file1 file2 &gt; file3</span></div><div class="line">Seq(file1, file2) &gt;&gt;: file3    <span class="comment">// same as cat file1 file2 &gt;&gt; file3</span></div><div class="line"><span class="keyword">file</span>.isReadLocked <span class="regexp">/ file.isWriteLocked /</span> <span class="keyword">file</span>.isLocked</div><div class="line"><span class="keyword">File</span>.newTemporaryDirectory() <span class="regexp">/ File.newTemporaryFile() /</span><span class="regexp">/ create temp dir/</span><span class="keyword">file</span></div></pre></td></tr></table></figure>

<h3 id="UNIX_DSL">UNIX DSL</h3>
<p>甚至提供了UNIX命令风格的操作：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import better.files_, Cmds._  <span class="comment"> // must import Cmds._ to bring in these utils</span></div><div class="line">pwd / cwd    <span class="comment"> // current dir</span></div><div class="line">cp(file1, file2)</div><div class="line">mv(file1, file2)</div><div class="line">rm(<span class="built_in">file</span>) <span class="comment">/*or*/</span> del(<span class="built_in">file</span>)</div><div class="line">ls(<span class="built_in">file</span>) <span class="comment">/*or*/</span> dir(<span class="built_in">file</span>)</div><div class="line"><span class="built_in">ln</span>(file1, file2)    <span class="comment"> // hard link</span></div><div class="line">ln_s(file1, file2)  <span class="comment"> // soft link</span></div><div class="line">cat(file1)</div><div class="line">cat(file1) &gt;&gt;: <span class="built_in">file</span></div><div class="line">touch(<span class="built_in">file</span>)</div><div class="line">mkdir(<span class="built_in">file</span>)</div><div class="line">mkdirs(<span class="built_in">file</span>)        <span class="comment"> // mkdir -p</span></div><div class="line">chown(owner, <span class="built_in">file</span>)</div><div class="line">chgrp(owner, <span class="built_in">file</span>)</div><div class="line">chmod_+(permission, <span class="built_in">files</span>) <span class="comment"> // add permission</span></div><div class="line">chmod_-(permission, <span class="built_in">files</span>) <span class="comment"> // remove permission</span></div><div class="line">md5(<span class="built_in">file</span>) / sha1(<span class="built_in">file</span>) / sha256(<span class="built_in">file</span>) / sha512(<span class="built_in">file</span>)</div><div class="line">unzip(zipFile)(targetDir)</div><div class="line">zip(<span class="built_in">file</span>*)(zipFile)</div></pre></td></tr></table></figure>

<h3 id="文件属性">文件属性</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">file</span>.name       // simpler than java.io.File#getName</div><div class="line"><span class="keyword">file</span>.extension</div><div class="line"><span class="keyword">file</span>.contentType</div><div class="line"><span class="keyword">file</span>.lastModifiedTime     // returns JSR-<span class="number">310</span> time</div><div class="line"><span class="keyword">file</span>.owner / <span class="keyword">file</span>.group</div><div class="line"><span class="keyword">file</span>.isDirectory / <span class="keyword">file</span>.isSymbolicLink / <span class="keyword">file</span>.isRegularFile</div><div class="line"><span class="keyword">file</span>.isHidden</div><div class="line"><span class="keyword">file</span>.<span class="keyword">hide</span>() / <span class="keyword">file</span>.<span class="keyword">unhide</span>()</div><div class="line"><span class="keyword">file</span>.isOwnerExecutable / <span class="keyword">file</span>.isGroupReadable // etc. see <span class="keyword">file</span>.permissions</div><div class="line"><span class="keyword">file</span>.size                 // <span class="keyword">for</span> <span class="keyword">a</span> directory, computes the directory size</div><div class="line"><span class="keyword">file</span>.posixAttributes / <span class="keyword">file</span>.dosAttributes  // see <span class="keyword">file</span>.attributes</div><div class="line"><span class="keyword">file</span>.isEmpty      // true <span class="keyword">if</span> <span class="keyword">file</span> <span class="built_in">has</span> <span class="keyword">no</span> content (<span class="built_in">or</span> <span class="keyword">no</span> children <span class="keyword">if</span> directory) <span class="built_in">or</span> does not exist</div><div class="line"><span class="keyword">file</span>.isParentOf / <span class="keyword">file</span>.isChildOf / <span class="keyword">file</span>.isSiblingOf / <span class="keyword">file</span>.siblings</div></pre></td></tr></table></figure>

<p><code>chmod</code>:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.nio.file.attribute.PosixFilePermission</div><div class="line">file.addPermission(PosixFilePermission.OWNER_EXECUTE)      <span class="comment">// chmod +X file</span></div><div class="line">file.removePermission(PosixFilePermission.OWNER_WRITE)     <span class="comment">// chmod -w file</span></div><div class="line">assert(file.permissionsAsString == <span class="string">"rw-r--r--"</span>)</div><div class="line"></div><div class="line"><span class="comment">// The following are all equivalent:</span></div><div class="line">assert(file.permissions contains PosixFilePermission.OWNER_EXECUTE)</div><div class="line">assert(file(PosixFilePermission.OWNER_EXECUTE))</div><div class="line">assert(file.isOwnerExecutable)</div></pre></td></tr></table></figure>

<h3 id="文件比较">文件比较</h3>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">file1 == file2    <span class="comment">// equivalent to `file1.isSamePathAs(file2)`</span></div><div class="line">file1 === file2   <span class="comment">// equivalent to `file1.isSameContentAs(file2)` (works for regular-files and directories)</span></div><div class="line">file1 != file2    <span class="comment">// equivalent to `!file1.isSamePathAs(file2)`</span></div><div class="line">file1 =!= file2   <span class="comment">// equivalent to `!file1.isSameContentAs(file2)`</span></div></pre></td></tr></table></figure>

<p>排序:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> files = myDir.list.toSeq</div><div class="line">files.sorted(File.Order.byName) </div><div class="line">files.max(File.Order.bySize) </div><div class="line">files.min(File.Order.byDepth) </div><div class="line">files.max(File.Order.byModificationTime) </div><div class="line">files.sorted(File.Order.byDirectoriesFirst)</div></pre></td></tr></table></figure>

<h3 id="压缩解压缩">压缩解压缩</h3>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Unzipping:</span></div><div class="line"><span class="keyword">val</span> zipFile: File = file<span class="string">"path/to/research.zip"</span></div><div class="line"><span class="keyword">val</span> research: File = zipFile.unzipTo(destination = home/<span class="string">"Documents"</span>/<span class="string">"research"</span>) </div><div class="line"></div><div class="line"><span class="comment">// Zipping:</span></div><div class="line"><span class="keyword">val</span> zipFile: File = directory.zipTo(destination = home/<span class="string">"Desktop"</span>/<span class="string">"toEmail.zip"</span>)</div><div class="line"></div><div class="line"><span class="comment">// Zipping/Unzipping to temporary files/directories:</span></div><div class="line"><span class="keyword">val</span> someTempZipFile: File = directory.zip()</div><div class="line"><span class="keyword">val</span> someTempDir: File = zipFile.unzip()</div><div class="line">assert(directory === someTempDir)</div><div class="line"></div><div class="line"><span class="comment">// Gzip handling:</span></div><div class="line">File(<span class="string">"countries.gz"</span>).newInputStream.gzipped.lines.take(<span class="number">10</span>).foreach(println)</div></pre></td></tr></table></figure>

<h3 id="轻量级的ARM_(自动化的资源管理)">轻量级的ARM (自动化的资源管理)</h3>
<p>Auto-close Java closeables:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> {</div><div class="line">  in &lt;- file1.newInputStream.autoClosed</div><div class="line">  out &lt;- file2.newOutputStream.autoClosed</div><div class="line">} in.pipeTo(out)</div></pre></td></tr></table></figure>

<p><code>better-files</code>提供了更加便利的管理，因此下面的代码</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> {</div><div class="line"> reader &lt;- file.newBufferedReader.autoClosed</div><div class="line">} foo(reader)</div></pre></td></tr></table></figure>

<p>可以写成：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> {</div><div class="line"> reader &lt;- file.bufferedReader    <span class="comment">// returns ManagedResource[BufferedReader]</span></div><div class="line">} foo(reader)</div><div class="line"></div><div class="line"><span class="comment">// or simply:</span></div><div class="line">file.bufferedReader.map(foo)</div></pre></td></tr></table></figure>

<h3 id="Scanner">Scanner</h3>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> data = t1 &lt;&lt; s<span class="string">"""</span></div><div class="line">  | Hello World</div><div class="line">  | 1 true 2 3</div><div class="line">""".stripMargin</div><div class="line"><span class="keyword">val</span> scanner: Scanner = data.newScanner()</div><div class="line">assert(scanner.next[String] == <span class="string">"Hello"</span>)</div><div class="line">assert(scanner.lineNumber == <span class="number">1</span>)</div><div class="line">assert(scanner.next[String] == <span class="string">"World"</span>)</div><div class="line">assert(scanner.next[(Int, Boolean)] == (<span class="number">1</span>, <span class="keyword">true</span>))</div><div class="line">assert(scanner.tillEndOfLine() == <span class="string">" 2 3"</span>)</div><div class="line">assert(!scanner.hasNext)</div></pre></td></tr></table></figure>

<p>你甚至可以写定制的Scanner。</p>
<h3 id="文件监控">文件监控</h3>
<p>普通的Java文件监控：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.nio.file.{StandardWatchEventKinds =&gt; EventType}</div><div class="line"><span class="keyword">val</span> service: java.nio.file.WatchService = myDir.newWatchService</div><div class="line">myDir.register(service, events = Seq(EventType.ENTRY_CREATE, EventType.ENTRY_DELETE))</div></pre></td></tr></table></figure>

<p><code>better-files</code>抽象了一个简单的接口：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> watcher = <span class="keyword">new</span> ThreadBackedFileMonitor(myDir, recursive = <span class="keyword">true</span>) {</div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> onCreate(file: File) = println(s<span class="string">"$file got created"</span>)</div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> onModify(file: File) = println(s<span class="string">"$file got modified"</span>)</div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> onDelete(file: File) = println(s<span class="string">"$file got deleted"</span>)</div><div class="line">}</div><div class="line">watcher.start()</div></pre></td></tr></table></figure>

<p>或者用下面的写法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.nio.file.{Path, StandardWatchEventKinds =&gt; EventType, WatchEvent}</div><div class="line"></div><div class="line"><span class="keyword">val</span> watcher = <span class="keyword">new</span> ThreadBackedFileMonitor(myDir, recursive = <span class="keyword">true</span>) {</div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> dispatch(eventType: WatchEvent.Kind[Path], file: File) = eventType <span class="keyword">match</span> {</div><div class="line">    <span class="keyword">case</span> EventType.ENTRY_CREATE =&gt; println(s<span class="string">"$file got created"</span>)</div><div class="line">    <span class="keyword">case</span> EventType.ENTRY_MODIFY =&gt; println(s<span class="string">"$file got modified"</span>)</div><div class="line">    <span class="keyword">case</span> EventType.ENTRY_DELETE =&gt; println(s<span class="string">"$file got deleted"</span>)</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Akka_风格的文件监控">Akka 风格的文件监控</h3>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> akka.actor.{ActorRef, ActorSystem}</div><div class="line"><span class="keyword">import</span> better.files._, FileWatcher._</div><div class="line"></div><div class="line">implicit <span class="keyword">val</span> system = ActorSystem(<span class="string">"mySystem"</span>)</div><div class="line"></div><div class="line"><span class="keyword">val</span> watcher: ActorRef = (home/<span class="string">"Downloads"</span>).newWatcher(recursive = <span class="keyword">true</span>)</div><div class="line"></div><div class="line"><span class="comment">// register partial function for an event</span></div><div class="line">watcher ! on(EventType.ENTRY_DELETE) {    </div><div class="line">  <span class="keyword">case</span> file <span class="keyword">if</span> file.isDirectory =&gt; println(s<span class="string">"$file got deleted"</span>) </div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// watch for multiple events</span></div><div class="line">watcher ! when(events = EventType.ENTRY_CREATE, EventType.ENTRY_MODIFY) {   </div><div class="line">  <span class="keyword">case</span> (EventType.ENTRY_CREATE, file) =&gt; println(s<span class="string">"$file got created"</span>)</div><div class="line">  <span class="keyword">case</span> (EventType.ENTRY_MODIFY, file) =&gt; println(s<span class="string">"$file got modified"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>对于使用Scala的程序员来说， I/O操作如文件的读写通常使用<a href="http://www.scala-lang.org/api/current/#scala.io.Source$" target="_blank" rel="external">scala.io.Source</a>来实现。但是这个类功能还是欠缺的，而且功能混乱，因此在Scala类库的增强提案(<a href="https://github.com/scala/slip/issues/19" target="_blank" rel="external">Scala IO fix-up/overhaul</a>)中如何改进它争论相当的大，甚至有些开发者提议将这个库废掉，让社区实现的第三方来完成这方面的工作，或者引导开发者使用<code>java.nio</code>来实现I/O操作。</p>
<p>当然，作为一个使用Scala的公司来说，可能会自己实现了辅助的I/O操作的方法， 比如类似FileUtils等名称的一些类。Java程序员可能已经熟悉了使用<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html" target="_blank" rel="external">java.nio.file.Files</a>、<a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/io/Files.html" target="_blank" rel="external">Guava</a>、<a href="https://commons.apache.org/proper/commons-io/" target="_blank" rel="external">Apache common-io</a>、<a href="http://jodd.org/api/jodd/io/FileUtil.html" target="_blank" rel="external">jodd FileUtil</a>等开源I/O库，但是如果使用Scala进行I/O操作时，虽然还是可以使用这些Java I/O库,但是毕竟还是不是那么纯粹，因此，我们可以关注一下Scala实现的I/O库，比如<a href="https://github.com/sbt/io" target="_blank" rel="external">sbt io</a>、<a href="http://www.lihaoyi.com/Ammonite/#Ammonite-Ops" target="_blank" rel="external">Ammonite-Ops</a>、<a href="https://github.com/pathikrit/better-files" target="_blank" rel="external">better-files</a>等。</p>
<p>本文为你推荐<a href="https://github.com/pathikrit/better-files" target="_blank" rel="external">better-files</a>。</p>
]]>
    
    </summary>
    
      <category term="Scala" scheme="http://colobu.com/tags/Scala/"/>
    
      <category term="Scala" scheme="http://colobu.com/categories/Scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用WinMerge作为git的Merge工具]]></title>
    <link href="http://colobu.com/2016/05/10/using-winmerge-with-tortoisegit/"/>
    <id>http://colobu.com/2016/05/10/using-winmerge-with-tortoisegit/</id>
    <published>2016-05-10T02:26:00.000Z</published>
    <updated>2016-06-21T08:57:05.000Z</updated>
    <content type="html"><![CDATA[<p>我比较喜欢使用免费的<a href="http://winmerge.org/" target="_blank" rel="external">WinMerge</a>作为diff和merge工具，虽然TortoiseGit也自己带了TortoiseGitMerge工具，但是使用起来总觉得不是那么方便。</p>
<p>虽然WinMerge项目看起来没人维护了，最后一个发布打分版本在2013-02-02，但是这个工具使用起来还是相当方便的。我在重装机器的时候，或者更新Windows的时候，如果需要配置TortoiseGit,总是需要到网上查找如何配置WinMerge,因为长长的命令参数总是记不起来。所以在本文中记录下来。</p>
<a id="more"></a>
<h3 id="作为Diff工具">作为Diff工具</h3>
<p>如果使用WinMerge作为diff工具，需要在TortoiseGit的设置(Setting)对话框中选择Diff Viewer:</p>
<p><img src="diff.png" alt=""></p>
<p>选择外部工具&quot;External&quot;,在输入框中输入：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\Program Files (x86)\WinMerge\WinMergeU.exe <span class="regexp">/s /</span>e <span class="regexp">/x /</span>ul <span class="regexp">/ur /</span>wl <span class="regexp">/dl %bname /</span>dr %yname %base %mine</div></pre></td></tr></table></figure>

<p>如果你已经把<code>C:\Program Files (x86)\WinMerge</code>加入到环境变量Path中了，你可以简写成：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WinMergeU <span class="regexp">/s /</span>e <span class="regexp">/x /</span>ul <span class="regexp">/ur /</span>wl <span class="regexp">/dl %bname /</span>dr %yname %base %mine</div></pre></td></tr></table></figure>

<p><code>/s</code>限制WinMerge窗口为单个实例，避免出现多个窗口。</p>
<p><code>/e</code>允许使用<code>ESC</code>作为退出键。</p>
<p><code>/x</code>如果文件没有变动则关闭WinMerge窗口。</p>
<p><code>/ul</code>和<code>/ur</code>不把左右窗口的文件加入到Most Recently Used (MRU)列表。</p>
<p><code>/wl</code>左边窗口的文件设为只读，这样我们只可以修改右边的文件。</p>
<p><code>/dl</code>为左边的文件指定描述符。</p>
<p><code>/dr</code>为右边的文件指定描述符。</p>
<p><code>%base</code>为左边窗口打开的文件。</p>
<p><code>%mine</code>为右边窗口打开的文件。</p>
<h3 id="作为Merge工具">作为Merge工具</h3>
<p>在TortoiseGit的设置(Setting)对话框中选择Merge Tool:<br><img src="merge.png" alt=""></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:<span class="command">\Program</span> Files (x86)<span class="command">\WinMerge</span><span class="command">\WinMergeU</span>.exe <span class="comment">%theirs %mine %merged</span></div></pre></td></tr></table></figure>

<p>如果你已经把<code>C:\Program Files (x86)\WinMerge</code>加入到环境变量Path中了，你可以简写成：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WinMergeU <span class="variable">%theirs</span> <span class="variable">%mine</span> <span class="variable">%merged</span></div></pre></td></tr></table></figure>

<h3 id="参考资料">参考资料</h3>
<ol>
<li><a href="http://www.bricelam.net/2014/08/14/using-winmerge-with-tortoisegit.html" target="_blank" rel="external">http://www.bricelam.net/2014/08/14/using-winmerge-with-tortoisegit.html</a></li>
<li><a href="http://thoai-nguyen.blogspot.com/2012/03/setup-tortoise-git-and-winmerge.html" target="_blank" rel="external">http://thoai-nguyen.blogspot.com/2012/03/setup-tortoise-git-and-winmerge.html</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>我比较喜欢使用免费的<a href="http://winmerge.org/" target="_blank" rel="external">WinMerge</a>作为diff和merge工具，虽然TortoiseGit也自己带了TortoiseGitMerge工具，但是使用起来总觉得不是那么方便。</p>
<p>虽然WinMerge项目看起来没人维护了，最后一个发布打分版本在2013-02-02，但是这个工具使用起来还是相当方便的。我在重装机器的时候，或者更新Windows的时候，如果需要配置TortoiseGit,总是需要到网上查找如何配置WinMerge,因为长长的命令参数总是记不起来。所以在本文中记录下来。</p>
]]>
    
    </summary>
    
      <category term="工具" scheme="http://colobu.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[更新Maven POM文件中依赖库的版本]]></title>
    <link href="http://colobu.com/2016/05/04/check-latest-dependencies-in-pom-xml/"/>
    <id>http://colobu.com/2016/05/04/check-latest-dependencies-in-pom-xml/</id>
    <published>2016-05-04T02:35:51.000Z</published>
    <updated>2016-06-21T08:57:04.000Z</updated>
    <content type="html"><![CDATA[<p>维护一个Maven管理的Java项目的时候，有的时候需要更新项目依赖的第三方的库，比如将Spring 3.2.16升级成Spring 4.2.5。我们可以通过<a href="http://www.mojohaus.org/versions-maven-plugin/" target="_blank" rel="external">Maven versions插件</a>自动化的实现。</p>
<p>这个插件定义了非常多的goal:</p>
<ul>
<li>versions:compare-dependencies compares the dependency versions of the current project to the dependency management section of a remote project.</li>
<li>versions:display-dependency-updates scans a project&#39;s dependencies and produces a report of those dependencies which have newer versions available.</li>
<li>versions:display-plugin-updates scans a project&#39;s plugins and produces a report of those plugins which have newer versions available.</li>
<li>versions:display-property-updates scans a projectand produces a report of those properties which are used to control artifact versions and which properies have newer versions available.</li>
<li>versions:update-parent updates the parent section of a project so that it references the newest available version. For example, if you use a corporate root POM, this goal can be helpful if you need to ensure you are using the latest version of the corporate root POM.</li>
<li>versions:update-properties updates properties defined in a project so that they correspond to the latest available version of specific dependencies. This can be useful if a suite of dependencies must all be locked to one version.</li>
<li>versions:update-property Sets a property to the latest version in a given range of associated artifacts.</li>
<li>versions:update-child-modules updates the parent section of the child modules of a project so the version matches the version of the current project. For example, if you have an aggregator pom that is also the parent for the projects that it aggregates and the children and parent versions get out of sync, this mojo can help fix the versions of the child modules. (Note you may need to invoke Maven with the -N option in order to run this goal if your project is broken so badly that it cannot build because of the version mis-match).</li>
<li>versions:lock-snapshots searches the pom for all -SNAPSHOT versions and replaces them with the current timestamp version of that -SNAPSHOT, e.g. -20090327.172306-4</li>
<li>versions:unlock-snapshots searches the pom for all timestamp locked snapshot versions and replaces them with -SNAPSHOT.</li>
<li>versions:resolve-ranges finds dependencies using version ranges and resolves the range to the specific version being used.</li>
<li>versions:set can be used to set the project version from the command line.</li>
<li>versions:use-releases searches the pom for all -SNAPSHOT versions which have been released and replaces them with the corresponding release version.</li>
<li>versions:use-next-releases searches the pom for all non-SNAPSHOT versions which have been a newer release and replaces them with the next release version.</li>
<li>versions:use-latest-releases searches the pom for all non-SNAPSHOT versions which have been a newer release and replaces them with the latest release version.</li>
<li>versions:use-next-snapshots searches the pom for all non-SNAPSHOT versions which have been a newer -SNAPSHOT version and replaces them with the next -SNAPSHOT version.</li>
<li>versions:use-latest-snapshots searches the pom for all non-SNAPSHOT versions which have been a newer -SNAPSHOT version and replaces them with the latest -SNAPSHOT version.</li>
<li>versions:use-next-versions searches the pom for all versions which have been a newer version and replaces them with the next version.</li>
<li>versions:use-latest-versions searches the pom for all versions which have been a newer version and replaces them with the latest version.</li>
<li>versions:commit removes the pom.xml.versionsBackup files. Forms one half of the built-in &quot;Poor Man&#39;s SCM&quot;.</li>
<li>versions:revert restores the pom.xml files from the pom.xml.versionsBackup files. Forms one half of the built-in &quot;Poor Man&#39;s SCM&quot;. </li>
</ul>
<p>也提供了三个reporting goal：</p>
<ul>
<li>versions:dependency-updates-report produces a report of those project dependencies which have newer versions available.</li>
<li>versions:plugin-updates-report produces a report of those plugins which have newer versions available.</li>
<li>versions:property-updates-report produces a report of those properties which are used to control artifact versions and which properies have newer versions available.</li>
</ul>
<p>如果你的项目中artifact的版本都是通过属性定义的，那么<code>mvn versions:display-property-updates</code>可以在命令行中显示可以更新的依赖的信息。</p>
<p>你可以手工更改这些依赖的版本，也可以通过<code>mvn versions:update-properties</code>自动更新定义版本的属性。</p>
<p>上面的命令会为你原始的pom.xml产生一个备份文件，如果没有更新问题，你可以通过 <code>mvn versions:commit</code>移除这个备份文件。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>维护一个Maven管理的Java项目的时候，有的时候需要更新项目依赖的第三方的库，比如将Spring 3.2.16升级成Spring 4.2.5。我们可以通过<a href="http://www.mojohaus.org/versions-maven-plugin/" t]]>
    </summary>
    
      <category term="Java" scheme="http://colobu.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在Go web服务器中实现prefork和affinity]]></title>
    <link href="http://colobu.com/2016/05/03/use-prefork-and-affinity-in-Go/"/>
    <id>http://colobu.com/2016/05/03/use-prefork-and-affinity-in-Go/</id>
    <published>2016-05-03T08:14:38.000Z</published>
    <updated>2016-06-21T08:57:05.000Z</updated>
    <content type="html"><![CDATA[<p>Apache服务器可是使用prefork技术，启动多个独立的进程，每个进程独立的处理http请求，不需要担心线程安全的问题。</p>
<blockquote>
<p>This Multi-Processing Module (MPM) implements a non-threaded, pre-forking web server that handles requests in a manner similar to Apache 1.3. It is appropriate for sites that need to avoid threading for compatibility with non-thread-safe libraries. It is also the best MPM for isolating each request, so that a problem with a single request will not affect any other.</p>
</blockquote>
<p>尽管prefork在处理高并发的情况下并不高效，但是作为一个技术，倒是有启发我们的地方。我最近在调研Go服务器的性能看到一段代码，很优雅的实现了prefork和affinity的的功能，特地抄写在本文中，看看他是怎么实现的。</p>
<a id="more"></a>
<p>代码出处: <a href="https://github.com/nanoant/WebFrameworkBenchmark/blob/master/benchmarks/go-fasthttp/helloworldserver.go" target="_blank" rel="external">WebFrameworkBenchmark go-fasthttp</a>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"flag"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"io"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"net"</span></div><div class="line">	<span class="string">"os"</span></div><div class="line">	<span class="string">"os/exec"</span></div><div class="line">	<span class="string">"runtime"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/valyala/fasthttp"</span></div><div class="line">	<span class="string">"github.com/valyala/fasthttp/reuseport"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	addr     = flag.String(<span class="string">"addr"</span>, <span class="string">":8080"</span>, <span class="string">"TCP address to listen to"</span>)</div><div class="line">	prefork  = flag.Bool(<span class="string">"prefork"</span>, <span class="constant">false</span>, <span class="string">"use prefork"</span>)</div><div class="line">	affinity = flag.Bool(<span class="string">"affinity"</span>, <span class="constant">false</span>, <span class="string">"use affinity for prefork"</span>)</div><div class="line">	child    = flag.Bool(<span class="string">"child"</span>, <span class="constant">false</span>, <span class="string">"is child proc"</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	flag.Parse()</div><div class="line"></div><div class="line">	ln := getListener()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> err := fasthttp.Serve(ln, requestHandler); err != <span class="constant">nil</span> {</div><div class="line">		log.Fatalf(<span class="string">"Error in ListenAndServe: %s"</span>, err)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> requestHandler(ctx *fasthttp.RequestCtx) {</div><div class="line">	io.WriteString(ctx, <span class="string">"Hello World"</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> getListener() net.Listener {</div><div class="line">	<span class="keyword">if</span> !*prefork {</div><div class="line">		ln, err := net.Listen(<span class="string">"tcp4"</span>, *addr)</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			log.Fatal(err)</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> ln</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">if</span> !*child {</div><div class="line">		children := <span class="built_in">make</span>([]*exec.Cmd, runtime.NumCPU())</div><div class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> children {</div><div class="line">			<span class="keyword">if</span> !*affinity {</div><div class="line">				children[i] = exec.Command(os.Args<span class="number">[0</span>], <span class="string">"-prefork"</span>, <span class="string">"-child"</span>)</div><div class="line">			} <span class="keyword">else</span> {</div><div class="line">				children[i] = exec.Command(<span class="string">"taskset"</span>, <span class="string">"-c"</span>, fmt.Sprintf(<span class="string">"%d"</span>, i), os.Args<span class="number">[0</span>], <span class="string">"-prefork"</span>, <span class="string">"-child"</span>)</div><div class="line">			}</div><div class="line">			children[i].Stdout = os.Stdout</div><div class="line">			children[i].Stderr = os.Stderr</div><div class="line">			<span class="keyword">if</span> err := children[i].Start(); err != <span class="constant">nil</span> {</div><div class="line">				log.Fatal(err)</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">for</span> _, ch := <span class="keyword">range</span> children {</div><div class="line">			<span class="keyword">if</span> err := ch.Wait(); err != <span class="constant">nil</span> {</div><div class="line">				log.Print(err)</div><div class="line">			}</div><div class="line">		}</div><div class="line">		os.Exit<span class="number">(0</span>)</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"unreachable"</span>)</div><div class="line">	}</div><div class="line"></div><div class="line">	runtime.GOMAXPROCS<span class="number">(1</span>)</div><div class="line">	ln, err := reuseport.Listen(<span class="string">"tcp4"</span>, *addr)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Fatal(err)</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> ln</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个程序使用fast-http简单的实现了一个web服务器，简单的返回一个<code>hello world</code>。</p>
<p>如果程序启动的时候加上了<code>-prefork</code>参数，它会使用<code>exec.Command</code>启动多个子进程，子进程的数量和CPU的核数相同(第51行)。</p>
<p>如果程序启动的时候加上了<code>-prefork</code>参数和&quot;-affinity&quot;参数，它会将子进程绑定在其中的一个CPU核上，这样这个子进程只会被这个CPU执行。</p>
<p>子进程限定了使用的原生线程为1: <code>runtime.GOMAXPROCS(1)</code>。</p>
<p>因为程序使用了<code>reuseport</code>,所以不会导致多个IP地址和端口被占用的情况，多个子进程可以共用相同的IP地址+端口监听。</p>
<p>需要注意的事，<code>reuseport</code>并不是所有的操作系统都支持，比如目前windows就不支持，所以只可能在高版本的Linux中使用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Apache服务器可是使用prefork技术，启动多个独立的进程，每个进程独立的处理http请求，不需要担心线程安全的问题。</p>
<blockquote>
<p>This Multi-Processing Module (MPM) implements a non-threaded, pre-forking web server that handles requests in a manner similar to Apache 1.3. It is appropriate for sites that need to avoid threading for compatibility with non-thread-safe libraries. It is also the best MPM for isolating each request, so that a problem with a single request will not affect any other.</p>
</blockquote>
<p>尽管prefork在处理高并发的情况下并不高效，但是作为一个技术，倒是有启发我们的地方。我最近在调研Go服务器的性能看到一段代码，很优雅的实现了prefork和affinity的的功能，特地抄写在本文中，看看他是怎么实现的。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[巅峰对决 - 框架的性能比较]]></title>
    <link href="http://colobu.com/2016/04/25/performance-comparison-of-frameworks/"/>
    <id>http://colobu.com/2016/04/25/performance-comparison-of-frameworks/</id>
    <published>2016-04-25T07:10:38.000Z</published>
    <updated>2016-06-21T08:57:05.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>天下武功，无坚不摧，无快不破</p>
</blockquote>
<p>这句话也可以应用在软件开发上，&quot;无快不破&quot;强调的是软件的性能。我陆陆续续写了多篇各种框架的文章，也在github上开了多个性能比较的开源项目，本文做一个汇总，以备将来的查找。<br><a id="more"></a></p>
<ol>
<li><a href="http://colobu.com/2016/02/26/techempower-benchmarks-round12/" target="_blank" rel="external">最快的web服务器</a></li>
<li><a href="http://colobu.com/2016/02/23/1M-threads-microbenchmark/" target="_blank" rel="external">最快的并发框架</a></li>
<li><a href="http://colobu.com/2015/07/16/rpc-framework-performance-comparison/" target="_blank" rel="external">最快的RPC服务器</a></li>
<li><a href="http://colobu.com/2015/07/14/performance-comparison-of-7-websocket-frameworks/" target="_blank" rel="external">最快的websocket框架</a></li>
<li><a href="http://colobu.com/2015/11/17/Jax-RS-Performance-Comparison/" target="_blank" rel="external">最快的RESTful框架</a></li>
<li><a href="http://colobu.com/2016/03/16/why-is-go-gencode-so-fast/" target="_blank" rel="external">最快的Go序列化框架</a></li>
<li><a href="http://colobu.com/2016/04/06/the-fastest-golang-web-framework/" target="_blank" rel="external">最快的Go web框架</a></li>
<li><a href="http://colobu.com/2014/08/26/java-serializer-comparison/" target="_blank" rel="external">最快的Java序列化框架</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>天下武功，无坚不摧，无快不破</p>
</blockquote>
<p>这句话也可以应用在软件开发上，&quot;无快不破&quot;强调的是软件的性能。我陆陆续续写了多篇各种框架的文章，也在github上开了多个性能比较的开源项目，本文做一个汇总，以备将来的查找。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Scala native即将发布]]></title>
    <link href="http://colobu.com/2016/04/22/scala-native-is-coming/"/>
    <id>http://colobu.com/2016/04/22/scala-native-is-coming/</id>
    <published>2016-04-22T02:08:57.000Z</published>
    <updated>2016-06-21T08:57:05.000Z</updated>
    <content type="html"><![CDATA[<p>洛桑联邦理工学院(EPFL)发布了一个新的网站<a href="http://www.scala-native.org/" target="_blank" rel="external">http://www.scala-native.org/</a>，他们宣布了一个新的项目 Scala Native,但是没有公布具体的内容，只有&quot;coming soon&quot;的提示， 但是网站上唯一的提示 &quot;Your favourite language gets closer to bare metal.&quot; 隐约透漏它可能是可以使用Scala编程语言编译成本机代码的项目。</p>
<p>Scala除了纵向发展外(Scala本身语言的扩展)， 也在横向的发展， 比如Scala.js将Scala语言引入到Javascript中，它可以将Scala语言编译成javascript。因此有理由相信，这个即将发布的项目可以将Scala代码编译成本机代码，这样就可以脱离虚拟机直接运行了。</p>
<a id="more"></a>
<p>这个项目会在接下来的几个月发布，但是在即将举行的纽约 Scala Days会议上, Denys Shabalin会介绍一个主题 &quot;Scala Goes Native&quot;, 内容为:</p>
<blockquote>
<p>Scala has historically been a JVM-centric programming language. The situation has started to change with appearance of the Scala.js that opened a door of front-end development to Scala programmers. This talk will expand the horizons of Scala even more. We’re going to announce a new ahead-of-time compiler and lightweight managed runtime designed specifically for Scala.</p>
</blockquote>
<p>可以看到Scala native会提供一个编译器和一个轻量级的受管的运行时，看起来类似Golang，编译的程序会自带这个轻量级的运行时，负责垃圾回收。详细的内容在5月11号就可以知道了，估计到时Scala native网站也会进行更新。</p>
<p>如果这一切成真，这将会给Scala带来非同一般的功能，本地代码意味着我们不必依赖JVM,可以很容易地发布到docker中，更快更小，将会吸引更多的程序员的眼球。</p>
<p>但是，也有一些值得观察的因素， 如果脱离JVM,是否还能使用Java的丰富的类库，还是自己提供一个？编译的性能如何？JVM的垃圾回收器历经多年，进行了非常非常仔细的优化，如果Scala native自带运行时的化，能否做好垃圾回收功能？</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>洛桑联邦理工学院(EPFL)发布了一个新的网站<a href="http://www.scala-native.org/" target="_blank" rel="external">http://www.scala-native.org/</a>，他们宣布了一个新的项目 Scala Native,但是没有公布具体的内容，只有&quot;coming soon&quot;的提示， 但是网站上唯一的提示 &quot;Your favourite language gets closer to bare metal.&quot; 隐约透漏它可能是可以使用Scala编程语言编译成本机代码的项目。</p>
<p>Scala除了纵向发展外(Scala本身语言的扩展)， 也在横向的发展， 比如Scala.js将Scala语言引入到Javascript中，它可以将Scala语言编译成javascript。因此有理由相信，这个即将发布的项目可以将Scala代码编译成本机代码，这样就可以脱离虚拟机直接运行了。</p>
]]>
    
    </summary>
    
      <category term="Scala" scheme="http://colobu.com/categories/Scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用visual studio code开发Go程序]]></title>
    <link href="http://colobu.com/2016/04/21/use-vscode-to-develop-go-programs/"/>
    <id>http://colobu.com/2016/04/21/use-vscode-to-develop-go-programs/</id>
    <published>2016-04-21T01:25:34.000Z</published>
    <updated>2016-06-21T08:57:05.000Z</updated>
    <content type="html"><![CDATA[<p>在visual studio code 1.0发布之前我也曾多次尝试使用visual studio code开发Go程序，但是都放弃了，一是Go的插件还没发布或者不完善，而是vscode还不是那么方便，所以我一直使用atom + goplus + godebug编写Go的代码，而且用起来也非常的顺手方便。 现在vscode 1.0发布了，而且支持10种本地化语言，我尝试使用它编写Go程序，功能和性能都不错，所以目前atom和vscode都是我的菜。</p>
<p>本文简单介绍一下使用vscode开发Go的一些配置，速览vscode + Go 的功能。</p>
<a id="more"></a>
<h3 id="调整本地语言">调整本地语言</h3>
<p>vscode安装上后会根据你的操作系统的本地化设置来配置你的visual studio code采用的语言，所以很可能你安装上之后显示为简体中文。目前vscode 1.0支持下面<a href="https://code.visualstudio.com/docs/customization/locales" target="_blank" rel="external">10种语言</a>：</p>
<ul>
<li>English (US)     en-US</li>
<li>简体中文     zh-CN</li>
<li>繁体中文     zh-TW</li>
<li>法语     fr</li>
<li>德语     de</li>
<li>意大利语     it</li>
<li>日语     ja</li>
<li>韩语     ko</li>
<li>俄语     ru</li>
<li>西班牙语     es</li>
</ul>
<p>我还是习惯于英语环境，所以调整本地化语言为英语。如果想调整语言，使用 &quot;ctrl + shift + P&quot;打开命令面板，输入 &quot;Conf&quot; 就会显示出 “Configure Language”命令，点击这个命令就会新建或者打开locale.json文件，在这个文件中你就可以设置你的locale 语言了：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">{</div><div class="line">	"<span class="attribute">locale</span>":<span class="value"><span class="string">"en-US"</span></span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>我把它改成英文显示，重启vscode就显示英文了。</p>
<h3 id="安装Go插件">安装Go插件</h3>
<p>要开发Go程序，你需要安装Go的插件。 &quot;ctrl + shift + P&quot;打开命名面板，然后输入 &quot;ext install Go&quot;就会安装Go插件了，安装完后提示你重启vscode,就可以编写Go程序了。<br><img src="http://i.giphy.com/xTiTndDHV3GeIy6aNa.gif" alt=""></p>
<p>它支持以下功能：</p>
<ul>
<li>彩色高亮Colorization</li>
<li>自动完成列表 (using gocode)</li>
<li>方法和类的签名帮助信息 (using godoc)</li>
<li>代码片段</li>
<li>快速信息 (using godef)</li>
<li>查找定义 (using godef)</li>
<li>查找引用 (using guru)</li>
<li>文件大纲 (using go-outline)</li>
<li>工作区符号搜索 (using go-symbols)</li>
<li>重命名 (using gorename)</li>
<li>保存时编译 (using go build and go test)</li>
<li>格式化 (using goreturns or goimports or gofmt)</li>
<li>增加导入 (using gopkgs)</li>
<li>调试 [部分实现] (using delve)</li>
</ul>
<p>它的调试功能值得称赞，Go总算也有一个方便的调试功能呢，加上断点后可以断点所在的堆栈信息，变量以及监控自定义的表达式。(atom + godebug也可以实现这个功能，它也通过delve进行调试)</p>
<p>在vscode左边工具栏的第四个图标就可以打开调试窗口,点击某行可以方便的在代码中增加断点。<br><img src="vscode.png" alt=""></p>
<p>当然，在第一次编写Go代码的时候，可能需要安装所需的工具，如guru、go-symbols、goreturns等。如果设置好GOPATH环境变量，启动vscode,打开一个go代码文件，在右下角你会看到 &quot;Analysis Tools Missing&quot;的提示，点击它就会自动安装这些所需的工具。你也可以手工安装它们：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">go get -u -v github.com/nsf/gocode</div><div class="line">go get -u -v github.com/rogpeppe/godef</div><div class="line">go get -u -v github.com/golang/lint/golint</div><div class="line">go get -u -v github.com/lukehoban/go-outline</div><div class="line">go get -u -v sourcegraph.com/sqs/goreturns</div><div class="line">go get -u -v golang.org/x/tools/cmd/gorename</div><div class="line">go get -u -v github.com/tpng/gopkgs</div><div class="line">go get -u -v github.com/newhook/go-symbols</div><div class="line">go get -u -v golang.org/x/tools/cmd/guru</div></pre></td></tr></table></figure>

<h3 id="Go插件设置">Go插件设置</h3>
<p>vscode的Go插件有一些可以定制化的配置，你可以打开user preferences 或者 workspace settings来配置。如果想对所有的Go项目有效，就修改user preferences。</p>
<p>点击菜单 &quot;File -&gt; Preferences -&gt; User Settting&quot;打开窗口，左边的窗口是 vscode缺省配置，右边的窗口可以添加我们自己的设置。对于Go插件，可以添加如下的设置：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">{</div><div class="line">    "<span class="attribute">go.buildOnSave</span>": <span class="value"><span class="literal">true</span></span>,</div><div class="line">    "<span class="attribute">go.lintOnSave</span>": <span class="value"><span class="literal">true</span></span>,</div><div class="line">    "<span class="attribute">go.vetOnSave</span>": <span class="value"><span class="literal">true</span></span>,</div><div class="line">    "<span class="attribute">go.buildFlags</span>": <span class="value">[]</span>,</div><div class="line">    "<span class="attribute">go.lintFlags</span>": <span class="value">[]</span>,</div><div class="line">    "<span class="attribute">go.vetFlags</span>": <span class="value">[]</span>,</div><div class="line">    "<span class="attribute">go.coverOnSave</span>": <span class="value"><span class="literal">false</span></span>,</div><div class="line">    "<span class="attribute">go.useCodeSnippetsOnFunctionSuggest</span>": <span class="value"><span class="literal">false</span></span>,</div><div class="line">    "<span class="attribute">go.formatOnSave</span>": <span class="value"><span class="literal">true</span></span>,</div><div class="line">    "<span class="attribute">go.formatTool</span>": <span class="value"><span class="string">"goreturns"</span></span>,</div><div class="line">    "<span class="attribute">go.goroot</span>": <span class="value"><span class="string">"C:/Go"</span></span>,</div><div class="line">    "<span class="attribute">go.gopath</span>": <span class="value"><span class="string">"C:/gopath"</span></span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>它定制了Go插件的一些行为和变量。比如你可以改格式化工具为&quot;gofmt&quot;,如 &quot;go.formatTool&quot;: &quot;gofmt&quot;。</p>
<p>在写Go代码的时候，很多工具只有在编写的文件保存的时候才会执行，比如格式化，vet，lint、cover、test等，所以定时的保存文件可以触发这些动作,因此你可以在这个配置文件中加上下面的配置：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"files.autoSave"</span>: <span class="string">"afterDelay"</span></div></pre></td></tr></table></figure>

<p>它可以定时的保存文件。</p>
<h3 id="快捷键">快捷键</h3>
<p>你可以通过菜单 &quot;File -&gt; Preferences -&gt; Keyboard Shortcuts&quot;查看和定义快捷键。左边的窗口显示缺省的快捷键设置，但是不是很直观，建议看这个<a href="https://code.visualstudio.com/Docs/customization/keybindings" target="_blank" rel="external">链接</a>，它分门别类的介绍了每个快捷键的功能。</p>
<p>一般涉及到快捷键，我都会对其中的一个快捷键特别的关注，就是 &quot;ctrl + space&quot;，这个键一般用来设置触发提示的功能，但是和输入法切换的快捷键冲突，所以我会重新定义它。在刚才打开的右边窗口中增加定义：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">{</div><div class="line">    "<span class="attribute">key</span>": <span class="value"><span class="string">"ctrl+j"</span></span>,</div><div class="line">    "<span class="attribute">command</span>": <span class="value"><span class="string">"editor.action.triggerSuggest"</span></span>,</div><div class="line">    "<span class="attribute">when</span>": <span class="value"><span class="string">"editorTextFocus"</span></span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>同时我还增加了一个自己习惯的快捷键，就是格式化代码的快捷点，默认设置为 &quot;shift+alt+f&quot;,我新增加了一个快捷键：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">{</div><div class="line">       "<span class="attribute">key</span>": <span class="value"><span class="string">"ctrl+alt+f"</span></span>,</div><div class="line">       "<span class="attribute">command</span>": <span class="value"><span class="string">"editor.action.format"</span></span>,</div><div class="line">       "<span class="attribute">when</span>": <span class="value"><span class="string">"editorTextFocus"</span></span></div><div class="line">   }</div></pre></td></tr></table></figure>

<p>以及执行测试的快捷键</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">{</div><div class="line">    <span class="string">"key"</span>: <span class="string">"ctrl+alt+t"</span>,</div><div class="line">    <span class="string">"command"</span>: <span class="string">"go.test.cursor"</span>,</div><div class="line">    <span class="string">"when"</span>: <span class="string">"editorTextFocus"</span></div><div class="line">},</div><div class="line"></div><div class="line">{</div><div class="line">    <span class="string">"key"</span>: <span class="string">"ctrl+alt+p"</span>,</div><div class="line">    <span class="string">"command"</span>: <span class="string">"go.test.package"</span>,</div><div class="line">    <span class="string">"when"</span>: <span class="string">"editorTextFocus"</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>右边窗口的的右下角有对话框可以帮助你增加快捷键，当然你也可以想我这样一样手工添加。</p>
<h3 id="其它功能">其它功能</h3>
<p>Go插件和vscode工具配合的很好，比如调用格式化代码的快捷键就可以进行格式化，不必在保存的时候就可以执行。你也可以在命令面板中输入 &quot;!&quot;查看警告和错误信息。</p>
<p>类似Sublime text,命令面板非常的有用， &quot;ctrl + p&quot;打开它后输入 &quot;?&quot;可以查看它的不同的功能。<br><img src="command.png" alt=""></p>
<p>vscode的状态栏也非常的有用，插件信息、git信息，文档信息都会在这里显示。<br><img src="status.png" alt=""></p>
<p>你可以改变代码高亮的风格。&quot;ctrl + shift + P&quot;打开命令面板，输入 &quot;theme&quot;会显示 &quot;Preferences:Color Theme&quot;,点击它会显示可用的theme。 你还可以在<a href="https://marketplace.visualstudio.com/vscode" target="_blank" rel="external">visual studio marketplace</a>上你可以找到更多的theme，比如我使用的[Seti Modified]，和atom的保持一致。</p>
<p>相比atom,当然vscode还有不足的地方，比如打开多个文件，它们不会以tab的显示多窗口，你还需要&quot;ctrl + tab&quot;再选择其它的文件。没有安装Python但是还总提示Python插件需要升级等。但是也有比atom功能强大的地方，比如 &quot;ctrl&quot; +鼠标点击就可以查看方法的定义，性能可能比atom要好，尽管在我的机器上还没看出太大的性能区别。</p>
<p>本文只是粗略的展示了vscode和Go插件的功能，相信更强大的功能还有待在实践中发掘和学习。</p>
<p>另外，建议阅读github上的这篇文章<a href="https://github.com/Microsoft/vscode-tips-and-tricks/blob/master/README.md" target="_blank" rel="external">VS Code Tips and Tricks</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在visual studio code 1.0发布之前我也曾多次尝试使用visual studio code开发Go程序，但是都放弃了，一是Go的插件还没发布或者不完善，而是vscode还不是那么方便，所以我一直使用atom + goplus + godebug编写Go的代码，而且用起来也非常的顺手方便。 现在vscode 1.0发布了，而且支持10种本地化语言，我尝试使用它编写Go程序，功能和性能都不错，所以目前atom和vscode都是我的菜。</p>
<p>本文简单介绍一下使用vscode开发Go的一些配置，速览vscode + Go 的功能。</p>
]]>
    
    </summary>
    
      <category term="vscode" scheme="http://colobu.com/tags/vscode/"/>
    
      <category term="go" scheme="http://colobu.com/tags/go/"/>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
</feed>
