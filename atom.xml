<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[鸟窝]]></title>
  <subtitle><![CDATA[大道至简 Simplicity is the ultimate form of sophistication]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://colobu.com/"/>
  <updated>2016-07-26T06:07:06.629Z</updated>
  <id>http://colobu.com/</id>
  
  <author>
    <name><![CDATA[smallnest]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[理解RxJava的线程模型]]></title>
    <link href="http://colobu.com/2016/07/25/understanding-rxjava-thread-model/"/>
    <id>http://colobu.com/2016/07/25/understanding-rxjava-thread-model/</id>
    <published>2016-07-25T09:03:53.000Z</published>
    <updated>2016-07-26T06:00:26.000Z</updated>
    <content type="html"><![CDATA[<p>ReactiveX是Reactive Extensions的缩写，一般简写为Rx，最初是LINQ的一个扩展，由微软的架构师Erik Meijer领导的团队开发，在2012年11月开源，Rx是一个编程模型，目标是提供一致的编程接口，帮助开发者更方便的处理异步数据流，Rx库支持.NET、JavaScript和C++，Rx近几年越来越流行了，现在已经支持几乎全部的流行编程语言了，Rx的大部分语言库由ReactiveX这个组织负责维护，比较流行的有RxJava/RxJS/Rx.NET，社区网站是 <a href="http://reactivex.io" target="_blank" rel="external">reactivex.io</a>。</p>
<p>Netflix参考微软的Reactive Extensions创建了Java的实现RxJava，主要是为了简化服务器端的并发。2013年二月份,Ben Christensen 和 Jafar Husain发在Netflix技术博客的一篇文章第一次向世界展示了RxJava。</p>
<p>RxJava也在Android开发中得到广泛的应用。</p>
<blockquote>
<p>ReactiveX<br>An API for asynchronous programming with observable streams.<br>A combination of the best ideas from the Observer pattern, the Iterator pattern, and functional programming.</p>
</blockquote>
<p>虽然RxJava是为异步编程实现的库，但是如果不清楚它的使用，或者错误地使用了它的线程调度，反而不能很好的利用它的异步编程提到系统的处理速度。本文通过实例演示错误的RxJava的使用，解释RxJava的线程调度模型，主要介绍<code>Scheduler</code>、<code>observeOn</code>和<code>subscribeOn</code>的使用。</p>
<a id="more"></a>
<p>本文中的例子以并发发送http request请求为基础，通过性能检验RxJava的线程调度。</p>
<h3 id="第一个例子，性能超好？">第一个例子，性能超好？</h3>
<p>我们首先看第一个例子:</p>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testRxJavaWithoutBlocking</span>(<span class="keyword">int</span> count) <span class="keyword">throws</span> Exception {</div><div class="line"></div><div class="line">    CountDownLatch finishedLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="keyword">long</span> t = System.nanoTime();</div><div class="line">    Observable.range(<span class="number">0</span>, count).map(i -&gt; {</div><div class="line">        <span class="comment">//System.out.println("A:" + Thread.currentThread().getName());</span></div><div class="line">        <span class="keyword">return</span> <span class="number">200</span>;</div><div class="line">    }).subscribe(statusCode -&gt; {</div><div class="line">        <span class="comment">//System.out.println("B:" + Thread.currentThread().getName());</span></div><div class="line">    }, error -&gt; {</div><div class="line"></div><div class="line">    }, () -&gt; {</div><div class="line">        finishedLatch.countDown();</div><div class="line">    });</div><div class="line"></div><div class="line">    finishedLatch.await();</div><div class="line">    t = (System.nanoTime() - t) / <span class="number">1000000</span>; <span class="comment">//ms</span></div><div class="line"></div><div class="line">    System.out.println(<span class="string">"RxJavaWithoutBlocking TPS: "</span> + count * <span class="number">1000</span> / t);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个例子是一个基本的RxJava的使用，利用Range创建一个Observable, subscriber处理接收的数据。因为整个逻辑没有阻塞，程序运行起来很快，<br>输出结果为：</p>
<p>RxJavaWithoutBlocking TPS: <strong>7692307</strong> 。</p>
<h3 id="加上业务的模拟，性能超差">加上业务的模拟，性能超差</h3>
<p>上面的例子是一个理想化的程序，没雨任何阻塞。我们模拟一下实际的应用，加上业务处理。</p>
<p>业务逻辑是发送一个http的请求，httpserver是一个模拟器，针对每个请求有30毫秒的延迟。subscriber统计请求结果：</p>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testRxJavaWithBlocking</span>(<span class="keyword">int</span> count) <span class="keyword">throws</span> Exception {</div><div class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">"http://127.0.0.1:8999/"</span>);</div><div class="line">        CountDownLatch finishedLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line"></div><div class="line">        <span class="keyword">long</span> t = System.nanoTime();</div><div class="line">        Observable.range(<span class="number">0</span>, count).map(i -&gt; {</div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                HttpURLConnection conn = (HttpURLConnection) url.openConnection();</div><div class="line">                conn.setRequestMethod(<span class="string">"GET"</span>);</div><div class="line">                <span class="keyword">int</span> responseCode = conn.getResponseCode();</div><div class="line"></div><div class="line">                BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(conn.getInputStream()));</div><div class="line">                String inputLine;</div><div class="line">                <span class="keyword">while</span> ((inputLine = in.readLine()) != <span class="keyword">null</span>) {</div><div class="line">                    <span class="comment">//response.append(inputLine);</span></div><div class="line">                }</div><div class="line">                in.close();</div><div class="line"></div><div class="line"></div><div class="line">                <span class="keyword">return</span> responseCode;</div><div class="line">            } <span class="keyword">catch</span> (Exception ex) {</div><div class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">        }).subscribe(statusCode -&gt; {</div><div class="line">        }, error -&gt; {</div><div class="line"></div><div class="line">        }, () -&gt; {</div><div class="line">            finishedLatch.countDown();</div><div class="line">        });</div><div class="line"></div><div class="line">        finishedLatch.await();</div><div class="line">        t = (System.nanoTime() - t) / <span class="number">1000000</span>; <span class="comment">//ms</span></div><div class="line"></div><div class="line">        System.out.println(<span class="string">"RxJavaWithBlocking TPS: "</span> + count * <span class="number">1000</span> / t);</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p>RxJavaWithBlocking TPS: <strong>29</strong>。</p>
<p>@＃¥％％……&amp;！</p>
<p>性能怎么突降呢，第一个例子看起来性能超好啊，http server只增加了一个30毫秒的延迟，导致这个方法每秒只能处理29个请求。</p>
<p>如果我们估算一下， 29*30= 870 毫秒，大约1秒，正好和单个线程发送处理所有的请求的TPS差不多。<br>后面我们也会看到，实际的确是一个线程处理的，你可以在代码中加入</p>
<h3 id="加上调度器，不起作用？">加上调度器，不起作用？</h3>
<p>如果你对<code>subscribeOn</code>和<code>observeOn</code>方法有些印象的话，可能会尝试使用调度器去解决：</p>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testRxJavaWithBlocking</span>(<span class="keyword">int</span> count) <span class="keyword">throws</span> Exception {</div><div class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">"http://127.0.0.1:8999/"</span>);</div><div class="line">        CountDownLatch finishedLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line"></div><div class="line">        <span class="keyword">long</span> t = System.nanoTime();</div><div class="line">        Observable.range(<span class="number">0</span>, count).map(i -&gt; {</div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                HttpURLConnection conn = (HttpURLConnection) url.openConnection();</div><div class="line">                conn.setRequestMethod(<span class="string">"GET"</span>);</div><div class="line">                <span class="keyword">int</span> responseCode = conn.getResponseCode();</div><div class="line"></div><div class="line">                BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(conn.getInputStream()));</div><div class="line">                String inputLine;</div><div class="line">                <span class="keyword">while</span> ((inputLine = in.readLine()) != <span class="keyword">null</span>) {</div><div class="line">                    <span class="comment">//response.append(inputLine);</span></div><div class="line">                }</div><div class="line">                in.close();</div><div class="line"></div><div class="line"></div><div class="line">                <span class="keyword">return</span> responseCode;</div><div class="line">            } <span class="keyword">catch</span> (Exception ex) {</div><div class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">        }).subscribeOn(Schedulers.io()).observeOn(Schedulers.computation()).subscribe(statusCode -&gt; {</div><div class="line">        }, error -&gt; {</div><div class="line"></div><div class="line">        }, () -&gt; {</div><div class="line">            finishedLatch.countDown();</div><div class="line">        });</div><div class="line"></div><div class="line">        finishedLatch.await();</div><div class="line">        t = (System.nanoTime() - t) / <span class="number">1000000</span>; <span class="comment">//ms</span></div><div class="line"></div><div class="line">        System.out.println(<span class="string">"RxJavaWithBlocking TPS: "</span> + count * <span class="number">1000</span> / t);</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>加上<code>.subscribeOn(Schedulers.io()).observeOn(Schedulers.computation())</code>看一下性能：</p>
<p>RxJavaWithBlocking TPS: <strong>30</strong>。</p>
<p>性能没有改观，是时候了解一下RxJava线程调度的问题了。</p>
<h3 id="RxJava的线程模型">RxJava的线程模型</h3>
<p>首先，依照<a href="http://reactivex.io/documentation/contract.html" target="_blank" rel="external">Observable Contract</a>, <code>onNext</code>是顺序执行的，不会同时由多个线程并发执行。<br><img src="no_observeon.gif" alt="图片来自 http://tomstechnicalblog.blogspot.com/2016/02/rxjava-understanding-observeon-and.html"></p>
<p>默认情况下，它是在调用<code>subscribe</code>方法的那个线程中执行的。如第一个例子和第二个例子，Rx的操作和消息接收处理都是在同一个线程中执行的。一旦由阻塞，比如第二个例子，久会导致这个线程被阻塞，吞吐量下降。<br><img src="1.png" alt="图片来自 https://medium.com/@diolor/observe-in-the-correct-thread-1939bb9bb9d2"></p>
<p>但是<code>subscribeOn</code>可以改变Observable的运行线程。<br><img src="2.png" alt="图片来自 https://medium.com/@diolor/observe-in-the-correct-thread-1939bb9bb9d2"><br>上图中可以看到，如果你使用了<code>subscribeOn</code>方法，则Rx的运行将会切换到另外的线程上，而不是默认的调用线程。</p>
<p>需要注意的是，如果在Observable链中调用了多个<code>subscribeOn</code>方法，无论调用点在哪里，Observable链只会使用第一个<code>subscribeOn</code>指定的调度器，正所谓&quot;一见倾情&quot;。<br>但是<code>onNext</code>还是顺序执行的，所以第二个例子的性能依然低下。</p>
<p><code>observeOn</code>可以中途改变Observable链的线程。前面说了，<code>subscribeOn</code>方法改变的源Observable的整个的运行线程，要想中途切换线程，就需要<code>observeOn</code>方法。<br><img src="observeOn.gif" alt="图片来自 http://tomstechnicalblog.blogspot.com/2016/02/rxjava-understanding-observeon-and.html"></p>
<p>官方的一个简略晦涩的解释如下：</p>
<blockquote>
<p>The SubscribeOn operator changes this behavior by specifying a different Scheduler on which the Observable should operate. The ObserveOn operator specifies a different Scheduler that the Observable will use to send notifications to its observers.</p>
</blockquote>
<p>一图胜千言：<br><img src="schedulers.png" alt="图片来自 http://reactivex.io"></p>
<p>注意箭头的颜色和横轴的颜色，不同的颜色代表不同的线程。</p>
<h3 id="Schedulers">Schedulers</h3>
<p>上面我们了解了RxJava可以使用<code>subscribeOn</code>和<code>observeOn</code>可以改变和切换线程，以及<code>onNext</code>是顺序执行的，不是并发执行,至多也就切换到另外一个线程，如果它中间的操作是阻塞的，久会影响整个Rx的执行。</p>
<p>Rx是通过调度器来选择哪个线程执行的，RxJava内置了几种调度器，分别为不同的case提供线程：</p>
<ul>
<li><p><strong>io()</strong> : 这个调度器时用于I/O操作, 它可以增长或缩减来确定线程池的大小它是使用CachedThreadScheduler来实现的。需要注意的是，它的线程池是无限制的，如果你使用了大量的线程的话，可能会导致OutOfMemory等资源用尽的异常。</p>
</li>
<li><p><strong>computation()</strong> : 这个是计算工作默认的调度器，它与I/O操作无关。它也是许多RxJava方法的默认调度器：buffer(),debounce(),delay(),interval(),sample(),skip()。</p>
</li>
</ul>
<p>因为这些方法内部已经调用的调度器，所以你再调用<code>subscribeOn</code>是无效的，比如下面的例子总是使用<code>computation</code>调度器的线程。</p>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</div><div class="line">                .delay(<span class="number">1</span>, TimeUnit.SECONDS)</div><div class="line">                .subscribeOn(Schedulers.newThread())</div><div class="line">                .map(i -&gt; {</div><div class="line">                    System.out.println(<span class="string">"map: "</span> + Thread.currentThread().getName());</div><div class="line">                    <span class="keyword">return</span> i;</div><div class="line">                })</div><div class="line">                .subscribe(i -&gt; {});</div></pre></td></tr></table></figure>

<ul>
<li><strong>immediate()</strong> :这个调度器允许你立即在当前线程执行你指定的工作。它是timeout(),timeInterval(),以及timestamp()方法默认的调度器。</li>
<li><strong>newThread()</strong> :创建一个新的线程只从。</li>
<li><strong>trampoline()</strong> :为当前线程建立一个队列，将当前任务加入到队列中依次执行。</li>
</ul>
<p>同时，<code>Schedulers</code>还提供了<code>from</code>静态方法，用户可以定制线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ExecutorService es = Executors.newFixedThreadPool(<span class="number">200</span>, <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">"SubscribeOn-%d"</span>).build());</div><div class="line">Schedulers.from(es)</div></pre></td></tr></table></figure>

<h3 id="改造，异步执行">改造，异步执行</h3>
<p>现在，我们已经了解了RxJava的线程运行，以及相关的调度器。可以看到上面的例子还是顺序阻塞执行的，即使是切换到另外的线程上，依然是顺序阻塞执行，显示它的吞吐率非常非常的低。下一步我们就要改造这个例子，让它能异步的执行。</p>
<p>下面是一种改造方案，我先把代码贴出来，再解释：</p>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testRxJavaWithFlatMap</span>(<span class="keyword">int</span> count) <span class="keyword">throws</span> Exception {</div><div class="line">    ExecutorService es = Executors.newFixedThreadPool(<span class="number">200</span>, <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">"SubscribeOn-%d"</span>).build());</div><div class="line"></div><div class="line">    URL url = <span class="keyword">new</span> URL(<span class="string">"http://127.0.0.1:8999/"</span>);</div><div class="line">    CountDownLatch finishedLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="keyword">long</span> t = System.nanoTime();</div><div class="line">    Observable.range(<span class="number">0</span>, count).subscribeOn(Schedulers.io()).flatMap(i -&gt; {</div><div class="line">                <span class="comment">//System.out.println("A: " + Thread.currentThread().getName());</span></div><div class="line">                <span class="keyword">return</span> Observable.just(i).subscribeOn(Schedulers.from(es)).map(v -&gt; {</div><div class="line">                            <span class="comment">//System.out.println("B: " + Thread.currentThread().getName());</span></div><div class="line">                            <span class="keyword">try</span> {</div><div class="line">                                HttpURLConnection conn = (HttpURLConnection) url.openConnection();</div><div class="line">                                conn.setRequestMethod(<span class="string">"GET"</span>);</div><div class="line">                                <span class="keyword">int</span> responseCode = conn.getResponseCode();</div><div class="line"></div><div class="line">                                BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(conn.getInputStream()));</div><div class="line">                                String inputLine;</div><div class="line">                                <span class="keyword">while</span> ((inputLine = in.readLine()) != <span class="keyword">null</span>) {</div><div class="line">                                    <span class="comment">//response.append(inputLine);</span></div><div class="line">                                }</div><div class="line">                                in.close();</div><div class="line"></div><div class="line"></div><div class="line">                                <span class="keyword">return</span> responseCode;</div><div class="line">                            } <span class="keyword">catch</span> (Exception ex) {</div><div class="line">                                <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">                            }</div><div class="line">                        }</div><div class="line">                );</div><div class="line">            }</div><div class="line"></div><div class="line">    ).observeOn(Schedulers.computation()).subscribe(statusCode -&gt; {</div><div class="line">        <span class="comment">//System.out.println("C: " + Thread.currentThread().getName());</span></div><div class="line">    }, error -&gt; {</div><div class="line"></div><div class="line">    }, () -&gt; {</div><div class="line">        finishedLatch.countDown();</div><div class="line">    });</div><div class="line"></div><div class="line">    finishedLatch.await();</div><div class="line">    t = (System.nanoTime() - t) / <span class="number">1000000</span>; <span class="comment">//ms</span></div><div class="line"></div><div class="line">    System.out.println(<span class="string">"RxJavaWithFlatMap TPS: "</span> + count * <span class="number">1000</span> / t);</div><div class="line">    es.shutdownNow();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>通过<code>flatmap</code>可以将源Observable的元素项转成n个Observable,生成的每个Observable可以使用线程池并发的执行，同时flatmap还会将这n个Observable merge成一个Observable。你可以将其中的注释打开，看看线程的执行情况。</p>
<p>性能还不错：</p>
<p>RxJavaWithFlatMap TPS: <strong>3906</strong>。</p>
<blockquote>
<p><strong>FlatMap</strong> — transform the items emitted by an Observable into Observables, then flatten the emissions from those into a single Observable</p>
</blockquote>
<p><img src="flatMap.c.png" alt="图片来自 http://reactivex.io"></p>
<h3 id="另一种解决方案">另一种解决方案</h3>
<p>我们已经清楚了要并行执行提高吞吐率的解决办法就是创建多个Observable并且并发执行。基于这种解决方案，我们还可以有其它的解决方案。</p>
<p>上一方案中利用flatmap创建多个Observable,针对我们的例子，我们何不直接创建多个Observable呢？</p>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testRxJavaWithParallel</span>(<span class="keyword">int</span> count) <span class="keyword">throws</span> Exception {</div><div class="line">    ExecutorService es = Executors.newFixedThreadPool(<span class="number">200</span>, <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">"SubscribeOn-%d"</span>).build());</div><div class="line"></div><div class="line">    URL url = <span class="keyword">new</span> URL(<span class="string">"http://127.0.0.1:8999/"</span>);</div><div class="line">    CountDownLatch finishedLatch = <span class="keyword">new</span> CountDownLatch(count);</div><div class="line"></div><div class="line">    <span class="keyword">long</span> t = System.nanoTime();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; count; k++) {</div><div class="line">        Observable.just(k).map(i -&gt; {</div><div class="line">            <span class="comment">//System.out.println("A: " + Thread.currentThread().getName());</span></div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                HttpURLConnection conn = (HttpURLConnection) url.openConnection();</div><div class="line">                conn.setRequestMethod(<span class="string">"GET"</span>);</div><div class="line">                <span class="keyword">int</span> responseCode = conn.getResponseCode();</div><div class="line"></div><div class="line">                BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(conn.getInputStream()));</div><div class="line">                String inputLine;</div><div class="line">                <span class="keyword">while</span> ((inputLine = in.readLine()) != <span class="keyword">null</span>) {</div><div class="line">                    <span class="comment">//response.append(inputLine);</span></div><div class="line">                }</div><div class="line">                in.close();</div><div class="line"></div><div class="line"></div><div class="line">                <span class="keyword">return</span> responseCode;</div><div class="line">            } <span class="keyword">catch</span> (Exception ex) {</div><div class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">        }).subscribeOn(Schedulers.from(es)).observeOn(Schedulers.computation()).subscribe(statusCode -&gt; {</div><div class="line">        }, error -&gt; {</div><div class="line"></div><div class="line">        }, () -&gt; {</div><div class="line">            finishedLatch.countDown();</div><div class="line">        });</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    finishedLatch.await();</div><div class="line">    t = (System.nanoTime() - t) / <span class="number">1000000</span>; <span class="comment">//ms</span></div><div class="line"></div><div class="line">    System.out.println(<span class="string">"RxJavaWithParallel TPS: "</span> + count * <span class="number">1000</span> / t);</div><div class="line">    es.shutdownNow();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>性能更好一点：</p>
<p>RxJavaWithParallel2 TPS: <strong>4716</strong>。</p>
<p>这个例子没有使用<code>Schedulers.io()</code>作为它的调度器，这是因为如果在大并发的情况下，可能会出现创建过多的线程导致资源不错，所以我们限定使用200个线程。</p>
<h3 id="总结">总结</h3>
<ul>
<li><strong>subscribeOn()</strong> 改变的Observable运行(operate)使用的调度器，多次调用无效。</li>
<li><strong>observeOn()</strong> 改变Observable发送notifications的调度器，会影响后续的操作，可以多次调用</li>
<li>默认情况下， 操作链使用的线程是调用<code>subscribe()</code>的线程</li>
<li><code>Schedulers</code>提供了多个调度器，可以并行运行多个Observable</li>
<li>使用RxJava可以实现异步编程，但是依然要小心线程阻塞。而且由于这种异步的编程，调试代码可能更加的困难</li>
</ul>
<h3 id="参考文档">参考文档</h3>
<ol>
<li><a href="http://reactivex.io/documentation/contract.html" target="_blank" rel="external">http://reactivex.io/documentation/contract.html</a></li>
<li><a href="http://reactivex.io/documentation/operators/subscribeon.html" target="_blank" rel="external">http://reactivex.io/documentation/operators/subscribeon.html</a> <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/SubscribeOn.html" target="_blank" rel="external">中文翻译</a></li>
<li><a href="http://reactivex.io/documentation/operators/observeon.html" target="_blank" rel="external">http://reactivex.io/documentation/operators/observeon.html</a> <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/ObserveOn.html" target="_blank" rel="external">中文翻译</a></li>
<li><a href="http://reactivex.io/documentation/scheduler.html" target="_blank" rel="external">http://reactivex.io/documentation/scheduler.html</a></li>
<li><a href="http://tomstechnicalblog.blogspot.com/2016/02/rxjava-understanding-observeon-and.html" target="_blank" rel="external">http://tomstechnicalblog.blogspot.com/2016/02/rxjava-understanding-observeon-and.html</a></li>
<li><a href="http://tomstechnicalblog.blogspot.com/2015/11/rxjava-achieving-parallelization.html" target="_blank" rel="external">http://tomstechnicalblog.blogspot.com/2015/11/rxjava-achieving-parallelization.html</a></li>
<li><a href="https://medium.com/@diolor/observe-in-the-correct-thread-1939bb9bb9d2" target="_blank" rel="external">https://medium.com/@diolor/observe-in-the-correct-thread-1939bb9bb9d2</a> <a href="http://www.jianshu.com/p/72911b9ba2d7" target="_blank" rel="external">中文翻译</a></li>
<li><a href="https://github.com/mcxiaoke/RxDocs" target="_blank" rel="external">https://github.com/mcxiaoke/RxDocs</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>ReactiveX是Reactive Extensions的缩写，一般简写为Rx，最初是LINQ的一个扩展，由微软的架构师Erik Meijer领导的团队开发，在2012年11月开源，Rx是一个编程模型，目标是提供一致的编程接口，帮助开发者更方便的处理异步数据流，Rx库支持.NET、JavaScript和C++，Rx近几年越来越流行了，现在已经支持几乎全部的流行编程语言了，Rx的大部分语言库由ReactiveX这个组织负责维护，比较流行的有RxJava/RxJS/Rx.NET，社区网站是 <a href="http://reactivex.io" target="_blank" rel="external">reactivex.io</a>。</p>
<p>Netflix参考微软的Reactive Extensions创建了Java的实现RxJava，主要是为了简化服务器端的并发。2013年二月份,Ben Christensen 和 Jafar Husain发在Netflix技术博客的一篇文章第一次向世界展示了RxJava。</p>
<p>RxJava也在Android开发中得到广泛的应用。</p>
<blockquote>
<p>ReactiveX<br>An API for asynchronous programming with observable streams.<br>A combination of the best ideas from the Observer pattern, the Iterator pattern, and functional programming.</p>
</blockquote>
<p>虽然RxJava是为异步编程实现的库，但是如果不清楚它的使用，或者错误地使用了它的线程调度，反而不能很好的利用它的异步编程提到系统的处理速度。本文通过实例演示错误的RxJava的使用，解释RxJava的线程调度模型，主要介绍<code>Scheduler</code>、<code>observeOn</code>和<code>subscribeOn</code>的使用。</p>
]]>
    
    </summary>
    
      <category term="rxjava" scheme="http://colobu.com/tags/rxjava/"/>
    
      <category term="Java" scheme="http://colobu.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[高性能的消息框架 go-disruptor]]></title>
    <link href="http://colobu.com/2016/07/22/using-go-disruptor/"/>
    <id>http://colobu.com/2016/07/22/using-go-disruptor/</id>
    <published>2016-07-22T08:17:49.000Z</published>
    <updated>2016-07-22T09:42:14.000Z</updated>
    <content type="html"><![CDATA[<p>Java程序员都知道，<a href="https://lmax-exchange.github.io/disruptor/" target="_blank" rel="external">Disruptor</a>是一个高性能的线程间通信的框架，即在同一个JVM进程中的多线程间消息传递,由LMAX开发。</p>
<p>Disruptor性能是如此之高，LMAX利用它可以处理每秒6百万订单，用1微秒的延迟获得吞吐量为100K+。那么Go语言生态圈中有没有这样的库呢？</p>
<a id="more"></a>
<p><a href="https://github.com/smartystreets/go-disruptor" target="_blank" rel="external">go-disruptor</a>就是对Java Disruptor的移植,它也提供了与Java Disruptor类似的API设计，使用起来也算不上麻烦。</p>
<p>至于性能呢，下面就会介绍，这也是本文的重点。</p>
<p>因为Disruptor的高性能， 好多人对它都有所关注， 有一系列的文章介绍Disruptor，比如下列的文章和资源：</p>
<ul>
<li><a href="http://groups.google.com/group/lmax-disruptor" target="_blank" rel="external">Disruptor Google Group</a></li>
<li><a href="http://bad-concurrency.blogspot.com/" target="_blank" rel="external">Bad Concurrency</a> (Michael Barker)</li>
<li><a href="http://blogs.lmax.com/" target="_blank" rel="external">LMAX</a> (Planet)</li>
<li><a href="http://www.lmax.com/" target="_blank" rel="external">LMAX Exchange</a></li>
<li><a href="http://www.infoq.com/presentations/LMAX" target="_blank" rel="external">Disruptor presentation @ QCon SF</a></li>
<li><a href="http://disruptor.googlecode.com/files/Disruptor-1.0.pdf" target="_blank" rel="external">Disruptor Technical Paper</a></li>
<li><a href="http://mechanical-sympathy.blogspot.com/" target="_blank" rel="external">Mechanical Sympathy</a> (Martin Thompson)</li>
<li><a href="http://martinfowler.com/articles/lmax.html" target="_blank" rel="external">Martin Fowler&#39;s Technical Review</a></li>
<li><a href="https://github.com/odeheurles/Disruptor-net" target="_blank" rel="external">.NET Disruptor Port</a></li>
<li><a href="http://www.slideshare.net/trishagee/introduction-to-the-disruptor?from=new_upload_email" target="_blank" rel="external">Introduction to the Disruptor</a></li>
<li><a href="Introduction to the Disruptor">Disruptor wiki</a></li>
</ul>
<p>也有一些中文的翻译和介绍，比如 <a href="http://ifeve.com/disruptor/" target="_blank" rel="external">并发编程网的Disrutpor专题</a>。<br><a href="http://www.infoq.com/cn/interviews/interview-with-fengzhongyan-talk-disruptor" target="_blank" rel="external">阿里巴巴封仲淹：如何优雅地使用Disruptor</a>。</p>
<p>Disruptor由LMAX开发，LMAX目标是要称为世界上最快的交易平台，为了取得低延迟和高吞吐率的目标，它们不得不开发一套高性能的生产者－消费者的消息框架。Java自己的Queue的性能还是有所延迟的，下图就是Disruptor和JDK ArrayBlockingQueue的性能比较。</p>
<p><img src="latency-histogram.png" alt="图片来自于Disruptor官网"></p>
<p>X轴显示的是延迟时间，Y轴是操作次数。可以看到Disruptor的延迟小，吞吐率高。</p>
<p>Disruptor有多种使用模型和配置，官方的一些模型的测试结果的链接在<a href="https://github.com/LMAX-Exchange/disruptor/wiki/Performance-Results" target="_blank" rel="external">这里</a>。</p>
<p>我想做的其实就是go-disruptor和官方的Java Disruptor的性能比较。因为Disruptor有多种配置方式，单生产者和多生产者，单消费者和多消费者，配置的不同性能差别还是蛮大的，所以公平地讲，两者的比较应该使用相同的配置，尽管它们是由不同的编程语言开发的。</p>
<p>我选取的一个测试方案是：3个生产者和一个消费者，如果使用一个生产者Java Disruptor的性能会成倍的提升。</p>
<h3 id="Java_Disruptor">Java Disruptor</h3>
<p>Java的测试主类如下：</p>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM_PUBLISHERS = <span class="number">3</span>;<span class="comment">//Runtime.getRuntime().availableProcessors();</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1024</span> * <span class="number">64</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ITERATIONS = <span class="number">1000</span>L * <span class="number">1000</span>L * <span class="number">20</span>L;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executor = Executors.newFixedThreadPool(NUM_PUBLISHERS + <span class="number">1</span>, DaemonThreadFactory.INSTANCE);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(NUM_PUBLISHERS + <span class="number">1</span>);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RingBuffer&lt;ValueEvent&gt; ringBuffer = createMultiProducer(ValueEvent.EVENT_FACTORY, BUFFER_SIZE, <span class="keyword">new</span> BusySpinWaitStrategy());</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SequenceBarrier sequenceBarrier = ringBuffer.newBarrier();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ValueAdditionEventHandler handler = <span class="keyword">new</span> ValueAdditionEventHandler();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BatchEventProcessor&lt;ValueEvent&gt; batchEventProcessor = <span class="keyword">new</span> BatchEventProcessor&lt;&gt;(ringBuffer, sequenceBarrier, handler);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ValueBatchPublisher[] valuePublishers = <span class="keyword">new</span> ValueBatchPublisher[NUM_PUBLISHERS];</div><div class="line"></div><div class="line">    {</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_PUBLISHERS; i++)</div><div class="line">        {</div><div class="line">            valuePublishers[i] = <span class="keyword">new</span> ValueBatchPublisher(cyclicBarrier, ringBuffer, ITERATIONS / NUM_PUBLISHERS, <span class="number">16</span>);</div><div class="line">        }</div><div class="line"></div><div class="line">        ringBuffer.addGatingSequences(batchEventProcessor.getSequence());</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">long</span> <span class="title">runDisruptorPass</span>() <span class="keyword">throws</span> Exception</div><div class="line">    {</div><div class="line">        <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line">        handler.reset(latch, batchEventProcessor.getSequence().get() + ((ITERATIONS / NUM_PUBLISHERS) * NUM_PUBLISHERS));</div><div class="line"></div><div class="line">        Future&lt;?&gt;[] futures = <span class="keyword">new</span> Future[NUM_PUBLISHERS];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_PUBLISHERS; i++)</div><div class="line">        {</div><div class="line">            futures[i] = executor.submit(valuePublishers[i]);</div><div class="line">        }</div><div class="line">        executor.submit(batchEventProcessor);</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        cyclicBarrier.await(); <span class="comment">//start test</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_PUBLISHERS; i++)</div><div class="line">        {</div><div class="line">            futures[i].get();</div><div class="line">        } <span class="comment">//all published</span></div><div class="line"></div><div class="line">        latch.await(); <span class="comment">//all handled</span></div><div class="line"></div><div class="line">        <span class="keyword">long</span> opsPerSecond = (ITERATIONS * <span class="number">1000</span>L) / (System.currentTimeMillis() - start);</div><div class="line">        batchEventProcessor.halt();</div><div class="line"></div><div class="line">        <span class="keyword">return</span> opsPerSecond;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> Exception</div><div class="line">    {</div><div class="line">        Main m = <span class="keyword">new</span> Main();</div><div class="line">        System.out.println(<span class="string">"opsPerSecond:"</span> + m.runDisruptorPass());</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>生产者和消费者类如下：</p>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueAdditionEventHandler</span> <span class="keyword">implements</span> <span class="title">EventHandler</span>&lt;<span class="title">ValueEvent</span>&gt;</span></div><div class="line">{</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> value = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> count;</div><div class="line">    <span class="keyword">private</span> CountDownLatch latch;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getValue</span>()</div><div class="line">    {</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span>(<span class="keyword">final</span> CountDownLatch latch, <span class="keyword">final</span> <span class="keyword">long</span> expectedCount)</div><div class="line">    {</div><div class="line">        value = <span class="number">0</span>;</div><div class="line">        <span class="keyword">this</span>.latch = latch;</div><div class="line">        count = expectedCount;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span>(<span class="keyword">final</span> ValueEvent event, <span class="keyword">final</span> <span class="keyword">long</span> sequence, <span class="keyword">final</span> <span class="keyword">boolean</span> endOfBatch) <span class="keyword">throws</span> Exception</div><div class="line">    {</div><div class="line">        value = event.getValue();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (count == sequence)</div><div class="line">        {</div><div class="line">            latch.countDown();</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueBatchPublisher</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></div><div class="line">{</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier cyclicBarrier;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RingBuffer&lt;ValueEvent&gt; ringBuffer;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> iterations;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> batchSize;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="title">ValueBatchPublisher</span>(</div><div class="line">            <span class="keyword">final</span> CyclicBarrier cyclicBarrier,</div><div class="line">            <span class="keyword">final</span> RingBuffer&lt;ValueEvent&gt; ringBuffer,</div><div class="line">            <span class="keyword">final</span> <span class="keyword">long</span> iterations,</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> batchSize)</div><div class="line">    {</div><div class="line">        <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</div><div class="line">        <span class="keyword">this</span>.ringBuffer = ringBuffer;</div><div class="line">        <span class="keyword">this</span>.iterations = iterations;</div><div class="line">        <span class="keyword">this</span>.batchSize = batchSize;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>()</div><div class="line">    {</div><div class="line">        <span class="keyword">try</span></div><div class="line">        {</div><div class="line">            cyclicBarrier.await();</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; iterations; i += batchSize)</div><div class="line">            {</div><div class="line">                <span class="keyword">long</span> hi = ringBuffer.next(batchSize);</div><div class="line">                <span class="keyword">long</span> lo = hi - (batchSize - <span class="number">1</span>);</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">long</span> l = lo; l &lt;= hi; l++)</div><div class="line">                {</div><div class="line">                    ValueEvent event = ringBuffer.get(l);</div><div class="line">                    event.setValue(l);</div><div class="line">                }</div><div class="line">                ringBuffer.publish(lo, hi);</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">catch</span> (Exception ex)</div><div class="line">        {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueEvent</span></span></div><div class="line">{</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> value;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getValue</span>()</div><div class="line">    {</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span>(<span class="keyword">final</span> <span class="keyword">long</span> value)</div><div class="line">    {</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> EventFactory&lt;ValueEvent&gt; EVENT_FACTORY = <span class="keyword">new</span> EventFactory&lt;ValueEvent&gt;()</div><div class="line">    {</div><div class="line">        <span class="keyword">public</span> ValueEvent <span class="title">newInstance</span>()</div><div class="line">        {</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ValueEvent();</div><div class="line">        }</div><div class="line">    };</div><div class="line">}</div></pre></td></tr></table></figure>

<p>生产者使用三个线程去写数据，一个消费者进行处理。生产者运行在三个线程中，批处理写入，每次写16个数据。</p>
<p>实际测试每秒能达到 <strong>183486238</strong> 的吞吐率， 也就是1.8亿的吞吐率。</p>
<h3 id="go-disruptor">go-disruptor</h3>
<p>下面看看go-disruptor的性能能达到多少。</p>
<p>我们知道，Go语言内置的goroutine之间的消息传递是通过channel实现的，go-disruptor官方网站上比较了go-disruptor和channel的性能，明显go-disruptor要比channel要好：</p>
<table>
<thead>
<tr>
<th>cenario</th>
<th>Per Operation Time</th>
</tr>
</thead>
<tbody>
<tr>
<td>Channels: Buffered, Blocking, GOMAXPROCS=1</td>
<td>58.6 ns</td>
</tr>
<tr>
<td>Channels: Buffered, Blocking, GOMAXPROCS=2</td>
<td>86.6 ns</td>
</tr>
<tr>
<td>Channels: Buffered, Blocking, GOMAXPROCS=3, Contended Write</td>
<td>194 ns</td>
</tr>
<tr>
<td>Channels: Buffered, Non-blocking, GOMAXPROCS=1</td>
<td>26.4 ns</td>
</tr>
<tr>
<td>Channels: Buffered, Non-blocking, GOMAXPROCS=2</td>
<td>29.2 ns</td>
</tr>
<tr>
<td>Channels: Buffered, Non-blocking, GOMAXPROCS=3, Contended Write</td>
<td>110 ns</td>
</tr>
<tr>
<td>Disruptor: Writer, Reserve One</td>
<td>4.3 ns</td>
</tr>
<tr>
<td>Disruptor: Writer, Reserve Many</td>
<td>1.0 ns</td>
</tr>
<tr>
<td>Disruptor: Writer, Reserve One, Multiple Readers</td>
<td>4.5 ns</td>
</tr>
<tr>
<td>Disruptor: Writer, Reserve Many, Multiple Readers</td>
<td>0.9 ns</td>
</tr>
<tr>
<td>Disruptor: Writer, Await One</td>
<td>3.0 ns</td>
</tr>
<tr>
<td>Disruptor: Writer, Await Many</td>
<td>0.7 ns</td>
</tr>
<tr>
<td>Disruptor: SharedWriter, Reserve One</td>
<td>13.6 ns</td>
</tr>
<tr>
<td>Disruptor: SharedWriter, Reserve Many</td>
<td>2.5 ns</td>
</tr>
<tr>
<td>Disruptor: SharedWriter, Reserve One, Contended Write</td>
<td>56.9 ns</td>
</tr>
<tr>
<td>Disruptor: SharedWriter, Reserve Many, Contended Write</td>
<td>3.1 ns</td>
</tr>
</tbody>
</table>
<p>在与Java Disruptor相同的测试条件下go-disruptor的性能呢？</p>
<p>下面是测试代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"runtime"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line"></div><div class="line">	disruptor <span class="string">"github.com/smartystreets/go-disruptor"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">	RingBufferSize   =<span class="number"> 1024</span> *<span class="number"> 64</span></div><div class="line">	RingBufferMask   = RingBufferSize -<span class="number"> 1</span></div><div class="line">	ReserveOne       =<span class="number"> 1</span></div><div class="line">	ReserveMany      =<span class="number"> 16</span></div><div class="line">	ReserveManyDelta = ReserveMany -<span class="number"> 1</span></div><div class="line">	DisruptorCleanup = time.Millisecond *<span class="number"> 10</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> ringBuffer = [RingBufferSize]<span class="typename">int64</span>{}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	NumPublishers :=<span class="number"> 3</span> <span class="comment">//runtime.NumCPU()</span></div><div class="line">	totalIterations := <span class="typename">int64</span><span class="number">(1000</span> *<span class="number"> 1000</span> *<span class="number"> 20</span>)</div><div class="line">	iterations := totalIterations / <span class="typename">int64</span>(NumPublishers)</div><div class="line">	totalIterations = iterations * <span class="typename">int64</span>(NumPublishers)</div><div class="line"></div><div class="line">	fmt.Printf(<span class="string">"Total: %d,  Iterations: %d, Publisher: %d, Consumer: 1\n"</span>, totalIterations, iterations, NumPublishers)</div><div class="line"></div><div class="line">	runtime.GOMAXPROCS(NumPublishers)</div><div class="line">	<span class="keyword">var</span> consumer = &countConsumer{TotalIterations: totalIterations, Count:<span class="number"> 0</span>}</div><div class="line">	consumer.WG.Add<span class="number">(1</span>)</div><div class="line"></div><div class="line">	controller := disruptor.Configure(RingBufferSize).WithConsumerGroup(consumer).BuildShared()</div><div class="line">	controller.Start()</div><div class="line">	<span class="keyword">defer</span> controller.Stop()</div><div class="line"></div><div class="line">	<span class="keyword">var</span> wg sync.WaitGroup</div><div class="line">	wg.Add(NumPublishers +<span class="number"> 1</span>)</div><div class="line"></div><div class="line">	<span class="keyword">var</span> sendWG sync.WaitGroup</div><div class="line">	sendWG.Add(NumPublishers)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; NumPublishers; i++ {</div><div class="line">		<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">			writer := controller.Writer()</div><div class="line">			wg.Done()</div><div class="line">			wg.Wait()</div><div class="line">			current := disruptor.InitialSequenceValue</div><div class="line">			<span class="keyword">for</span> current &lt; totalIterations {</div><div class="line">				current = writer.Reserve(ReserveMany)</div><div class="line"></div><div class="line">				<span class="keyword">for</span> j := current - ReserveMany; j &lt;= current; j++ {</div><div class="line">					ringBuffer[j&RingBufferMask] = j</div><div class="line">				}</div><div class="line">				writer.Commit(current-ReserveMany, current)</div><div class="line">			}</div><div class="line"></div><div class="line">			sendWG.Done()</div><div class="line">		}()</div><div class="line">	}</div><div class="line"></div><div class="line">	wg.Done()</div><div class="line">	t := time.Now().UnixNano()</div><div class="line">	wg.Wait() <span class="comment">//waiting for ready as a barrier</span></div><div class="line">	fmt.Println(<span class="string">"start to publish"</span>)</div><div class="line"></div><div class="line">	sendWG.Wait()</div><div class="line">	fmt.Println(<span class="string">"Finished to publish"</span>)</div><div class="line"></div><div class="line">	consumer.WG.Wait()</div><div class="line">	fmt.Println(<span class="string">"Finished to consume"</span>) <span class="comment">//waiting for consumer</span></div><div class="line"></div><div class="line">	t = (time.Now().UnixNano() - t) /<span class="number"> 1000000</span> <span class="comment">//ms</span></div><div class="line"></div><div class="line">	fmt.Printf(<span class="string">"opsPerSecond: %d\n"</span>, totalIterations<span class="number">*1000</span>/t)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> countConsumer <span class="keyword">struct</span> {</div><div class="line">	Count           <span class="typename">int64</span></div><div class="line">	TotalIterations <span class="typename">int64</span></div><div class="line">	WG              sync.WaitGroup</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (cc *countConsumer) Consume(lower, upper <span class="typename">int64</span>) {</div><div class="line">	<span class="keyword">for</span> lower &lt;= upper {</div><div class="line">		message := ringBuffer[lower&RingBufferMask]</div><div class="line">		<span class="keyword">if</span> message != lower {</div><div class="line">			warning := fmt.Sprintf(<span class="string">"\nRace condition--Sequence: %d, Message: %d\n"</span>, lower, message)</div><div class="line">			fmt.Printf(warning)</div><div class="line">			<span class="built_in">panic</span>(warning)</div><div class="line">		}</div><div class="line">		lower++</div><div class="line">		cc.Count++</div><div class="line">		<span class="comment">//fmt.Printf("count: %d, message: %d\n", cc.Count-1, message)</span></div><div class="line">		<span class="keyword">if</span> cc.Count == cc.TotalIterations {</div><div class="line">			cc.WG.Done()</div><div class="line">			<span class="keyword">return</span></div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>实际测试go-disruptor的每秒的吞吐率达到<strong>137931020</strong>。</p>
<p>好了，至少我们在相同的测试case情况下得到了两组数据,另外我还做了相同case情况的go channel的测试，所以一共三组数据：</p>
<ul>
<li>Java Disruptor : 183486238 ops/s</li>
<li>go-disruptor   : 137931020 ops/s</li>
<li>go channel     :   6995452 ops/s</li>
</ul>
<p>可以看到go-disruptor的性能要略微低于Java Disruptor,但是也已经足够高了，达到1.4亿/秒，所以它还是值的我们关注的。go channel的性能远远不如前两者。</p>
<h3 id="Go_Channel">Go Channel</h3>
<p>如果通过Go Channel实现，每秒的吞吐率为 6995452。</p>
<p>代码如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	NumPublishers :=<span class="number"> 3</span> <span class="comment">//runtime.NumCPU()</span></div><div class="line">	totalIterations := <span class="typename">int64</span><span class="number">(1000</span> *<span class="number"> 1000</span> *<span class="number"> 20</span>)</div><div class="line">	iterations := totalIterations / <span class="typename">int64</span>(NumPublishers)</div><div class="line">	totalIterations = iterations * <span class="typename">int64</span>(NumPublishers)</div><div class="line">	channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">int64</span>,<span class="number"> 1024</span><span class="number">*64</span>)</div><div class="line"></div><div class="line">	<span class="keyword">var</span> wg sync.WaitGroup</div><div class="line">	wg.Add(NumPublishers +<span class="number"> 1</span>)</div><div class="line"></div><div class="line">	<span class="keyword">var</span> readerWG sync.WaitGroup</div><div class="line">	readerWG.Add<span class="number">(1</span>)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; NumPublishers; i++ {</div><div class="line">		<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">			wg.Done()</div><div class="line">			wg.Wait()</div><div class="line">			<span class="keyword">for</span> i := <span class="typename">int64</span><span class="number">(0</span>); i &lt; iterations; {</div><div class="line">				<span class="keyword">select</span> {</div><div class="line">				<span class="keyword">case</span> channel &lt;- i:</div><div class="line">					i++</div><div class="line">				<span class="keyword">default</span>:</div><div class="line">					<span class="keyword">continue</span></div><div class="line">				}</div><div class="line">			}</div><div class="line">		}()</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">for</span> i := <span class="typename">int64</span><span class="number">(0</span>); i &lt; totalIterations; i++ {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> msg := &lt;-channel:</div><div class="line">				<span class="keyword">if</span> NumPublishers ==<span class="number"> 1</span> && msg != i {</div><div class="line">					<span class="comment">//panic("Out of sequence")</span></div><div class="line">				}</div><div class="line">			<span class="keyword">default</span>:</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			}</div><div class="line">		}</div><div class="line"></div><div class="line">		readerWG.Done()</div><div class="line">	}()</div><div class="line"></div><div class="line">	wg.Done()</div><div class="line">	t := time.Now().UnixNano()</div><div class="line">	wg.Wait()</div><div class="line"></div><div class="line">	readerWG.Wait()</div><div class="line">	t = (time.Now().UnixNano() - t) /<span class="number"> 1000000</span> <span class="comment">//ms</span></div><div class="line"></div><div class="line">	fmt.Printf(<span class="string">"opsPerSecond: %d\n"</span>, totalIterations<span class="number">*1000</span>/t)</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>Java程序员都知道，<a href="https://lmax-exchange.github.io/disruptor/" target="_blank" rel="external">Disruptor</a>是一个高性能的线程间通信的框架，即在同一个JVM进程中的多线程间消息传递,由LMAX开发。</p>
<p>Disruptor性能是如此之高，LMAX利用它可以处理每秒6百万订单，用1微秒的延迟获得吞吐量为100K+。那么Go语言生态圈中有没有这样的库呢？</p>
]]>
    
    </summary>
    
      <category term="disruptor" scheme="http://colobu.com/tags/disruptor/"/>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java中的纤程库 - Quasar]]></title>
    <link href="http://colobu.com/2016/07/14/Java-Fiber-Quasar/"/>
    <id>http://colobu.com/2016/07/14/Java-Fiber-Quasar/</id>
    <published>2016-07-14T08:18:47.000Z</published>
    <updated>2016-07-20T02:39:14.000Z</updated>
    <content type="html"><![CDATA[<p>最近遇到的一个问题大概是微服务架构中经常会遇到的一个问题：</p>
<p>服务 <strong>A</strong> 是我们开发的系统，它的业务需要调用 <strong>B</strong>、<strong>C</strong>、<strong>D</strong> 等多个服务，这些服务是通过http的访问提供的。 问题是 <strong>B</strong>、<strong>C</strong>、<strong>D</strong> 这些服务都是第三方提供的，不能保证它们的响应时间，快的话十几毫秒，慢的话甚至1秒多，所以这些服务的Latency比较长。幸运地是这些服务都是集群部署的，容错率和并发支持都比较高，所以不担心它们的并发性能，唯一不爽的就是就是它们的Latency太高了。</p>
<p><img src="/2016/07/14/Java-Fiber-Quasar/system.png" alt="简化的微服务架构"></p>
<p>系统A会从Client接收Request, 每个Request的处理都需要多次调用B、C、D的服务，所以完成一个Request可能需要1到2秒的时间。为了让A能更好地支持并发数，系统中使用线程池处理这些Request。当然这是一个非常简化的模型，实际的业务处理比较复杂。</p>
<p>可以预见，因为系统B、C、D的延迟，导致整个业务处理都很慢，即使使用线程池，但是每个线程还是会阻塞在B、C、D的调用上，导致I/O阻塞了这些线程， CPU利用率相对来说不是那么高。</p>
<p>当然在测试的时候使用的是B、C、D的模拟器，没有预想到它们的响应是那么慢，因此测试数据的结果还不错，吞吐率还可以，但是在实际环境中问题就暴露出来了。</p>
<a id="more"></a>
<h3 id="概述">概述</h3>
<p>最开始线程池设置的是200,然后用HttpUrlConnection作为http client发送请求到B、C、D。当然HttpUrlConnection也有一些坑，比如<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/net/http-keepalive.html" target="_blank" rel="external">Persistent Connections</a>、<a href="http://techblog.bozho.net/caveats-of-httpurlconnection/" target="_blank" rel="external">Caveats of HttpURLConnection</a>,跳出坑后性能依然不行。</p>
<p>通过测试，如果B、C、D等服务延迟接近0毫秒，则HttpUrlConnection的吞吐率(线程池的大小为200)能到40000 requests/秒,但是随着第三方服务的响应时间变慢，它的吞吐率急剧下降，B、C、D的服务的延迟为100毫秒的时候，则HttpUrlConnection的吞吐率降到1800 requests/秒，而B、C、D的服务的延迟为100毫秒的时候HttpUrlConnection的吞吐率降到550 requests／秒。</p>
<p>增加<code>http.maxConnections</code>系统属性并不能显著增加吞吐率。</p>
<p>如果增加调用HttpUrlConnection的线程池的大小，比如增加到2000，性能会好一些，但是B、C、D的服务的延迟为500毫秒的时候，吞吐率为3800 requests/秒，延迟为1秒的时候，吞吐率为1900 requests/秒。</p>
<p>虽然线程池的增大能带来性能的提升，但是线程池也不能无限制的增大，因为每个线程都会占用一定的资源，而且随着线程的增多，线程之间的切换也更加的频繁，对CPU等资源也是一种浪费。</p>
<p>切换成netty(channel pool)，与B、C、D通讯的性能还不错， latency为500ms的时候吞吐率能达到10000 requests/秒，通讯不成问题，问题是需要将业务代码改成异步的方式，异步地接收到这些response后在一个线程池中处理这些消息。</p>
<p>下面列出了一些常用的http client:</p>
<ul>
<li>JDK’s <a href="http://docs.oracle.com/javase/8/docs/api/java/net/URLConnection.html" target="_blank" rel="external">URLConnection</a> uses traditional thread-blocking I/O.</li>
<li><a href="https://hc.apache.org/httpcomponents-client-ga/index.html" target="_blank" rel="external">Apache HTTP Client</a> uses traditional thread-blocking I/O with thread-pools.</li>
<li><a href="https://hc.apache.org/httpcomponents-asyncclient-4.1.x/index.html" target="_blank" rel="external">Apache Async HTTP Client</a> uses NIO.</li>
<li><a href="https://jersey.java.net/documentation/latest/async.html#d0e10447" target="_blank" rel="external">Jersey</a> is a ReST client/server framework; the client API can use several HTTP client backends including URLConnection and Apache HTTP Client.</li>
<li><a href="http://square.github.io/okhttp/" target="_blank" rel="external">OkHttp</a> uses traditional thread-blocking I/O with thread-pools.</li>
<li><a href="http://square.github.io/retrofit/" target="_blank" rel="external">Retrofit</a> turns your HTTP API into a Java interface and can use several HTTP client backends including Apache HTTP Client.</li>
<li><a href="https://grizzly.java.net/" target="_blank" rel="external">Grizzly</a> is network framework with low-level HTTP support; it was using NIO but it switched to AIO .</li>
<li><a href="http://netty.io/" target="_blank" rel="external">Netty</a> is a network framework with HTTP support (low-level), multi-transport, includes NIO and native (the latter uses epoll on Linux).</li>
<li><a href="http://www.eclipse.org/jetty/documentation/current/http-client.html" target="_blank" rel="external">Jetty Async HTTP Client</a> uses NIO.</li>
<li><a href="https://github.com/AsyncHttpClient/async-http-client" target="_blank" rel="external">Async HTTP Client</a> wraps either Netty, Grizzly or JDK’s HTTP support.</li>
<li><a href="https://github.com/dakrone/clj-http" target="_blank" rel="external">clj-http</a> wraps the Apache HTTP Client.</li>
<li><a href="https://dzone.com/articles/www.http-kit.org/client.html" target="_blank" rel="external">http-kit</a> is an async subset of clj-http implemented partially in Java directly on top of NIO.</li>
<li><a href="https://github.com/cch1/http.async.client" target="_blank" rel="external">http async client</a> wraps the Async HTTP Client for Java.</li>
</ul>
<p>这个列表摘自 <a href="https://dzone.com/articles/high-concurrency-http-clients-on-the-jvm" target="_blank" rel="external">High-Concurrency HTTP Clients on the JVM</a>,不止于此，这篇文章重点介绍基于java纤程库quasar的实现的http client库，并比较了性能。我们待会再说。</p>
<p>回到我前面所说的系统，如何能更好的提供性能？有一种方案是借助其它语言的优势，比如Go，让Go来代理完成和B、C、D的请求，系统A通过一个TCP连接与Go程序交流。第三方服务B、C、D的Response结果可以异步地返回给系统A。</p>
<p><img src="proxy.png" alt=""></p>
<p>Go的优势在于可以实现request-per-goroutine,整个系统中可以有成千上万个goroutine。 goroutine是轻量级的，而且在I/O阻塞的时候可以不占用线程，这让Go可以轻松地处理上万个链接，即使I/O阻塞也没问题。Go和Java之间的通讯协议可以通过Protobuffer来实现，而且它们之间只保留一个TCP连接即可。</p>
<p>当然这种架构的修改带来系统稳定性的降低，服务A和服务B、C、D之间的通讯增加了复杂性。同时，因为是异步方式，服务A的业务也要实现异步方式，否则200个线程依然等待Response的话，还是一个阻塞的架构。</p>
<p>通过测试，这种架构可以带来稳定的吞吐率。 不管服务B、C、D的延迟有多久，A的吞吐率能维持15000 requests/秒。当然Go到B、C、D的并发连接数也有限制，我把最大值调高到20000。</p>
<p>这种曲折的方案的最大的两个弊病就是架构的复杂性以及对原有系统需要进行大的重构。 高复杂性带来的是系统的稳定性的降低，包括部署、维护、网络状况、系统资源等。同时系统要改成异步模型，因为系统业务线程发送Request后不能等待Go返回Response,它需要从Client接收更多的Request,而收到Response之后它才继续执行剩下的业务，只有这样才不会阻塞，进而提到系统的吞吐率。</p>
<blockquote>
<p>将系统A改成异步，然后使用HttpUrlConnection线程池行不行？<br>HttpUrlConnection线程池还是导致和B、C、D通讯的吞吐率下降，但是Go这种方案和B、C、D通讯的吞吐率可以维持一个较高的水平。</p>
</blockquote>
<p>考虑到Go的优势，那么能不能在Java中使用类似Go的这种goroutine模型呢？那就是本文要介绍的Java纤程库: ［Quasar](<a href="http://docs.paralleluniverse.co/quasar/)。" target="_blank" rel="external">http://docs.paralleluniverse.co/quasar/)。</a></p>
<p>实际测试结果表明Go和Netty都是两种比较好的解决方案，而且Netty的性能惊人的好，不好的地方正如前面所讲，我们需要将代码改成异步的处理。线程池中的业务单元用Netty发送完Request之后，不要等待Response, Response的处理交给另外的线程来处理，同时注意不要在Netty的Handler里面处理业务逻辑。要解决的问题就变成如何更高效的处理Response了，而不是第三方系统阻塞的问题。</p>
<h3 id="quasar初步">quasar初步</h3>
<p>以下介绍Java的另一个解决方案，也就是Java中的coroutine库，因为最近刚刚看这个库，感觉挺不错的，而且用它替换Thread改动较少。</p>
<p>Java官方并没有纤程库。但是伟大的社区提供了一个优秀的库，它就是Quasar。</p>
<p>创始人是<a href="http://www.paralleluniverse.co/about/" target="_blank" rel="external">Ron Pressler和Dafna Pressler</a>,由Y Combinator孵化。</p>
<blockquote>
<p>Quasar is a library that provides high-performance lightweight threads, Go-like channels, Erlang-like actors, and other asynchronous programming tools for Java and Kotlin.</p>
</blockquote>
<p>Quasar提供了高性能轻量级的线程，提供了类似Go的channel，Erlang风格的actor，以及其它的异步编程的工具，可以用在Java和Kotlin编程语言中。Scala目前的支持还不完善，我想如果这个公司能快速的发展壮大，或者被一些大公司收购的话，对Scala的支持才能提上日程。</p>
<p>你需要把下面的包加入到你的依赖中：</p>
<ul>
<li><strong>Core (必须)</strong>    co.paralleluniverse:quasar-core:0.7.5[:jdk8] (对于 JDK 8，需要增加jdk8 classifier)</li>
<li><strong>Actor</strong>    co.paralleluniverse:quasar-actors:0.7.5</li>
<li><strong>Clustering</strong>    co.paralleluniverse:quasar-galaxy:0.7.5</li>
<li><strong>Reactive Stream</strong>    co.paralleluniverse:quasar-reactive-streams:0.7.5</li>
<li><strong>Kotlin</strong>    co.paralleluniverse:quasar-kotlin:0.7.5</li>
</ul>
<p>Quasar fiber依赖java instrumentation修改你的代码，可以在运行时通过java Agent实现，也可以在编译时使用ant task实现。</p>
<p>通过java agent很简单，在程序启动的时候将下面的指令加入到命令行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-javaagent:path-to-quasar-jar.jar</div></pre></td></tr></table></figure>

<p>对于maven来说，你可以使用插件<a href="http://maven.apache.org/plugins/maven-dependency-plugin/" target="_blank" rel="external">maven-dependency-plugin</a>,它会为你的每个依赖设置一个属性，以便在其它地方引用，我们主要想使用 <code>${co.paralleluniverse:quasar-core:jar}</code>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">plugin</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>maven-dependency-plugin<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">version</span>&gt;</span>2.5.1<span class="tag">&lt;/<span class="title">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">executions</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">execution</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="title">id</span>&gt;</span>getClasspathFilenames<span class="tag">&lt;/<span class="title">id</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="title">goals</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="title">goal</span>&gt;</span>properties<span class="tag">&lt;/<span class="title">goal</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="title">goals</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="title">execution</span>&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="title">executions</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">plugin</span>&gt;</span></div></pre></td></tr></table></figure>

<p>然后你可以配置<code>exec-maven-plugin</code>或者<code>maven-surefire-plugin</code>加上agent参数，在执行maven任务的时候久可以使用Quasar了。</p>
<p>官方提供了一个<a href="https://github.com/puniverse/quasar-mvn-archetype" target="_blank" rel="external">Quasar Maven archetype</a>,你可以通过下面的命令生成一个quasar应用原型：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/puniverse/quasar-mvn-archetype</div><div class="line"><span class="built_in">cd</span> quasar-mvn-archetype</div><div class="line">mvn install</div><div class="line"><span class="built_in">cd</span> ..</div><div class="line">mvn archetype:generate -DarchetypeGroupId=co.paralleluniverse -DarchetypeArtifactId=quasar-mvn-archetype -DarchetypeVersion=<span class="number">0.7</span>.<span class="number">4</span> -DgroupId=testgrp -DartifactId=testprj</div><div class="line"><span class="built_in">cd</span> testprj</div><div class="line">mvn test</div><div class="line">mvn clean compile dependency:properties <span class="keyword">exec</span>:<span class="keyword">exec</span></div></pre></td></tr></table></figure>

<p>如果你使用gradle，可以看一下gradle项目模版：<a href="https://github.com/puniverse/quasar-gradle-template" target="_blank" rel="external">Quasar Gradle template project</a>。</p>
<p>最容易使用Quasar的方案就是使用Java Agent,它可以在运行时instrument程序。如果你想编译的时候就使用AOT instrumentation(Ahead-of-Time)，可以使用Ant任务<code>co.paralleluniverse.fibers.instrument.InstrumentationTask</code>，它包含在quasar-core.jar中。</p>
<p>Quasar最主要的贡献就是提供了轻量级线程的实现，叫做fiber(纤程)。Fiber的功能和使用类似Thread, API接口也类似，所以使用起来没有违和感，但是它们不是被操作系统管理的，它们是由一个或者多个ForkJoinPool调度。一个idle fiber只占用400K内存，切换的时候占用更少的CPU，你的应用中可以有上百万的fiber，显然Thread做不到这一点。这一点和Go的goroutine类似。</p>
<p><strong>Fiber并不意味着它可以在所有的场景中都可以替换Thread。当fiber的代码经常会被等待其它fiber阻塞的时候，就应该使用fiber。</strong><br><strong>对于那些需要CPU长时间计算的代码，很少遇到阻塞的时候，就应该首选thread</strong></p>
<p>以上两条是选择fiber还是thread的判断条件，主要还是看任务是I/O blocking相关还是CPU相关。幸运地是，fiber API使用和thread使用类似，所以代码略微修改久就可以兼容。</p>
<p>Fiber特别适合替换哪些异步回调的代码。使用<code>FiberAsync</code>异步回调很简单，而且性能很好，扩展性也更高。</p>
<p>类似Thread, fiber也是用Fiber类表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Fiber&lt;V&gt;() {</div><div class="line">  <span class="annotation">@Override</span></div><div class="line">  <span class="keyword">protected</span> V <span class="title">run</span>() <span class="keyword">throws</span> SuspendExecution, InterruptedException {</div><div class="line">        <span class="comment">// your code</span></div><div class="line">    }</div><div class="line">}.start();</div></pre></td></tr></table></figure>

<p>与Thread类似，但也有些不同。Fiber可以有一个返回值,类型为泛型V，也可以为空Void。<code>run</code>也可以抛出异常<code>InterruptedException</code>。</p>
<p>你可以传递<code>SuspendableRunnable</code>  或 <code>SuspendableCallable</code> 给Fiber的构造函数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Fiber&lt;Void&gt;(<span class="keyword">new</span> SuspendableRunnable() {</div><div class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() <span class="keyword">throws</span> SuspendExecution, InterruptedException {</div><div class="line">    <span class="comment">// your code</span></div><div class="line">  }</div><div class="line">}).start();</div></pre></td></tr></table></figure>

<p>甚至你可以调用Fiber的join方法等待它完成，调用<code>get</code>方法得到它的结果。</p>
<p>Fiber继承Strand类。Strand类代表一个Fiber或者Thread，提供了一些底层的方法。</p>
<p>逃逸的Fiber(Runaway Fiber)是指那些陷入循环而没有block、或者block fiber本身运行的线程的Fiber。偶尔有逃逸的fiber没有问题，但是太频繁会导致性能的下降，因为需要调度器的线程可能都忙于逃逸fiber了。Quasar会监控这些逃逸fiber,你可以通过JMX监控。如果你不想监控，可以设置系统属性<code>co.paralleluniverse.fibers.detectRunawayFibers</code>为<code>false</code>。</p>
<p>fiber中的<code>ThreadLocal</code>是fiber local的。<code>InheritableThreadLocal</code>继承父fiber的值。</p>
<p>Fiber、SuspendableRunnable 、SuspendableCallable 的<code>run</code>方法会抛出SuspendExecution异常。但这并不是真正意义的异常，而是fiber内部工作的机制，通过这个异常暂停因block而需要暂停的fiber。</p>
<p>任何在Fiber中运行的方法，需要声明这个异常(或者标记@Suspendable),都被称为suspendable method。</p>
<p>反射调用通常都被认为是suspendable, Java8 lambda 也被认为是suspendable。不应该将类构造函数或类初始化器标记为suspendable。</p>
<p><code>synchronized</code>语句块或者方法会阻塞操作系统线程，所以它们不应该标记为suspendable。Blocking线程调用默认也不被quasar允许。但是这两种情况都可以被quasar处理，你需要在Quasar javaagent中分别加上<code>m</code>和<code>b</code>参数，或者ant任务中加上<code>allowMonitors</code>和<code>allowBlocking</code>属性。</p>
<h3 id="quasar原理">quasar原理</h3>
<p>Quasar最初fork自<a href="http://www.matthiasmann.de/content/view/24/26/" target="_blank" rel="external">Continuations Library</a>。</p>
<p>如果你了解其它语言的coroutine, 比如Lua,你久比较容易理解quasar的fiber了。 Fiber实质上是 <em>continuation</em>， continuation可以捕获一个计算的状态，可以暂停当前的计算，等隔一段时间可以继续执行。Quasar通过instrument修改suspendable方法。Quasar的调度器使用<code>ForkJoinPool</code>调度这些fiber。</p>
<p>Fiber调度器FiberScheduler是一个高效的、work-stealing、多线程的调度器。</p>
<p>默认的调度器是<code>FiberForkJoinScheduler</code>,但是你可以使用自己的线程池去调度，请参考<code>FiberExecutorScheduler</code>。</p>
<p>当一个类被加载时，Quasar的instrumentation模块 (使用 Java agent时) 搜索suspendable 方法。每一个suspendable 方法 <code>f</code>通过下面的方式 instrument:<br>它搜索对其它suspendable方法的调用。对suspendable方法<code>g</code>的调用，一些代码会在这个调用<code>g</code>的前后被插入，它们会保存和恢复fiber栈本地变量的状态，记录这个暂停点。在这个“suspendable function chain”的最后，我们会发现对<code>Fiber.park</code>的调用。<code>park</code>暂停这个fiber，扔出 SuspendExecution异常。</p>
<p>当<code>g</code> block的时候，SuspendExecution异常会被Fiber捕获。 当Fiber被唤醒(使用unpark), 方法<code>f</code>会被调用， 执行记录显示它被block在g的调用上，所以程序会立即跳到<code>f</code>调用<code>g</code>的那一行,然后调用它。最终我们会到达暂停点，然后继续执行。当<code>g</code>返回时， <code>f</code>中插入的代码会恢复f的本地变量。</p>
<p>过程听起来很复杂，但是它只会带来3% ~ 5%的性能的损失。</p>
<p>下面看一个简单的例子, 方法m2声明抛出SuspendExecution异常，方法m1调用m2和m3,所以也声明抛出这个异常，最后这个异常会被Fiber所捕获：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Helloworld</span> </span>{</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">void</span> m1() <span class="keyword">throws</span> SuspendExecution, InterruptedException {</div><div class="line">        String m = <span class="string">"m1"</span>;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"m1 begin"</span>);</div><div class="line">        m = m2();</div><div class="line">        m = m3();</div><div class="line">        System.out.println(<span class="string">"m1 end"</span>);</div><div class="line">        System.out.println(m);</div><div class="line"></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">static</span> String m2() <span class="keyword">throws</span> SuspendExecution, InterruptedException {</div><div class="line">        <span class="keyword">return</span> <span class="string">"m2"</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">static</span> String m3() <span class="keyword">throws</span> SuspendExecution, InterruptedException {</div><div class="line">        <span class="keyword">return</span> <span class="string">"m3"</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> ExecutionException, InterruptedException {</div><div class="line">        <span class="keyword">new</span> Fiber&lt;Void&gt;(<span class="string">"Caller"</span>, <span class="keyword">new</span> SuspendableRunnable() {</div><div class="line"></div><div class="line">            <span class="annotation">@Override</span></div><div class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() <span class="keyword">throws</span> SuspendExecution, InterruptedException {</div><div class="line">                m1();</div><div class="line">            }</div><div class="line">        }).start();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>反编译这段代码 (一般的反编译软件如jd-gui不能把这段代码反编译java文件，<a href="https://bitbucket.org/mstrobel/procyon/wiki/Java%20Decompiler" target="_blank" rel="external">Procyon</a>虽然能反编译，但是感觉反编译有错。所以我们还是看字节码吧)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@Instrumented</span>(suspendableCallSites={<span class="number">16</span>, <span class="number">17</span>}, methodStart=<span class="number">13</span>, methodEnd=<span class="number">21</span>, methodOptimized=<span class="keyword">false</span>)</div><div class="line"> <span class="keyword">static</span> <span class="keyword">void</span> m1()</div><div class="line">   <span class="keyword">throws</span> SuspendExecution, InterruptedException</div><div class="line"> {</div><div class="line">   <span class="comment">// Byte code:</span></div><div class="line">   <span class="comment">//   0: aconst_null</span></div><div class="line">   <span class="comment">//   1: astore_3</span></div><div class="line">   <span class="comment">//   2: invokestatic 88	co/paralleluniverse/fibers/Stack:getStack	()Lco/paralleluniverse/fibers/Stack;</span></div><div class="line">   <span class="comment">//   5: dup</span></div><div class="line">   <span class="comment">//   6: astore_1</span></div><div class="line">   <span class="comment">//   7: ifnull +42 -&gt; 49</span></div><div class="line">   <span class="comment">//   10: aload_1</span></div><div class="line">   <span class="comment">//   11: iconst_1</span></div><div class="line">   <span class="comment">//   12: istore_2</span></div><div class="line">   <span class="comment">//   13: invokevirtual 92	co/paralleluniverse/fibers/Stack:nextMethodEntry	()I</span></div><div class="line">   <span class="comment">//   16: tableswitch	default:+24-&gt;40, 1:+64-&gt;80, 2:+95-&gt;111</span></div><div class="line">   <span class="comment">//   40: aload_1</span></div><div class="line">   <span class="comment">//   41: invokevirtual 96	co/paralleluniverse/fibers/Stack:isFirstInStackOrPushed	()Z</span></div><div class="line">   <span class="comment">//   44: ifne +5 -&gt; 49</span></div><div class="line">   <span class="comment">//   47: aconst_null</span></div><div class="line">   <span class="comment">//   48: astore_1</span></div><div class="line">   <span class="comment">//   49: iconst_0</span></div><div class="line">   <span class="comment">//   50: istore_2</span></div><div class="line">   <span class="comment">//   51: ldc 2</span></div><div class="line">   <span class="comment">//   53: astore_0</span></div><div class="line">   <span class="comment">//   54: getstatic 3	java/lang/System:out	Ljava/io/PrintStream;</span></div><div class="line">   <span class="comment">//   57: ldc 4</span></div><div class="line">   <span class="comment">//   59: invokevirtual 5	java/io/PrintStream:println	(Ljava/lang/String;)V</span></div><div class="line">   <span class="comment">//   62: aload_1</span></div><div class="line">   <span class="comment">//   63: ifnull +26 -&gt; 89</span></div><div class="line">   <span class="comment">//   66: aload_1</span></div><div class="line">   <span class="comment">//   67: iconst_1</span></div><div class="line">   <span class="comment">//   68: iconst_1</span></div><div class="line">   <span class="comment">//   69: invokevirtual 100	co/paralleluniverse/fibers/Stack:pushMethod	(II)V</span></div><div class="line">   <span class="comment">//   72: aload_0</span></div><div class="line">   <span class="comment">//   73: aload_1</span></div><div class="line">   <span class="comment">//   74: iconst_0</span></div><div class="line">   <span class="comment">//   75: invokestatic 104	co/paralleluniverse/fibers/Stack:push	(Ljava/lang/Object;Lco/paralleluniverse/fibers/Stack;I)V</span></div><div class="line">   <span class="comment">//   78: iconst_0</span></div><div class="line">   <span class="comment">//   79: istore_2</span></div><div class="line">   <span class="comment">//   80: aload_1</span></div><div class="line">   <span class="comment">//   81: iconst_0</span></div><div class="line">   <span class="comment">//   82: invokevirtual 108	co/paralleluniverse/fibers/Stack:getObject	(I)Ljava/lang/Object;</span></div><div class="line">   <span class="comment">//   85: checkcast 110	java/lang/String</span></div><div class="line">   <span class="comment">//   88: astore_0</span></div><div class="line">   <span class="comment">//   89: invokestatic 6	com/colobu/fiber/Helloworld:m2	()Ljava/lang/String;</span></div><div class="line">   <span class="comment">//   92: astore_0</span></div><div class="line">   <span class="comment">//   93: aload_1</span></div><div class="line">   <span class="comment">//   94: ifnull +26 -&gt; 120</span></div><div class="line">   <span class="comment">//   97: aload_1</span></div><div class="line">   <span class="comment">//   98: iconst_2</span></div><div class="line">   <span class="comment">//   99: iconst_1</span></div><div class="line">   <span class="comment">//   100: invokevirtual 100	co/paralleluniverse/fibers/Stack:pushMethod	(II)V</span></div><div class="line">   <span class="comment">//   103: aload_0</span></div><div class="line">   <span class="comment">//   104: aload_1</span></div><div class="line">   <span class="comment">//   105: iconst_0</span></div><div class="line">   <span class="comment">//   106: invokestatic 104	co/paralleluniverse/fibers/Stack:push	(Ljava/lang/Object;Lco/paralleluniverse/fibers/Stack;I)V</span></div><div class="line">   <span class="comment">//   109: iconst_0</span></div><div class="line">   <span class="comment">//   110: istore_2</span></div><div class="line">   <span class="comment">//   111: aload_1</span></div><div class="line">   <span class="comment">//   112: iconst_0</span></div><div class="line">   <span class="comment">//   113: invokevirtual 108	co/paralleluniverse/fibers/Stack:getObject	(I)Ljava/lang/Object;</span></div><div class="line">   <span class="comment">//   116: checkcast 110	java/lang/String</span></div><div class="line">   <span class="comment">//   119: astore_0</span></div><div class="line">   <span class="comment">//   120: invokestatic 7	com/colobu/fiber/Helloworld:m3	()Ljava/lang/String;</span></div><div class="line">   <span class="comment">//   123: astore_0</span></div><div class="line">   <span class="comment">//   124: getstatic 3	java/lang/System:out	Ljava/io/PrintStream;</span></div><div class="line">   <span class="comment">//   127: ldc 8</span></div><div class="line">   <span class="comment">//   129: invokevirtual 5	java/io/PrintStream:println	(Ljava/lang/String;)V</span></div><div class="line">   <span class="comment">//   132: getstatic 3	java/lang/System:out	Ljava/io/PrintStream;</span></div><div class="line">   <span class="comment">//   135: aload_0</span></div><div class="line">   <span class="comment">//   136: invokevirtual 5	java/io/PrintStream:println	(Ljava/lang/String;)V</span></div><div class="line">   <span class="comment">//   139: aload_1</span></div><div class="line">   <span class="comment">//   140: ifnull +7 -&gt; 147</span></div><div class="line">   <span class="comment">//   143: aload_1</span></div><div class="line">   <span class="comment">//   144: invokevirtual 113	co/paralleluniverse/fibers/Stack:popMethod	()V</span></div><div class="line">   <span class="comment">//   147: return</span></div><div class="line">   <span class="comment">//   148: aload_1</span></div><div class="line">   <span class="comment">//   149: ifnull +7 -&gt; 156</span></div><div class="line">   <span class="comment">//   152: aload_1</span></div><div class="line">   <span class="comment">//   153: invokevirtual 113	co/paralleluniverse/fibers/Stack:popMethod	()V</span></div><div class="line">   <span class="comment">//   156: athrow</span></div><div class="line">   <span class="comment">// Line number table:</span></div><div class="line">   <span class="comment">//   Java source line #13	-&gt; byte code offset #51</span></div><div class="line">   <span class="comment">//   Java source line #15	-&gt; byte code offset #54</span></div><div class="line">   <span class="comment">//   Java source line #16	-&gt; byte code offset #62</span></div><div class="line">   <span class="comment">//   Java source line #17	-&gt; byte code offset #93</span></div><div class="line">   <span class="comment">//   Java source line #18	-&gt; byte code offset #124</span></div><div class="line">   <span class="comment">//   Java source line #19	-&gt; byte code offset #132</span></div><div class="line">   <span class="comment">//   Java source line #21	-&gt; byte code offset #139</span></div><div class="line">   <span class="comment">// Local variable table:</span></div><div class="line">   <span class="comment">//   start	length	slot	name	signature</span></div><div class="line">   <span class="comment">//   53	83	0	m	String</span></div><div class="line">   <span class="comment">//   6	147	1	localStack	co.paralleluniverse.fibers.Stack</span></div><div class="line">   <span class="comment">//   12	99	2	i	int</span></div><div class="line">   <span class="comment">//   1	1	3	localObject	Object</span></div><div class="line">   <span class="comment">//   156	1	4	localSuspendExecution	SuspendExecution</span></div><div class="line">   <span class="comment">// Exception table:</span></div><div class="line">   <span class="comment">//   from	to	target	type</span></div><div class="line">   <span class="comment">//   49	148	148	finally</span></div><div class="line">   <span class="comment">//   49	148	156	co/paralleluniverse/fibers/SuspendExecution</span></div><div class="line">   <span class="comment">//   49	148	156	co/paralleluniverse/fibers/RuntimeSuspendExecution</span></div><div class="line"> }</div></pre></td></tr></table></figure>

<p>这段反编译的代码显示了方法m被instrument后的样子，虽然我们不能很清楚的看到代码执行的样子，但是也可以大概地看到它实际在方法的最开始加入了此方法的栈信息的检查（＃0 ～ ＃49，如果是第一次运行这个方法，则直接运行，<br>然后在一些暂停点上加上一些栈压入的处理，并且可以在下次执行的时候直接跳到上次的暂停点上。</p>
<p>官方的工程师关于Quasar的instrument操作如下：</p>
<blockquote>
<ul>
<li>Fully analyze the bytecode to find all the calls into suspendable methods. A method that (potentially) calls into other suspendable methods is itself considered suspendable, transitively.</li>
<li>Inject minimal bytecode in suspendable methods (and only them) that will manage an user-mode stack, in the following places:<ul>
<li>At the beginning we’ll check if we’re resuming the fiber and only in this case we’ll jump into the relevant bytecode index.</li>
<li>Before a call into another suspendable method we’ll push a snapshot of the current activation frame, including the resume bytecode index; we can do it because we know the structure statically from the analysis phase.</li>
<li>After a call into another suspendable method we’ll pop the top activation frame and, if resumed, we’ll restore it in the current fiber.</li>
</ul>
</li>
</ul>
</blockquote>
<p>我并没有更深入的去了解Quasar的实现细节以及调度算法，有兴趣的读者可以翻翻它的代码。如果你有更深入的剖析，请留下相关的地址，以便我加到参考文档中。</p>
<p>曾经， 陆陆续续也有一些Java coroutine的实现(<a href="http://stackoverflow.com/questions/2846428/available-coroutine-libraries-in-java" target="_blank" rel="external">coroutine-libraries</a>), 但是目前来说最好的应该还是Quasar。</p>
<p>Oracle会实现一个官方的纤程库吗？目前来说没有看到这方面的计划，而且从Java的开发进度上来看，这个特性可能是遥遥无期的，所以目前还只能借助社区的力量，从第三方库如Quasar中寻找解决方案。</p>
<p>更多的Quasar知识，比如Channel、Actor、Reactive Stream 的使用可以参考官方的文档，官方也提供了多个<a href="http://docs.paralleluniverse.co/quasar/#examples" target="_blank" rel="external">例子</a>。</p>
<h3 id="Comsat介绍">Comsat介绍</h3>
<p>Comsat又是什么？</p>
<p>Comsat还是Parallel Universe提供的集成Quasar的一套开源库，可以提供web或者企业级的技术，如HTTP服务和数据库访问。</p>
<p>Comsat并不是一套web框架。它并不提供新的API,只是为现有的技术如Servlet、JAX－RS、JDBC等提供Quasar fiber的集成。</p>
<p>它包含非常多的库，比如Spring、ApacheHttpClient、OkHttp、Undertow、Netty、Kafka等。</p>
<h3 id="性能对比">性能对比</h3>
<p>刘小溪在CSDN上写了一篇关于Quasar的文章：<a href="http://geek.csdn.net/news/detail/71824" target="_blank" rel="external">次时代Java编程（一）：Java里的协程</a>，写的挺好，建议读者读一读。</p>
<p>它参考<a href="https://github.com/atemerev/skynet" target="_blank" rel="external">Skynet</a>的测试写了代码进行对比，这个测试是并发执行整数的累加：<br>测试结果是Golang花了261毫秒，Quasar花了612毫秒。其实结果还不错，但是文中指出这个测试没有发挥Quasar的性能。因为quasar的性能主要在于阻塞代码的调度上。<br>虽然文中加入了排序的功能，显示Java要比Golang要好，但是我觉得这又陷入了另外一种错误的比较， Java的排序算法使用TimSort，排序效果相当好，Go的排序效果显然比不上Java的实现，所以最后的测试主要测试排序算法上。 真正要体现Quasar的性能还是测试在有阻塞的情况下fiber的调度性能。</p>
<h4 id="HttpClient">HttpClient</h4>
<p>话题扯的越来越远了，拉回来。我最初的目的是要解决的是在第三方服务响应慢的情况下提高系统 <strong>A</strong> 的吞吐率。最初A是使用200个线程处理业务逻辑，调用第三方服务。因为线程总是被第三方服务阻塞，所以系统A的吞吐率总是很低。</p>
<p>虽然使用Go可以解决这个问题，但是对于系统A的改造比较大，还增加了系统的复杂性。Netty性能好，改动量还可以接受，但是不妨看一下这个场景，系统的问题是由http阻塞引起。</p>
<p>这正是Quasar fiber适合的场景，如果一个Fiber被阻塞，它可以暂时放弃线程，以便线程可以用来执行其它的Fiber。虽然整个集成系统的吞吐率依然很低，这是无法避免的，但是系统的吞吐率确很高。</p>
<p>Comsat提供了Apache Http Client的实现： <code>FiberHttpClientBuilder</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> CloseableHttpClient client = FiberHttpClientBuilder.</div><div class="line">        create(<span class="number">2</span>). <span class="comment">// use 2 io threads</span></div><div class="line">        setMaxConnPerRoute(concurrencyLevel).</div><div class="line">        setMaxConnTotal(concurrencyLevel).build();</div></pre></td></tr></table></figure>

<p>然后在Fiber中久可以调用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String response = client.execute(<span class="keyword">new</span> HttpGet(<span class="string">"http://localhost:8080"</span>), BASIC_RESPONSE_HANDLER);</div></pre></td></tr></table></figure>

<p>你也可以使用异步的HttpClient:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> CloseableHttpAsyncClient client = FiberCloseableHttpAsyncClient.wrap(HttpAsyncClients.</div><div class="line">        custom().</div><div class="line">        setMaxConnPerRoute(concurrencyLevel).</div><div class="line">        setMaxConnTotal(concurrencyLevel).</div><div class="line">        build());</div><div class="line">client.start();</div></pre></td></tr></table></figure>

<p>Comsat还提供了Jersey Http Client: <code>AsyncClientBuilder.newClient()</code>。</p>
<p>甚至提供了<code>Retrofit</code>、<code>OkHttp</code>的实现。</p>
<p>经过测试，虽然随着系统B、C、D的响应时间的拉长，吞吐率有所降低，但是在latency为100毫秒的时候吞吐率依然能达到9900 requests/秒，可以满足我们的需求，而我们的代码改动的比较小。</p>
<p>综上所述，如果想彻底改造系统A,则可以使用Go库重写，或者使用Netty + Rx的方式去处理，都能达到比较好的效果。如果想改动比较小，可以考虑使用quasar替换线程对代码进行维护。</p>
<blockquote>
<p>我希望本文不要给读者造成误解，以为Java NIO／Selector这种方式不能解决本文的问题，也就是第三方阻塞的问题。 事实上Java NIO也正是适合解决这样的问题， 比如Netty性能就不错，但是你需要小心的是， 不要让你的这个client对外又变成阻塞的方式，而是程序应该异步的去发送request和处理response。当然本文重点不是介绍这种实现，而是介绍Java的线程库，它可以改造传统的代码，即使有阻塞，也只是阻塞Fiber，而不是阻塞线程，这是另一个解决问题的思路。</p>
</blockquote>
<h3 id="参考文档">参考文档</h3>
<ul>
<li><a href="http://docs.paralleluniverse.co/quasar/" target="_blank" rel="external">http://docs.paralleluniverse.co/quasar/</a></li>
<li><a href="http://docs.paralleluniverse.co/comsat/" target="_blank" rel="external">http://docs.paralleluniverse.co/comsat/</a></li>
<li><a href="http://geek.csdn.net/news/detail/71824" target="_blank" rel="external">http://geek.csdn.net/news/detail/71824</a></li>
<li><a href="http://stackoverflow.com/questions/24722233/how-to-use-quasar-with-scala-under-sbt" target="_blank" rel="external">http://stackoverflow.com/questions/24722233/how-to-use-quasar-with-scala-under-sbt</a></li>
<li><a href="http://blog.kazaff.me/2016/05/29/了解协程(coroutine)/" target="_blank" rel="external">http://blog.kazaff.me/2016/05/29/了解协程(coroutine)/</a></li>
<li><a href="http://tieba.baidu.com/p/4244920191" target="_blank" rel="external">http://tieba.baidu.com/p/4244920191</a></li>
<li><a href="http://javapapers.com/core-java/java-instrumentation/" target="_blank" rel="external">http://javapapers.com/core-java/java-instrumentation/</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/package-summary.html" target="_blank" rel="external">https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/package-summary.html</a></li>
<li><a href="http://zeroturnaround.com/rebellabs/what-are-fibers-and-why-you-should-care/" target="_blank" rel="external">http://zeroturnaround.com/rebellabs/what-are-fibers-and-why-you-should-care/</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近遇到的一个问题大概是微服务架构中经常会遇到的一个问题：</p>
<p>服务 <strong>A</strong> 是我们开发的系统，它的业务需要调用 <strong>B</strong>、<strong>C</strong>、<strong>D</strong> 等多个服务，这些服务是通过http的访问提供的。 问题是 <strong>B</strong>、<strong>C</strong>、<strong>D</strong> 这些服务都是第三方提供的，不能保证它们的响应时间，快的话十几毫秒，慢的话甚至1秒多，所以这些服务的Latency比较长。幸运地是这些服务都是集群部署的，容错率和并发支持都比较高，所以不担心它们的并发性能，唯一不爽的就是就是它们的Latency太高了。</p>
<p><img src="/2016/07/14/Java-Fiber-Quasar/system.png" alt="简化的微服务架构"></p>
<p>系统A会从Client接收Request, 每个Request的处理都需要多次调用B、C、D的服务，所以完成一个Request可能需要1到2秒的时间。为了让A能更好地支持并发数，系统中使用线程池处理这些Request。当然这是一个非常简化的模型，实际的业务处理比较复杂。</p>
<p>可以预见，因为系统B、C、D的延迟，导致整个业务处理都很慢，即使使用线程池，但是每个线程还是会阻塞在B、C、D的调用上，导致I/O阻塞了这些线程， CPU利用率相对来说不是那么高。</p>
<p>当然在测试的时候使用的是B、C、D的模拟器，没有预想到它们的响应是那么慢，因此测试数据的结果还不错，吞吐率还可以，但是在实际环境中问题就暴露出来了。</p>
]]>
    
    </summary>
    
      <category term="Fiber" scheme="http://colobu.com/tags/Fiber/"/>
    
      <category term="Quasar" scheme="http://colobu.com/tags/Quasar/"/>
    
      <category term="Comsat" scheme="http://colobu.com/tags/Comsat/"/>
    
      <category term="Java" scheme="http://colobu.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转]使用Nginx 和 RTMP 模块搭建视频直播系统]]></title>
    <link href="http://colobu.com/2016/07/13/Setup-Nginx-and-RTMP-module/"/>
    <id>http://colobu.com/2016/07/13/Setup-Nginx-and-RTMP-module/</id>
    <published>2016-07-13T07:59:01.000Z</published>
    <updated>2016-07-14T06:32:26.000Z</updated>
    <content type="html"><![CDATA[<p>原文: <a href="https://licson.net/post/setting-up-adaptive-streaming-with-nginx/" target="_blank" rel="external">Setting Up Adaptive Streaming with Nginx</a> by <a href="https://licson.net/" target="_blank" rel="external">Licson</a>。</p>
<blockquote>
<p>最近我在为一个组织搭建视频直播系统。对于视频直播来说我是新手，经过一番调研，最终还是觉得Nginx + RTMP module是一个好的选择。<br>搭建这个系统还是很困难的。经过了好几天的测试和摸索，我得到了一种比较好的配置，值得给大家分享。</p>
</blockquote>
<a id="more"></a>
<p>Recently, I’m working out a system to smoothly stream live events for an organization. That is pretty new to me and, after a bunch of research, found that Nginx with the RTMP module seems to be a good choice. There are many difficulties when setting all this up and after several days of testing, I found a good setting that is worth a post.</p>
<h3 id="Setup_Nginx_and_RTMP_module">Setup Nginx and RTMP module</h3>
<p>First, let’s get Nginx set up. In order to use the <a href="https://github.com/arut/nginx-rtmp-module" target="_blank" rel="external">RTMP module</a>, we need to compile that as an Nginx module. It would look something like this:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">apt-get install git gcc make libaio1 libpcre3-dev openssl libssl-dev ffmpeg -y</div><div class="line"></div><div class="line"><span class="comment"># Installing the same thing in RHEL/CentOS</span></div><div class="line">yum install git gcc make libaio libaio-devel openssl libssl-devel pcre-devel ffmpeg -y</div><div class="line"></div><div class="line"><span class="comment"># Download nginx and nginx-rtmp-module</span></div><div class="line">wget http://nginx.org/download/nginx-<span class="number">1.9</span>.<span class="number">4</span>.tar.gz</div><div class="line">git clone https://github.com/arut/nginx-rtmp-module.git</div><div class="line"></div><div class="line"><span class="comment"># Compile nginx with nginx-rtmp and libaio</span></div><div class="line">tar zxvf nginx-<span class="number">1.9</span>.<span class="number">4</span>.tar.gz</div><div class="line"></div><div class="line">./configure --prefix=/usr/local/nginx --with-file-aio --add-module=/path/to/nginx-rtmp/</div><div class="line">make</div><div class="line">make install</div><div class="line"></div><div class="line"><span class="comment"># Link nginx</span></div><div class="line">ln <span class="operator">-s</span> /usr/local/nginx/sbin/nginx /usr/bin/nginx</div><div class="line"></div><div class="line">nginx <span class="comment"># Start Nginx</span></div><div class="line">nginx <span class="operator">-s</span> stop <span class="comment"># Stop Nginx</span></div></pre></td></tr></table></figure>

<p>After all things are done, check whether nginx is compiled properly.<br><img src="Capture.png" alt=""><br>If you can see that Nginx RTMP is included, you can go to the next step. Before we proceed to configuring Nginx for live streaming, we should confirm what kind of resolution we should provide for live streams and how much hardware power you have.</p>
<h3 id="Prerequisites">Prerequisites</h3>
<p>For converting live streams into several streams for adaptive streaming, you need to make sure your server have enough CPU for such workload. Otherwise, the live stream will suffer from continuous delays and/or server becomes unresponsive. I have spawn some EC2 c3.large and c3.xlarge instances, test with them and I found out their optimized CPU can handle such workload with ease. Something that also worth mention is about the I/O limits of the disks. If possible, store the HLS fragments generated to an high-speed SSD helps maintain smooth streaming experiences.</p>
<p><img src="ec2.png" alt="CPU Usage when using an EC2 c3.xlarge instance"></p>
<p>Then, you also need to think about what kind of resolutions you will be offering for adaptive streaming. Generally about 4-5 variants are good enough to provide great loading speeds for different network speeds and devices. Here’s my recommended list of variants used for live streaming:</p>
<ol>
<li>240p Low Definition stream at 288kbps</li>
<li>480p Standard Definition stream at 448kbps</li>
<li>540p Standard Definition stream at 1152kbps</li>
<li>720p High Definition stream at 2048kbps</li>
<li>Source resolution, source bitrate</li>
</ol>
<h3 id="Configuring_nginx_for_live_streaming">Configuring nginx for live streaming</h3>
<p>Here is my own nginx.conf with comments that you can have references on.</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">worker_processes  auto;</div><div class="line">events {</div><div class="line">    # Allows up to 1024 connections, can be adjusted</div><div class="line">    worker_connections  1024;</div><div class="line">}</div><div class="line"></div><div class="line"># RTMP configuration</div><div class="line">rtmp {</div><div class="line">    server {</div><div class="line">        listen 1935; # Listen on standard RTMP port</div><div class="line">        chunk_size 4000;</div><div class="line"></div><div class="line">        # This application is to accept incoming stream</div><div class="line">        application live {</div><div class="line">            live on; # Allows live input</div><div class="line"></div><div class="line">            # Once receive stream, transcode for adaptive streaming</div><div class="line">            # This single ffmpeg command takes the input and transforms</div><div class="line">            # the source into 4 different streams with different bitrate</div><div class="line">            # and quality. P.S. The scaling done here respects the aspect</div><div class="line">            # ratio of the input.</div><div class="line">            exec ffmpeg -i rtmp://localhost/$app/$name -async 1 -vsync -1</div><div class="line">                        -c:v libx264 -c:a libvo_aacenc -b:v 256k -b:a 32k -vf "scale=480:trunc(ow/a/2)*2" -tune zerolatency -preset veryfast -crf 23 -f flv rtmp://localhost/show/$name_low</div><div class="line">                        -c:v libx264 -c:a libvo_aacenc -b:v 768k -b:a 96k -vf "scale=720:trunc(ow/a/2)*2" -tune zerolatency -preset veryfast -crf 23 -f flv rtmp://localhost/show/$name_mid</div><div class="line">                        -c:v libx264 -c:a libvo_aacenc -b:v 1024k -b:a 128k -vf "scale=960:trunc(ow/a/2)*2" -tune zerolatency -preset veryfast -crf 23 -f flv rtmp://localhost/show/$name_high</div><div class="line">                        -c:v libx264 -c:a libvo_aacenc -b:v 1920k -b:a 128k -vf "scale=1280:trunc(ow/a/2)*2" -tune zerolatency -preset veryfast -crf 23 -f flv rtmp://localhost/show/$name_hd720</div><div class="line">                        -c copy -f flv rtmp://localhost/show/$name_src;</div><div class="line">        }</div><div class="line"></div><div class="line">        # This application is for splitting the stream into HLS fragments</div><div class="line">        application show {</div><div class="line">            live on; # Allows live input from above</div><div class="line">            hls on; # Enable HTTP Live Streaming</div><div class="line"></div><div class="line">            # Pointing this to an SSD is better as this involves lots of IO</div><div class="line">            hls_path /mnt/hls/;</div><div class="line"></div><div class="line">            # Instruct clients to adjust resolution according to bandwidth</div><div class="line">            hls_variant _low BANDWIDTH=288000; # Low bitrate, sub-SD resolution</div><div class="line">            hls_variant _mid BANDWIDTH=448000; # Medium bitrate, SD resolution</div><div class="line">            hls_variant _high BANDWIDTH=1152000; # High bitrate, higher-than-SD resolution</div><div class="line">            hls_variant _hd720 BANDWIDTH=2048000; # High bitrate, HD 720p resolution</div><div class="line">            hls_variant _src BANDWIDTH=4096000; # Source bitrate, source resolution</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">http {</div><div class="line">    # See http://licson.net/post/optimizing-nginx-for-large-file-delivery/ for more detail</div><div class="line">    # This optimizes the server for HLS fragment delivery</div><div class="line">    sendfile off;</div><div class="line">    tcp_nopush on;</div><div class="line">    aio on;</div><div class="line">    directio 512;</div><div class="line"></div><div class="line">    # HTTP server required to serve the player and HLS fragments</div><div class="line">    server {</div><div class="line">        listen 80;</div><div class="line"></div><div class="line">        location / {</div><div class="line">            root /path/to/web_player/;</div><div class="line">        }</div><div class="line"></div><div class="line">        location /hls {</div><div class="line">            types {</div><div class="line">                application/vnd.apple.mpegurl m3u8;</div><div class="line">            }</div><div class="line"></div><div class="line">            root /mnt/;</div><div class="line">            add_header Cache-Control no-cache; # Prevent caching of HLS fragments</div><div class="line">            add_header Access-Control-Allow-Origin *; # Allow web player to access our playlist</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>Then, configure your live encoder to use these settings to stream into the server:</p>
<ul>
<li>RTMP Endpoint: rtmp://yourserver/live/</li>
<li>RTMP Stream Name: [Whatever name you like]</li>
</ul>
<p>Finally, configure your player for live playback. The HLS URL would look like this:<br><a href="http://yourserver/hls/[The" target="_blank" rel="external">http://yourserver/hls/[The</a> stream name above].m3u8</p>
<h3 id="Recommended_encoder_settings_for_live_events">Recommended encoder settings for live events</h3>
<p>If you can adjust the encoder, the following settings can help to gain better experiences.</p>
<ul>
<li>Full HD Resolution (1920×1080) is recommended</li>
<li>H.264 Main profile, with target bitrate of 4000Kbps, maximum 6000Kbps</li>
<li>25fps, 2 second keyframe interval</li>
<li>AAC audio at 128Kbps, 44.1kHz sample rate</li>
</ul>
<p>And that’s all! I hope you can enjoy doing live events with these techniques.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文: <a href="https://licson.net/post/setting-up-adaptive-streaming-with-nginx/" target="_blank" rel="external">Setting Up Adaptive Streaming with Nginx</a> by <a href="https://licson.net/" target="_blank" rel="external">Licson</a>。</p>
<blockquote>
<p>最近我在为一个组织搭建视频直播系统。对于视频直播来说我是新手，经过一番调研，最终还是觉得Nginx + RTMP module是一个好的选择。<br>搭建这个系统还是很困难的。经过了好几天的测试和摸索，我得到了一种比较好的配置，值得给大家分享。</p>
</blockquote>
]]>
    
    </summary>
    
      <category term="RTMP" scheme="http://colobu.com/tags/RTMP/"/>
    
      <category term="工具" scheme="http://colobu.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转]go's march to low latency gc]]></title>
    <link href="http://colobu.com/2016/07/13/gos-march-to-low-latency-gc/"/>
    <id>http://colobu.com/2016/07/13/gos-march-to-low-latency-gc/</id>
    <published>2016-07-13T02:50:13.000Z</published>
    <updated>2016-07-13T08:13:49.000Z</updated>
    <content type="html"><![CDATA[<p>这是Twitch的<a href="https://blog.twitch.tv/@rhysh" target="_blank" rel="external">Rhys Hiltner</a>写的一篇关于Go垃圾回收监控的优秀文章，我前几天在reddit看到后就想翻译它。这几天也看到飞花无缺已经把它翻译整理了：<a href="http://blog.csdn.net/erlib/article/details/51850912" target="_blank" rel="external">为Go语言GC正名－2秒到1毫秒的演变史</a>，所以我就不翻译了，因为这篇文章被墙了，我就把原文转帖在这里。</p>
<p>这篇文章有几个值得我们学习的地方。一是提供了Go各个版本在产品级大并发情况(50万并发用户)的垃圾回收器的改进效果，二是对Go的垃圾回收的监控分析手段，主要通过<a href="http://sss.gnlnymzg.lnhtr.uk2.gsr.awhoer.net/brendangregg/FlameGraph" target="_blank" rel="external">Brendan Gregg’s tools</a>火炬图这个工具分析方法的耗时。</p>
<p><img src="/2016/07/13/gos-march-to-low-latency-gc/flamegraph.png" alt=""></p>
<p>以下是文章原文。</p>
<a id="more"></a>
<p>We use <a href="https://golang.org/" target="_blank" rel="external">Go</a> at <a href="https://www.twitch.tv/" target="_blank" rel="external">Twitch</a> for many of our busiest systems. Its simplicity, safety, performance, and readability make it a good tool for the problems we encounter with serving live video and chat to our millions of users.<br>But this isn’t another article about how great Go is for us — it’s about how our use of Go pushes the limits of the current runtime implementation in some dimensions, and how we respond to reaching those limits.<br>It’s the story of how improvements to the Go runtime between Go 1.4 and Go 1.6 gave us a 20x improvement in garbage collection (GC) pause time, of how we’ve gotten another 10x improvement in Go 1.6’s pauses, and of how sharing our experience with the Go runtime team helped them give us an additional 10x speedup in Go 1.7 while obsoleting our manual tuning.</p>
<h2 id="The_GC_latency_saga_begins">The GC latency saga begins</h2>
<p>Our IRC-based chat system was first written in Go in late 2013, replacing the previous Python implementation. Using pre-release versions of Go 1.2, it was able to serve over 500,000 concurrent users from each physical host without special tuning. With a group of three goroutines (Go’s lightweight threads of execution) serving each connection, the program chugged along with 1,500,000 goroutines per process. Even with such a large goroutine count, the only major performance issue we encountered with Go circa 1.2 was the GC pause time, which would freeze our application for tens of seconds whenever it ran — not something we could accept for our interactive chat service.</p>
<p>Not only was each GC pause very expensive, the collections ran several times a minute. We worked hard to reduce the number and size of memory allocations so the GC would run less frequently, declaring victory once the heap grew only around 50% every two minutes. Although there were fewer pauses, each one was just as devastating.<br>Once Go 1.2 was released, GC pause time was down to “only” a few seconds. We split our traffic across a larger number of processes, which brought the pauses down to a more comfortable range.<br>The work to reduce allocations continues to benefit our chat server even as the Go implementation evolves, but the change to split chat traffic across a larger number of processes is a workaround for a particular range of Go versions. Workarounds like that don’t stand the test of time, but are important for providing a good service to our users today. Sharing our experience with the workarounds can help to create lasting improvements to the Go runtime that benefit more than a single program.<br>Starting with Go 1.5 in August of 2015, Go’s garbage collector is mostly-concurrent and incremental, meaning that it no longer requires the application to be entirely stopped while it does the bulk of its work. Aside from relatively short setup and termination phases, our program can continue to operate while garbage collection is underway. Upgrading to Go 1.5 immediately led to a 10x improvement in the length of GC pauses in our chat system, with pause time on a heavily-loaded test instance shrinking from 2 seconds to around 200ms.</p>
<h2 id="Go_1-5,_a_new_era_of_GC">Go 1.5, a new era of GC</h2>
<p>While the latency reduction we got with Go 1.5 was worth celebrating, the best part of the new GC was that it set the stage for further incremental improvements.<br>Go 1.5’s garbage collector still has the same two major phases — a mark phase where the GC determines which memory allocations are still in use, and a sweep phase where the unused memory is prepared for reuse — but those have each been broken into two subphases. First, the application is paused while the previous sweep phase terminates. Then the concurrent mark phase finds in-use memory while the user code is running. Finally, the application is paused a second time for the mark phase to terminate. Afterwards, the unused memory is gradually swept while the application goes about its business.<br>The runtime’s gctrace feature prints lines summarizing each GC cycle, including the duration of each phase. For our chat server it indicates that most of the remaining pause time is in the mark termination phase, so the analysis will focus there. And since the runtime team has requested bug reports describing apps that still see long GC pauses, we’d be remiss to keep our long pause times a secret!<br>Of course, we’d need more detail on what exactly the GC was up to during those pauses. The Go core packages include a great user-level CPU profiler, but for this we’re going to use Linux’s perf tool. Using perf will allow a higher sample frequency and visibility into time spent in the kernel. Monitoring cycles spent in the kernel can help us debug slow syscalls and work done transparently for virtual memory management.<br>The image below is part of a profile of our chat server running with go1.5.1. This is a <a href="http://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html" target="_blank" rel="external">Flame Graph</a> made with <a href="http://sss.gnlnymzg.lnhtr.uk2.gsr.awhoer.net/brendangregg/FlameGraph" target="_blank" rel="external">Brendan Gregg’s tools</a>, trimmed to only include samples that have the runtime.gcMark function on the stack, which for Go 1.5 approximates time spent in the mark termination phase.</p>
<p><img src="flamegraph.png" alt=""></p>
<p>The flame graph shows stack depth as upwards growth, and represents CPU time as the width of each section. (The colors are meaningless, and the ordering on the x-axis is also insignificant — it’s just alphabetical.) At the very left of the chart we can see that runtime.gcMark is calling runtime.parfordo in nearly all of the sampled stacks. Moving upwards, we see that most time is spent in runtime.markroot making calls to runtime.scang, runtime.scanobject, and runtime.shrinkstack.<br>The runtime.scang function is for re-scanning memory to aid in terminating the mark phase. The whole idea behind the mark termination phase is to finish scanning the app’s memory, so this is the right type of work for it to be doing here. We’ll have better luck finding performance improvements in the other functions.<br>Next up is runtime.scanobject. That function does several things, but the reason it’s running during the chat server’s mark termination phase in Go 1.5 is to implement finalizers. “Why would the program use so many finalizers that they’d make a significant contribution to GC pause times?” you might wonder. The application in question is a chat server, handling hundreds of thousands of users. Go’s core “net” package attaches a finalizer to every TCP connection to help control file descriptor leaks — and since each user has their own TCP connection, even small contributions to mark termination add up.<br>That seemed worth reporting to the Go runtime team. We emailed back and forth and the Go team was very helpful with suggestions on how to diagnose the performance problems and how to distill them into minimal test cases. For Go 1.6, the runtime team moved finalizer scanning into the concurrent mark phase, leading to smaller pauses for apps with a large number of TCP connections. Together with all of the other improvements in the release, pause times for our chat server with Go 1.6 are half of what they were with Go 1.5, down to around 100ms on a test instance. Progress!</p>
<h2 id="Stack_shrinking">Stack shrinking</h2>
<p>Go’s approach to concurrency involves making it very cheap to have a large number of goroutines. While a program using 10,000 OS threads might perform poorly, that number of goroutines is nothing unusual. One difference is that a goroutine starts with a very small stack — only 2kB — which grows as needed, contrasted with the large fixed-size stacks that are common elsewhere. Go’s function call preamble makes sure there’s enough stack space for the next call, and if not will move the goroutine’s stack to a larger memory area — rewriting pointers as needed — before allowing the call to continue.<br>Thus as a program runs, its goroutines’ stacks will grow to support the deepest calls they make. One of the responsibilities of the garbage collector is to reclaim stack memory that’s no longer required. The task of moving goroutine stacks onto more appropriately-sized memory ranges is done by runtime.shrinkstack, which in Go 1.5 and 1.6 is done during mark termination while the app is paused.</p>
<p><img src="flamegraph2.png" alt=""></p>
<p>The above flame graph — recorded with a pre-1.6 version of Go from October 2015 — shows runtime.shrinkstack in around 3/4ths of its samples. If that work could be done while the app is running, it could give a big speedup to our chat server and other programs like it.<br>The Go runtime’s package docs explain how to disable stack shrinking. For our chat server, wasting some memory is a small price to pay for reduced GC pauses — and this is the decision we have when running Go 1.6. With stack shrinking disabled, the chat server’s pause times are cut in half again to somewhere between 30 and 70ms depending on which way the wind is blowing.<br>While keeping the structure and operations of the chat service relatively constant, we’d endured the multi-second GC pauses of Go 1.2 through 1.4. Go 1.5 brought them down to around 200ms, and Go 1.6 cut it further to around 100ms. Now with pauses generally less than 70ms, we can claim an improvement of more than 30x.<br>There’s probably still room for improvement; time for another profile!</p>
<h2 id="Page_faults?!">Page faults?!</h2>
<p>The GC pause times had been fairly consistent until this point, but now they are spread out over a wide range of durations (from 30 to 70ms), uncorrelated with any other gctrace output. Here’s a flame graph of cycles spent during some of the longer mark termination pauses:<br>When the Go GC calls runtime.gcRemoveStackBarriers the system generates a page fault, leading to a call to the kernel’s page_fault function, leading to the wide tower in the chart just right of center. Page faults are the kernel’s way of mapping a page of virtual memory (often 4kB) to a piece of physical RAM. Processes are often allowed to allocate huge amounts of virtual memory, which will be converted to resident memory through page faults only as it’s accessed by the program.<br>The runtime.gcRemoveStackBarriers function modifies stack memory, which should have been accessed recently by the program. In fact, its purpose is to remove stack barriers that were added at the beginning of the GC cycle just seconds earlier. The system has plenty of memory available — it didn’t assign the physical RAM to some other more active process — so why would this memory access lead to page faults?<br>Some background on our computing hardware might be helpful. The servers we use to run the chat system are modern dual-socket machines. Each CPU socket has a few directly-attached memory banks. This configuration results in NUMA, Non-Uniform Memory Access. When a thread runs on a core in socket 0, it will have faster access to the physical memory attached to that socket and moderately slower access to other memory. The Linux kernel tries to reduce this latency by running threads near the memory they use, and by moving physical memory pages to be close to where the relevant threads run.<br>With this in mind, we can take a closer look at the behavior of the kernel’s page_fault function. Looking deeper into the call stack (moving upwards on the flame graph) we can see the kernel calling do_numa_page and migrate_misplaced_page, indicating that the kernel is moving the program’s memory between physical memory banks.<br>The Linux kernel has picked up on the nearly-meaningless memory access patterns of the GC’s mark termination phase and is migrating memory pages — at great expense — to match it. This behavior shows up ever so slightly in the go1.5.1 flame graph, but it’s much more pronounced now that our attention is focused on runtime.gcRemoveStackBarriers.<br>This is where the benefit of profiling with perf is most apparent. The perf tool is able to show kernel stacks, while Go’s user-level profiler would have shown the Go function as mysteriously slow. Using perf is rather more complicated, requires root access for viewing kernel stacks, and for Go 1.5 and 1.6 requires a nonstandard build of the Go toolchain (via GOEXPERIMENT=framepointer ./make.bash, to be standard in Go 1.7). For problems like this one, it’s entirely worth it.</p>
<h2 id="Controlling_the_migrations">Controlling the migrations</h2>
<p>If using two CPU sockets and two memory banks is too complex, let’s try using just one. The bluntest instrument available for this is the taskset command, which can restrict a program to run only on cores on a single socket. Since the program’s threads only access memory from one socket, the kernel will move its memory to reside in that socket’s memory banks.</p>
<p><img src="flamegraph4.png" alt=""></p>
<p>After confining the program to a single NUMA node the app’s mark termination times went down to 10–15ms, a remarkable improvement from the 200ms seen with Go 1.5 or the 2-second pauses of Go 1.4. (The same benefit can be had without sacrificing half of the server by setting the memory policy of the process to MPOL_BIND via set_mempolicy(2) or mbind(2).) The above profile was taken with a pre-1.6 version of Go from October 2015. It shows considerable time in runtime.freeStackSpans on the left, which has since been moved to a concurrent GC phase and so no longer contributes to pause duration. There’s not much left in the mark termination phase to remove!</p>
<h2 id="Go_1-7">Go 1.7</h2>
<p>Up through Go 1.6, we managed the high cost of stack shrinking by disabling the feature for our program. That had a minimal impact on the chat server’s memory usage, but levied a much larger toll on operational complexity. Stack shrinking is very important for some programs, so instead of rolling the change out everywhere we only implemented it for a small set of applications. Go 1.7 now shrinks stacks concurrently while the application is running. We get the best of both worlds — low memory usage without any special tuning.<br>Since the introduction of its concurrent GC in Go 1.5, the runtime has kept track of whether a goroutine has executed since its stack was last scanned. The mark termination phase would check each goroutine to see whether it had recently run, and would rescan the few that had. In Go 1.7, the runtime maintains a separate short list of such goroutines. This removes the need to look through the entire list of goroutines while user code is paused, and greatly reduces the number of memory accesses that can trigger the kernel’s NUMA-related memory migration code.<br>Finally, the compilers for the amd64 architecture will maintain frame pointers by default, so standard debugging and performance tools like perf can determine the current function call stack. Users who build their programs with binary distributions of Go will be able pick up more advanced tools as they need them without having to dig into how to rebuild their Go toolchain and rebuild/redeploy their programs. This bodes well for future performance improvements to the Go core packages and runtime, as engineers like you and I will be able to collect the information we need for high-quality bug reports.<br>With pre-release Go 1.7 from June 2016, the GC pause times are better than ever with no manual tuning required. Typical pause times for our chat server are close to 1ms out of the box — a 10x improvement over the tuned Go 1.6 configuration!<br>Sharing our experiences with the Go team allowed them to find permanent solutions to the problems we’d encountered. Profiling and tuning gave our application a 10x improvement in pause time with Go 1.5 and 1.6, but between Go 1.5 and Go 1.7 the runtime team was able to turn that into a 100x improvement in pause time for all apps like ours. Hats off to their tireless work on Go’s runtime performance.</p>
<h2 id="What’s_next">What’s next</h2>
<p>All of this analysis has focused on our chat server’s bane — stop-the-world pause duration — but that’s only one dimension of GC performance. With the GC’s awkward pauses finally under control, the runtime team is poised to tackle throughput.<br>Their recent proposal for a <a href="https://golang.org/s/gctoc" target="_blank" rel="external">Transaction Oriented Collector</a> describes an approach to transparently provide inexpensive allocation and collection of memory that isn’t shared between goroutines. This can delay the need for a full GC run, and reduce the total number of CPU cycles that the program spends on garbage collection.<br>And of course, Twitch is hiring! If this sort of stuff interests you, <a href="https://engineering.twitch.tv/" target="_blank" rel="external">drop us a line</a>.</p>
<h2 id="Thank_you">Thank you</h2>
<p>I’d like to thank Chris Carroll and John Rizzo for their help with safely testing new Go versions on their chat system, and Spencer Nelson and Mike Ossareh for editing this post with me. I’d also like to thank the Go runtime team for helping me to file good bug reports and for their constant improvements to Go’s garbage collector.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是Twitch的<a href="https://blog.twitch.tv/@rhysh" target="_blank" rel="external">Rhys Hiltner</a>写的一篇关于Go垃圾回收监控的优秀文章，我前几天在reddit看到后就想翻译它。这几天也看到飞花无缺已经把它翻译整理了：<a href="http://blog.csdn.net/erlib/article/details/51850912" target="_blank" rel="external">为Go语言GC正名－2秒到1毫秒的演变史</a>，所以我就不翻译了，因为这篇文章被墙了，我就把原文转帖在这里。</p>
<p>这篇文章有几个值得我们学习的地方。一是提供了Go各个版本在产品级大并发情况(50万并发用户)的垃圾回收器的改进效果，二是对Go的垃圾回收的监控分析手段，主要通过<a href="http://sss.gnlnymzg.lnhtr.uk2.gsr.awhoer.net/brendangregg/FlameGraph" target="_blank" rel="external">Brendan Gregg’s tools</a>火炬图这个工具分析方法的耗时。</p>
<p><img src="/2016/07/13/gos-march-to-low-latency-gc/flamegraph.png" alt=""></p>
<p>以下是文章原文。</p>
]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入Go语言 - 13]]></title>
    <link href="http://colobu.com/2016/07/09/dive-into-go-13/"/>
    <id>http://colobu.com/2016/07/09/dive-into-go-13/</id>
    <published>2016-07-09T09:16:26.000Z</published>
    <updated>2016-07-11T06:46:34.000Z</updated>
    <content type="html"><![CDATA[<p>本章重点介绍Go语言中的反射。<br>包<a href="https://golang.org/pkg/reflect/" target="_blank" rel="external">reflect</a>可以实现运行时的反射，允许程序操纵对象的值和类型。<br>典型地，你可以获取 interface{}的动态类型以及的它的值和方法。</p>
<p>Go是静态类型的语言，每一个对象在声明和初始化的时候都已经有一个确定值，即使是声明为接口类型的变量，它的静态类型也已经确定，即使任何包含这个接口方法集的类型的对象都可以赋值给它。</p>
<p>我们可以在运行时获取对象的动态类型和值。</p>
<p>类型Type和值Value是我们使用发射库的主要用的两个概念。</p>
<a id="more"></a>
<h3 id="Type">Type</h3>
<p><code>Type</code>是一个interface,代表Go中的一个类型，可以把它看成某个类型的元数据(描述类型的类型)，这个类型既可以是Go语言或者库中定义的type类型，也可以你自己定义的type类型。</p>
<p>下面我们介绍它的主要方法以及一些辅助方法。</p>
<p>值得注意的是，并不是所有的方法都对某种类型有效，比如有些方法只对函数类型有意义，有的只对Struct有意义。如果对某个类型调用了错误的方法，则会发生运行时的panic，比如针对struct Type，调用<code>IsVariadic</code>方法。所以最好先判断一下Type的Kind。</p>
<p>首先我们先为下面的例子定义一个简单的struct用来测试, Bird有三个字段Field和三个方法，其中两个字段和两个方法是导出的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Bird <span class="keyword">struct</span> {</div><div class="line">	Name  <span class="typename">string</span></div><div class="line">	Color <span class="typename">string</span></div><div class="line">	age   <span class="typename">int</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (b Bird) Sing() <span class="typename">string</span> {</div><div class="line">	<span class="keyword">return</span> <span class="string">"sing"</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (b *Bird) Fly() <span class="typename">string</span> {</div><div class="line">	<span class="keyword">return</span> <span class="string">"fly"</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (b *Bird) food() {</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>TypeOf</code>返回一个接口对象的动态类型，也就是类型<code>reflect.Type</code>的一个值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bird = Bird{Name: <span class="string">"parrot"</span>, Color: <span class="string">"blue"</span>}</div><div class="line"><span class="keyword">var</span> t reflect.Type</div><div class="line">t = reflect.TypeOf(bird)</div></pre></td></tr></table></figure>

<ul>
<li><strong>Name</strong>、<strong>PkgPath</strong>、<strong>String</strong><br>返回动态类型的名称，包名以及字符串表示。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fmt.Println(t.Name()) <span class="comment">//Bird</span></div><div class="line">fmt.Println(t.String()) <span class="comment">//main.Bird</span></div><div class="line">fmt.Println(t.PkgPath()) <span class="comment">//main</span></div></pre></td></tr></table></figure>

<p>Name返回类型名，如Bird,对于未定义名称的类型，返回空字符串。</p>
<p>PkgPath返回包名，代表这个包的唯一标识符，所以可能是单一的包名，或者<code>encoding/base64</code>。对于Go内置的类型string,error等，或者未定义名称的类型struct{}等，则返回空字符串。</p>
<p>String方法返回这个类型的字符串表示，包名可能用简写表示。</p>
<ul>
<li><strong>Kind</strong><br>返回类型的分类。 你自己定义的类型必定属于下面的某一类：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> (</div><div class="line">        Invalid Kind = <span class="constant">iota</span></div><div class="line">        Bool</div><div class="line">        Int</div><div class="line">        Int8</div><div class="line">        Int16</div><div class="line">        Int32</div><div class="line">        Int64</div><div class="line">        Uint</div><div class="line">        Uint8</div><div class="line">        Uint16</div><div class="line">        Uint32</div><div class="line">        Uint64</div><div class="line">        Uintptr</div><div class="line">        Float32</div><div class="line">        Float64</div><div class="line">        Complex64</div><div class="line">        Complex128</div><div class="line">        Array</div><div class="line">        Chan</div><div class="line">        Func</div><div class="line">        Interface</div><div class="line">        Map</div><div class="line">        Ptr</div><div class="line">        Slice</div><div class="line">        String</div><div class="line">        Struct</div><div class="line">        UnsafePointer</div><div class="line">)</div></pre></td></tr></table></figure>

<p>例如:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fmt.Println(t.Kind()) <span class="comment">//struct</span></div></pre></td></tr></table></figure>

<ul>
<li><strong>Size</strong>、<strong>Bits</strong>、<strong>Align</strong>、<strong>FieldAlign</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">	fmt.Println(t.Size()) <span class="comment">//40</span></div><div class="line">	<span class="comment">//fmt.Println(t.Bits())       //panic</span></div><div class="line">	fmt.Println(t.Align())      <span class="comment">//8</span></div><div class="line">	fmt.Println(t.FieldAlign()) <span class="comment">//8</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>Size</code>返回存储这个类型的一个值所需要的字节数，它返回要保存储这个值需要的内存，而不会计算它引用的内存的大小。 比如字符串是以<code>StringHeader</code>类型来存储的，它包含一个指针指向内存字符存储的数据，它的size只计算存储这个结构所需的内存，而不会计算指针指向的数据占用的字节数的，数据会对齐的。</p>
<p><code>Bits</code>返回类型的size，以bit计算，但是如果类型不是Int、Uint、Float、Complex之一则panic。</p>
<p><code>Algin</code>是这个类型的一个变量在内存中的对齐后的所用的字节数。<code>FieldAlign</code>指这种类型的变量如果是struct中的字段，那么它对齐后所用的字节数。</p>
<p>对于gc编译器来讲,<code>Align</code>和<code>FieldAlign</code>是一样的，但是对于gccgo来讲，它们可能不同。</p>
<p>还有下面会讲到的<code>reflect.StructField.Offset</code>,它是某个字段在struct中的偏移量，一起考虑了前面字段的对齐。</p>
<blockquote>
<p><em>为什么要对齐?</em><br>第一个原因——很多CPU只从对齐的地址开始加载数据，而有的CPU这样做，只是更快一点。<br>第二个原因——外部总线从内存一次获取的数据往往不是1byte，而是4bytes或许8bytes,或者更多~~<br>引子<a href="http://www.zhihu.com/question/23791224" target="_blank" rel="external">知乎</a></p>
</blockquote>
<p>注意<code>Size</code>是值占用的字节数，而<code>Align</code>是变量占的字节数。</p>
<p>比如在我当前的开发环境下(64-bit windows 10), 字符串的<code>Size</code>为16个字节，而字符串的<code>Align</code>为8, int类型的<code>Size</code>和<code>Align</code>都是8, int32的<code>Size</code>和<code>Align</code>都是4。</p>
<ul>
<li><strong>Implements</strong>、<strong>AssignableTo</strong>、<strong>ConvertibleTo</strong>、<strong>Comparable</strong></li>
</ul>
<p><code>Implements</code>返回类型是否实现了某个接口,如果参数的类型不是interface类型，则会panic。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> r *io.Reader</div><div class="line">t1 := reflect.TypeOf(r).Elem()</div><div class="line">t2 := reflect.TypeOf(&os.Stdout).Elem()</div><div class="line"></div><div class="line">fmt.Println(t.Implements(t1))  <span class="comment">//false</span></div><div class="line">fmt.Println(t2.Implements(t1)) <span class="comment">//true</span></div></pre></td></tr></table></figure>

<p><code>AssignableTo</code>一个类型的值是否可以赋值给参数指定的类型,下面的例子中Bird类型的指针对象可以赋值给IBird接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> IBird <span class="keyword">interface</span> {</div><div class="line">	Sing() <span class="typename">string</span></div><div class="line">	Fly() <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> i IBird = &bird</div><div class="line">fmt.Println(t.AssignableTo(reflect.TypeOf(i).Elem()))</div></pre></td></tr></table></figure>

<p><code>ConvertibleTo</code> 一个类型的值是否可以转换成另一个类型的值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Bird2 Bird</div><div class="line"><span class="keyword">var</span> bird2 Bird2</div><div class="line">t3 := reflect.TypeOf(bird2)</div><div class="line">fmt.Println(t3.ConvertibleTo(t)) <span class="comment">//true</span></div><div class="line">bird = Bird(bird2)               <span class="comment">//可以转换</span></div></pre></td></tr></table></figure>

<p><code>Comparable</code>返回类型是否可以比较：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fmt.Println(t.Comparable()) <span class="comment">//true</span></div></pre></td></tr></table></figure>

<p>类型如果可以比较，就可以使用<code>==</code>、<code>!=</code>运算符。可以参看 <a href="http://colobu.com/2016/06/20/dive-into-go-5/#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6" target="_blank" rel="external">比较运算符</a>。</p>
<ul>
<li><strong>NumField</strong>、<strong>Field</strong>、<strong>FieldByIndex</strong>、<strong>FieldByName</strong>、<strong>FieldByNameFunc</strong><br>这一组方法用来获取Struct的Field的信息，这个信息通过StructField类型来描述。如果类型不是Struct,调用相应的方法导致运行时panic。</li>
</ul>
<p><code>NumField</code>返回Struct的字段的数量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fmt.Println(t4.NumField()) <span class="comment">//1</span></div></pre></td></tr></table></figure>

<p><code>Field</code>返回struct的第i个字段的信息，包括未导出对象的信息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fmt.Println(t.Field<span class="number">(0</span>)) <span class="comment">//{Name  string  0 [0] false}</span></div><div class="line">fmt.Println(t.Field<span class="number">(1</span>)) <span class="comment">//{Color  string  16 [1] false}</span></div><div class="line">fmt.Println(t.Field<span class="number">(2</span>)) <span class="comment">//{age github.com/smallnest/dive-into-go/ch12/model int  32 [2] false}</span></div></pre></td></tr></table></figure>

<p><code>FieldByIndex</code>对于嵌套的Struct,可以递归地得到某一层的字段的信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> S1 <span class="keyword">struct</span> {</div><div class="line">		Name <span class="typename">string</span></div><div class="line">		Age  <span class="typename">int</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">type</span> S2 <span class="keyword">struct</span> {</div><div class="line">		S1</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">type</span> S3 <span class="keyword">struct</span> {</div><div class="line">		S2</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">var</span> s S3</div><div class="line">	t4 := reflect.TypeOf(s)</div><div class="line">	fmt.Println(t4.FieldByIndex([]<span class="typename">int</span><span class="number">{0</span>,<span class="number"> 0</span>,<span class="number"> 1</span>})) <span class="comment">//{Age  int  16 [1] false}</span></div></pre></td></tr></table></figure>

<p>这个例子S3嵌套S2，S2嵌套S1,我们通过0,0,1就可以得到S1的字段Age的信息。</p>
<p><code>FieldByName</code>根据名称得到字段的信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fmt.Println(t4.FieldByName(<span class="string">"Name"</span>)) <span class="comment">//{Name  string  0 [0 0 0] false} true</span></div></pre></td></tr></table></figure>

<p><code>FieldByNameFunc</code>根据一个函数筛选字段，返回第一个符合条件的字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fmt.Println(t4.FieldByNameFunc(<span class="keyword">func</span>(n <span class="typename">string</span>) <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">if</span> n == <span class="string">"Age"</span> {</div><div class="line">		<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">}))</div></pre></td></tr></table></figure>

<ul>
<li><strong>NumMethod</strong>、<strong>Method</strong>、<strong>MethodByName</strong>、<br>这是一组操作类型的方法的一组方法。</li>
</ul>
<p>对于非接口的类型T或者*T,它的方法类型和函数字段描述了方法的第一个参数就是receiver。</p>
<p>对于接口类型，它的方法类型的Func字段总是为nil。</p>
<p><code>NumMethod</code>返回这个类型的方法集中方法的数量, <code>Method</code>返回第i个方法的信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fmt.Println(t.NumMethod())  <span class="comment">//1</span></div><div class="line">fmt.Println(t.Method<span class="number">(0</span>))    <span class="comment">//{Sing  func(model.Bird) string &lt;func(model.Bird) string Value&gt; 0}</span></div><div class="line">t5 := reflect.TypeOf(&bird)</div><div class="line">fmt.Println(t5.NumMethod()) <span class="comment">//3</span></div><div class="line">fmt.Println(t5.Method<span class="number">(0</span>)) <span class="comment">//{Fly  func(*model.Bird) string &lt;func(*model.Bird) string Value&gt; 0}</span></div><div class="line">fmt.Println(t5.Method<span class="number">(1</span>)) <span class="comment">//{Sing  func(*model.Bird) string &lt;func(*model.Bird) string Value&gt; 1}</span></div><div class="line">fmt.Println(t5.Method<span class="number">(2</span>)) <span class="comment">//{food github.com/smallnest/dive-into-go/ch12/model func(*model.Bird) &lt;func(*model.Bird) Value&gt; 2}</span></div></pre></td></tr></table></figure>

<p><code>MethodByName</code>则是根据名称查找方法。</p>
<ul>
<li><strong>NumIn</strong>、<strong>In</strong>、<strong>NumOut</strong>、<strong>Out</strong>、<strong>IsVariadic</strong><br>对于函数类型，我们关注的是它的输入参数信息<code>Int</code>和输出参数信息<code>Out</code>。<br><code>IsVariadic</code>返回函数是否是变参的。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">f := http.ListenAndServe</div><div class="line">ft := reflect.TypeOf(f)</div><div class="line">fmt.Println(ft.NumIn())  <span class="comment">//2</span></div><div class="line">fmt.Println(ft.In<span class="number">(0</span>))    <span class="comment">//string</span></div><div class="line">fmt.Println(ft.NumOut()) <span class="comment">//1</span></div><div class="line">fmt.Println(ft.Out<span class="number">(0</span>))   <span class="comment">//error</span></div><div class="line">fmt.Println(ft.IsVariadic()) <span class="comment">//false</span></div></pre></td></tr></table></figure>

<ul>
<li><strong>Key</strong><br><code>Key</code>方法返回map类型的key的类型，如果不是map类型，则调用此方法会panic。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span></div><div class="line">mt := reflect.TypeOf(m)</div><div class="line">fmt.Println(mt.Key())</div></pre></td></tr></table></figure>

<ul>
<li><strong>Elem</strong><br><code>Elem</code>方法返回类型 Array, Chan, Map, Ptr,  Slice的元素的类型。</li>
</ul>
<p>对于Map类型，它返回的值的类型。</p>
<p>对于指针类型Ptr，它返回指针指向的元素的类型。</p>
<p>对于Chan,它返回传递的元素的类型。</p>
<p>数组和Slice返回的是它包含的元素的类型。</p>
<ul>
<li><p><strong>Len</strong><br><code>Len</code>返回数组的长度，因为数组的类型中包含长度的定义。如果不是数组则会panic。</p>
</li>
<li><p><strong>ChanDir</strong><br>返回channel的方向, chan、chan&lt;-、&lt;-chan</p>
</li>
</ul>
<h3 id="Value">Value</h3>
<p>Value描述对象的值信息，同样，并不是所有的方法对任何的类型都有意义，特定的方法只适用于特定的类型。</p>
<p>零值代表没有值，它的<code>IsValid</code>总是返回false，它的<code>Kind</code>总是返回Invalid，它的String总是返回&quot;<invalid value="">&quot;。</invalid></p>
<p>A Value can be used concurrently by multiple goroutines provided that the underlying Go value can be used concurrently for the equivalent direct operations.</p>
<p>Using == on two Values does not compare the underlying values they represent, but rather the contents of the Value structs. To compare two Values, compare the results of the Interface method.</p>
<p>本文中不准备详细阐述Value对象的方法。不是这些方法不重要，而是它的方法太多了。</p>
<p>它针对每一中类型的操作都提供了相应的方法，比如slice类型，有Append、AppendSlice等方法、Map有MapIndex、MapKeys等方法、Struct有Field、FieldByIndex等方法。 注意Value的Field方法返回的是字段的值类型Value,而不是字段的类型描述Type。还有针对数值型、Bool型、Channel类型的方法等。</p>
<p><code>Indirect</code>返回指针指向的对象，如果不是指针，则返回参数本身。</p>
<p><code>Addr</code>返回一个可寻址的对象的指针。 只有slice的元素、可寻址的数组的元素、可寻址的struct的字段、指针的可寻址的结果才可以调用Addr方法。可以通过<code>CabAddr</code>检查。可以查看Go规范中的描述:<a href="https://golang.org/ref/spec#Address_operators" target="_blank" rel="external">Address operators</a>。</p>
<p><code>Zero</code>返回类型的零值。</p>
<p>一组SetXxx方法用来设置值的值(好绕口)。</p>
<p>下面是一组辅助函数，生成Value对象：<br><code>MakeChan</code>、<code>MakeFunc</code>、<code>MakeMap</code>、<code>MakeSlice</code>、<code>New</code>、<code>NewAt</code>生成某个类型的值Value。<br><code>ValueOf</code>从接口对象返回Value。</p>
<h3 id="转换">转换</h3>
<p>1、 从接口对象到反射对象</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x <span class="typename">float64</span> =<span class="number"> 3.4</span></div><div class="line">  fmt.Println(<span class="string">"type:"</span>, reflect.TypeOf(x))</div><div class="line">fmt.Println(<span class="string">"value:"</span>, reflect.ValueOf(x))</div></pre></td></tr></table></figure>

<p>2、从反射对象到接口对象</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (v Value) Interface() <span class="keyword">interface</span>{}</div></pre></td></tr></table></figure>

<p>如果想转为特定的类型的对象,可以用type assertion：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">y := v.Interface().(<span class="typename">float64</span>)</div></pre></td></tr></table></figure>

<p>3、修改反射对象<br>对象的值必须是可设置的,可以用CanSet方法判断。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x <span class="typename">float64</span> =<span class="number"> 3.4</span></div><div class="line">p := reflect.ValueOf(&x)</div><div class="line">v := p.Elem()</div><div class="line">v.SetFloat<span class="number">(7.1</span>)</div><div class="line">fmt.Println(v.Interface())</div><div class="line">fmt.Println(x)</div></pre></td></tr></table></figure>

<p>也有一些第三方的简化go reflect的库，如<a href="https://github.com/tkrajina/go-reflector" target="_blank" rel="external">go-reflector</a>。</p>
<p>反射经常用在序列化和反序列的实现中，如官方的<a href="https://golang.org/src/encoding/json/decode.go" target="_blank" rel="external">json</a>、<a href="https://golang.org/src/encoding/xml/marshal.go" target="_blank" rel="external">xml</a>库。</p>
<p>但是请记住一点，发射的性能并不高，所以很多序列化库采用代码模版的方式生成Model对象，而不是反射的方式序列化和反序列化对象。</p>
<p>参考</p>
<ul>
<li><a href="http://blog.golang.org/laws-of-reflection" target="_blank" rel="external">http://blog.golang.org/laws-of-reflection</a></li>
<li><a href="http://golang.org/pkg/reflect/" target="_blank" rel="external">http://golang.org/pkg/reflect/</a></li>
<li><a href="http://research.swtch.com/interfaces" target="_blank" rel="external">http://research.swtch.com/interfaces</a></li>
<li><a href="http://my.oschina.net/tongjh/blog/513540" target="_blank" rel="external">http://my.oschina.net/tongjh/blog/513540</a></li>
<li><a href="http://blog.altoros.com/golang-internals-part-6-bootstrapping-and-memory-allocator-initialization.html" target="_blank" rel="external">http://blog.altoros.com/golang-internals-part-6-bootstrapping-and-memory-allocator-initialization.html</a></li>
<li><a href="http://grokbase.com/t/gg/golang-nuts/153kv99728/go-nuts-how-to-use-reflect-type-implements" target="_blank" rel="external">http://grokbase.com/t/gg/golang-nuts/153kv99728/go-nuts-how-to-use-reflect-type-implements</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>本章重点介绍Go语言中的反射。<br>包<a href="https://golang.org/pkg/reflect/" target="_blank" rel="external">reflect</a>可以实现运行时的反射，允许程序操纵对象的值和类型。<br>典型地，你可以获取 interface{}的动态类型以及的它的值和方法。</p>
<p>Go是静态类型的语言，每一个对象在声明和初始化的时候都已经有一个确定值，即使是声明为接口类型的变量，它的静态类型也已经确定，即使任何包含这个接口方法集的类型的对象都可以赋值给它。</p>
<p>我们可以在运行时获取对象的动态类型和值。</p>
<p>类型Type和值Value是我们使用发射库的主要用的两个概念。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转]系统之锹sysdig：Linux服务器监控和排障利器]]></title>
    <link href="http://colobu.com/2016/07/07/monitor-troubleshoot-linux-server-sysdig/"/>
    <id>http://colobu.com/2016/07/07/monitor-troubleshoot-linux-server-sysdig/</id>
    <published>2016-07-07T10:01:32.000Z</published>
    <updated>2016-07-07T07:11:27.000Z</updated>
    <content type="html"><![CDATA[<p>中文编译地址：<a href="https://linux.cn/article-4341-1.html" target="_blank" rel="external">https://linux.cn/article-4341-1.html</a> by GOLinux<br>英文原文地址：<a href="http://xmodulo.com/monitor-troubleshoot-linux-server-sysdig.html" target="_blank" rel="external">http://xmodulo.com/monitor-troubleshoot-linux-server-sysdig.html</a>  作者： Gabriel Cánepa</p>
<p>当你需要追踪某个进程产生和接收的系统调用时，首先浮现在你脑海中的是什么？你可能会想到strace，那么你是对的。你会使用什么样的命令行工具来监控原始网络通信呢？如果你想到了tcpdump，你又作出了一个极佳的选择。而如果你碰到必须追踪打开的文件（在Unix意义上：一切皆文件）的需求，可能你会使用lsof。</p>
<p>strace、tcpdump以及lsof，确实是些伟大的工具，它们应该成为每个系统管理员工具集之中的一部分，而这也正是你为什么应该爱上sysdig的原因。它是一个强大的开源工具，用于系统级别的勘察和排障，它的创建者在介绍它时称之为“strace+tcpdump+lsof+上面点缀着lua樱桃的绝妙酱汁”。抛开幽默不说，sysdig的最棒特性之一在于，它不仅能分析Linux系统的“现场”状态，也能将该状态保存为转储文件以供离线检查。更重要的是，你可以自定义sysdig的行为，或者甚至通过内建的（你也可以自己编写）名为凿子（chisel）的小脚本增强其功能。单独的凿子可以以脚本指定的各种风格分析sysdig捕获的事件流。</p>
<p>在本教程中，我们将探索sysdig的安装及其基本用法，在Linux上实施系统监控和排障。<br><a id="more"></a></p>
<h3 id="安装Sysdig">安装Sysdig</h3>
<p>对于本教程，由于为了简便、缩短安装流程以及版本的不可知，我们将选择使用官方网站提供的自动化安装过程。在自动化过程中，安装脚本会自动检测操作系统并安装必需的依赖包。</p>
<p>以root身份运行以下命令来从官方apt/yum仓库安装sysdig：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># curl -s https://s3.amazonaws.com/download.draios.com/stable/install-sysdig | bash</span></div></pre></td></tr></table></figure>

<p><img src="1.jpg" alt=""></p>
<p>安装完成后，我们可以通过以下方法调用sysdig来感受一下它：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># sysdig</span></div></pre></td></tr></table></figure>

<p>我们的屏幕将马上被系统上发生的所有事件填满，对于这些信息，不便于我们做更多操作。要进一步处理，我们可以运行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># sysdig -cl | less</span></div></pre></td></tr></table></figure>

<p>来查看可用的凿子列表。<br><img src="2.jpg" alt=""></p>
<p>默认有以下类目可用，各个类目中分布有多个内建的凿子。</p>
<ul>
<li>CPU Usage：CPU使用量</li>
<li>Errors：错误</li>
<li>I/O</li>
<li>Logs：日志</li>
<li>Misc：混杂</li>
<li>Net：网络</li>
<li>Performance：性能</li>
<li>Security：安全</li>
<li>System State：系统状态</li>
</ul>
<p>要显示指定凿子上的信息（包括详细的命令行用法），运行以下命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># sysdig -cl [凿子名称]</span></div></pre></td></tr></table></figure>

<p>例如，我们可以检查“网络”类目下关于spy_port凿子的信息：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># sysdig -i spy_port</span></div></pre></td></tr></table></figure>

<p><img src="3.jpg" alt=""></p>
<p>凿子可以通过过滤器（可同时应用于实时数据和记录文件）组合，以获取更多有用的输出。</p>
<p>过滤器遵从“类.字段”结构。例如：</p>
<ul>
<li>fd.cip：客户端IP地址。</li>
<li>evt.dir：事件方向，可以是‘&gt;’用于进入事件，或‘&lt;’用于退出事件。</li>
</ul>
<p>完整的过滤器列表可以通过以下命令显示：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># sysdig -l</span></div></pre></td></tr></table></figure>

<p>在本教程剩余部分，我将演示几个sysdig的使用案例。</p>
<h3 id="Sysdig实例：_服务器性能排障">Sysdig实例： 服务器性能排障</h3>
<p>假定你的服务器发生了性能问题（如，没有回应，或者重大的回应延迟）。你可以使用瓶颈凿子来显示当前10个最慢系统调用的列表。</p>
<p>使用以下命令在存活服务器上进行实时检查。“-c”标识，后跟凿子名称告诉sysdig运行指定的凿子。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># sysdig -c bottlenecks</span></div></pre></td></tr></table></figure>

<p>或者，你可以离线对服务器实施性能分析。在此种情况下，你可以保存完整的sysdig记录到文件，然后像下面这样针对记录运行瓶颈凿子。</p>
<p>首先，保存sysdige记录（使用Ctrl+c来停止收集）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># sysdig -w trace.scap</div></pre></td></tr></table></figure>

<p>收集完记录后，你可以运行以下命令来检查捕获间隔中最慢的系统调用：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># sysdig -r trace.scap -c bottlenecks</span></div></pre></td></tr></table></figure>

<p><img src="4.jpg" alt=""></p>
<p>你需要关注栏#2，#3和#4，这些分别表示执行时间、进程名和PID。</p>
<h3 id="Sysdig实例：_监控交互用户活动">Sysdig实例： 监控交互用户活动</h3>
<p>假定你作为系统管理员想要监控系统中交互的用户活动（如，用户在命令行输入了什么命令，以及用户去了什么目录），这时spy_user凿子就派上用场了。</p>
<p>让我们首先通过一些额外选项来收集一个sysdig记录。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># sysdig -s 4096 -z -w /mnt/sysdig/$(hostname).scap.gz</span></div></pre></td></tr></table></figure>

<ul>
<li>“-s 4096”告诉sysdig每个事件捕获4096字节。</li>
<li>“-z” （与“-w”一起使用）为记录文件启用压缩。</li>
<li>“-w ”保存sysdig记录到指定的文件。<br>在上面的例子中，我们自定义了基于每个主机的压缩的记录文件的名称。记住，你可以在任何时候按下Ctrl+c来打断sysdig的执行。</li>
</ul>
<p>在我们收集到了合理数量的数据后，我们可以通过运行以下命令来查看每个用户的交互活动：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># sysdig -r /mnt/sysdig/debian.scap.gz -c spy_users</span></div></pre></td></tr></table></figure>

<p><img src="5.jpg" alt=""></p>
<p>上面输出的第一栏表示与指定用户的活动相关进程的PID。</p>
<p>如果你想要定位一个指定的用户，以及只监控该用户的活动又怎么样呢？你可以通过用户名对spy_users凿子的结果进行过滤：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># sysdig -r /mnt/sysdig/debian.scap.gz -c spy_users "user.name=xmodulo"</span></div></pre></td></tr></table></figure>

<p><img src="6.jpg" alt=""></p>
<h3 id="Sysdig实例：_监控文件I/O">Sysdig实例： 监控文件I/O</h3>
<p>我们可以使用“-p”标识来自定义sysdig记录的输出格式，并指定双引号括起来的想要的字段（如用户名、进程名，以及文件或套接口名称）。在本例中，我们将创建一个记录文件，该文件将只包含在家目录中的写入事件（我们今后可以使用“sysdig -r writetrace.scap.gz”来检测该文件）。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># sysdig -p "%user.name %proc.name %fd.name" "evt.type=write and fd.name contains /home/" -z -w writetrace.scap.gz</span></div></pre></td></tr></table></figure>

<p><img src="7.jpg" alt=""></p>
<h3 id="Sysdig实例：_监控网络I/O">Sysdig实例： 监控网络I/O</h3>
<p>作为服务器排障的一部分，你可能想要监听网络通信，此工作通常由tcpdump做。对于sysdig，可以很容易进行通信嗅探，其风格更为对用户友好。</p>
<p>例如，你可以检查由特定IP地址，特定进程（如apache2）提供的数据（ASCII编码格式）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># sysdig -s 4096 -A -c echo_fds fd.cip=192.168.0.100 -r /mnt/sysdig/debian.scap.gz proc.name=apache2</span></div></pre></td></tr></table></figure>

<p>如果你想要监控原生数据传输（二进制格式），请把“-A”替换为“-X”：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># sysdig -s 4096 -X -c echo_fds fd.cip=192.168.0.100 -r /mnt/sysdig/debian.scap.gz proc.name=apache2</span></div></pre></td></tr></table></figure>

<p>要获取更多信息、实例以及案例分析，你可以查阅项目网站。相信我，会有着无限可能，但请不要仅仅局限于我所写的这些。安装sysdig，请从今天开始深入挖掘吧！</p>
<p>其它参考文档：</p>
<ul>
<li><a href="http://www.csdn.net/article/2015-11-08/2826147" target="_blank" rel="external">容器周边开源工具新秀：Sysdig和Calico</a></li>
<li><a href="http://os.51cto.com/art/201511/496024.htm" target="_blank" rel="external">功能强大的系统工具Sysdig命令实例介绍</a></li>
<li><a href="https://yq.aliyun.com/articles/57138" target="_blank" rel="external">DockerCon 2016 深度解读：Docker监控厂商之Sysdig</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>中文编译地址：<a href="https://linux.cn/article-4341-1.html" target="_blank" rel="external">https://linux.cn/article-4341-1.html</a> by GOLinux<br>英文原文地址：<a href="http://xmodulo.com/monitor-troubleshoot-linux-server-sysdig.html" target="_blank" rel="external">http://xmodulo.com/monitor-troubleshoot-linux-server-sysdig.html</a>  作者： Gabriel Cánepa</p>
<p>当你需要追踪某个进程产生和接收的系统调用时，首先浮现在你脑海中的是什么？你可能会想到strace，那么你是对的。你会使用什么样的命令行工具来监控原始网络通信呢？如果你想到了tcpdump，你又作出了一个极佳的选择。而如果你碰到必须追踪打开的文件（在Unix意义上：一切皆文件）的需求，可能你会使用lsof。</p>
<p>strace、tcpdump以及lsof，确实是些伟大的工具，它们应该成为每个系统管理员工具集之中的一部分，而这也正是你为什么应该爱上sysdig的原因。它是一个强大的开源工具，用于系统级别的勘察和排障，它的创建者在介绍它时称之为“strace+tcpdump+lsof+上面点缀着lua樱桃的绝妙酱汁”。抛开幽默不说，sysdig的最棒特性之一在于，它不仅能分析Linux系统的“现场”状态，也能将该状态保存为转储文件以供离线检查。更重要的是，你可以自定义sysdig的行为，或者甚至通过内建的（你也可以自己编写）名为凿子（chisel）的小脚本增强其功能。单独的凿子可以以脚本指定的各种风格分析sysdig捕获的事件流。</p>
<p>在本教程中，我们将探索sysdig的安装及其基本用法，在Linux上实施系统监控和排障。<br>]]>
    
    </summary>
    
      <category term="运维" scheme="http://colobu.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入Go语言 - 12]]></title>
    <link href="http://colobu.com/2016/07/06/dive-into-go-12/"/>
    <id>http://colobu.com/2016/07/06/dive-into-go-12/</id>
    <published>2016-07-06T10:31:12.000Z</published>
    <updated>2016-07-07T05:34:31.000Z</updated>
    <content type="html"><![CDATA[<p>本章介绍Go语言的代码的测试、性能测试以及示例的写法。</p>
<a id="more"></a>
<h3 id="测试">测试</h3>
<p>虽然也有一些第三方的基于某种概念开发的测试库，但是我觉得最好用还是官方的测试库: <a href="https://golang.org/pkg/testing/" target="_blank" rel="external">testing</a>。</p>
<p>常规地，我们会把测试代码的文件和正式的代码文件放在同一个文件夹下，但是包含测试代码的文件应该以&quot;_test.go&quot;结尾。</p>
<p>测试文件的包名可以和正式文件的包名相同，也可以不同。比如正式的报名为<code>abc</code>，测试的报名就可以是<code>abc_test</code>，但是不能是其它的，比如<code>xyz</code>。<br>这两种风格官方库中都有。一般来说和正式的包名相同的话，我们就可以进行白盒测试，可以直接调用包下的未导出的方法，包名不同则进行黑盒测试。根据 &quot;The Go programming language&quot;一书的介绍，这种方案还可以避免循环依赖的问题。</p>
<p>测试的文件名不能以下划线或者<code>.</code>开始，这些文件不会被<code>go test</code>包含进来。</p>
<p>测试的方法名有特殊的定义，以&quot;Test&quot;开头，并且参数为<code>*testing.T</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> TestXxx(*testing.T)</div></pre></td></tr></table></figure>

<p>Xxx可以是任意的alphanumeric字符串，但是首字母X不能是[a-z]中的字符，<code>Testxyz</code>就不是一个测试函数，但是<code>Test123</code>就是。</p>
<p>很多语言比如Java中的Junit、testng都提供了<code>assertion</code>辅助函数，可以方便的判定测试结果是否和期望的结果是否一致，但是Go官方并没有提供，而且是有意为之，说是避免让程序员犯懒。有地方库提供了相应的功能，比如<a href="https://godoc.org/github.com/stretchr/testify/assert" target="_blank" rel="external">testify/assert</a>。</p>
<p>如果测试结果不是你所期望的，你可以调用<code>Fail</code>、<code>Error</code>等方法触发失败信号。</p>
<p>正常编译的时候测试文件会被排除在外，但是调用<code>go test</code>测试的时候会包含进来。</p>
<p>通过<code>Skip</code>方法可以掉过测试：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> TestTimeConsuming(t *testing.T) {</div><div class="line">    <span class="keyword">if</span> testing.Short() {</div><div class="line">        t.Skip(<span class="string">"skipping test in short mode."</span>)</div><div class="line">    }</div><div class="line">    ...</div><div class="line">}</div></pre></td></tr></table></figure>

<p>完整的测试命令如下：<br><code>go test [build/test flags] [packages] [build/test flags &amp; test binary flags]</code></p>
<p>不带任何参数的时候，它会编译和测试包下的所有的源文件。</p>
<p>除了<code>build flag</code>，test还会额外的处理几个编译flag: <code>-args</code>、<code>-c</code>、<code>-exec xprog</code>、<code>-i</code>、<code>-o file</code>。</p>
<p><code>packages</code>可以是绝对路径、相对路径(.或..)或者只是一个包名(go会在GOPATH环境变量的列表中查找DIR/src/P，假设DIR在环境变量定义的文件列表中， P为包名)。<code>...</code>可以模糊匹配字符串，比如<code>x/...</code>匹配x及x的子文件夹。 <code>go help packages</code>会给出详细的介绍。</p>
<p><code>build flag</code>包含很多的flag,一般我们都不会加这些flag,如果你想了解，可以看<a href="https://golang.org/cmd/go/#hdr-Compile_packages_and_dependencies" target="_blank" rel="external">官方文档</a>。</p>
<p>官方文档的<a href="https://golang.org/cmd/go/#hdr-Description_of_testing_flags" target="_blank" rel="external">Description of testing flags</a>描述了全部的测试flag,我们挑几个常用的看一下。</p>
<ul>
<li><code>-bench regexp</code>:性能测试，支持表达式对测试函数进行筛选。<code>-bench .</code>则是对所有的benchmark函数测试</li>
<li><code>-benchmem</code>:性能测试的时候显示测试函数的内存分配的统计信息</li>
<li><code>－count n</code>:运行测试和性能多少此，默认一次</li>
<li><code>-run regexp</code>:只运行特定的测试函数， 比如<code>-run ABC</code>只测试函数名中包含ABC的测试函数</li>
<li><code>-timeout t</code>:测试时间如果超过t, panic,默认10分钟</li>
<li><code>-v</code>:显示测试的详细信息，也会把<code>Log</code>、<code>Logf</code>方法的日志显示出来</li>
</ul>
<p><code>go test -v -args -x -v</code>会编译然后执行程序：<code>pkg.test -test.v -x -v</code>，这样你就容易理解args参数的意义了。</p>
<p>Go 1.7中开始支持 <a href="https://github.com/golang/proposal/blob/master/design/12166-subtests.md" target="_blank" rel="external">sub-test</a>的概念。</p>
<p>参考</p>
<ul>
<li><a href="https://golang.org/pkg/testing/" target="_blank" rel="external">https://golang.org/pkg/testing/</a></li>
<li><a href="https://golang.org/doc/code.html#Testing" target="_blank" rel="external">https://golang.org/doc/code.html#Testing</a></li>
<li><a href="https://golang.org/cmd/go/#hdr-Test_packages" target="_blank" rel="external">https://golang.org/cmd/go/#hdr-Test_packages</a></li>
<li><a href="https://github.com/shageman/gotestit" target="_blank" rel="external">https://github.com/shageman/gotestit</a></li>
</ul>
<h3 id="测试比较工具">测试比较工具</h3>
<p>性能测试至关重要，你经常会问&quot;A 更快还是 B更快&quot;，当然还的靠性能数据说话。当然性能测试并不是一件简单的事情，今早我还看到陈皓写的一篇批判Dubbo测试的一篇文章：<a href="http://coolshell.cn/articles/17381.html" target="_blank" rel="external">性能测试应该怎么做？</a>。还好Go提供了一种容易的写性能测试的方法，但是如何比较多个候选者之间的性能呢？</p>
<p>一种方式就是编写多个测试函数，每个测试函数只测试一种候选方案，然后看测试的结果,比如我为Go序列化框架写的性能测试：<a href="https://github.com/smallnest/gosercomp" target="_blank" rel="external">gosercomp</a>。</p>
<p>本节要介绍的第一个工具就是 <a href="https://godoc.org/golang.org/x/tools/cmd/benchcmp" target="_blank" rel="external">benchcmp</a>,它可以比较两个版本之间的性能的提升或者下降。比如你的代码库在Go 1.6.2和Go 1.7编译后的性能的改变：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">go test -run=NONE -bench=. ./... &gt; old.txt</div><div class="line"><span class="comment"># make changes</span></div><div class="line">go test -run=NONE -bench=. ./... &gt; new.txt</div></pre></td></tr></table></figure>

<p>然后用这个工具进行比较：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ benchcmp old.txt <span class="built_in">new</span>.txt</div><div class="line">benchmark           old ns/op     <span class="built_in">new</span> ns/op     delta</div><div class="line">BenchmarkConcat    <span class="number"> 523</span>          <span class="number"> 68.6</span>         <span class="number"> -86.88</span>%</div><div class="line"></div><div class="line">benchmark           old allocs     <span class="built_in">new</span> allocs     delta</div><div class="line">BenchmarkConcat    <span class="number"> 3</span>             <span class="number"> 1</span>             <span class="number"> -66.67</span>%</div><div class="line"></div><div class="line">benchmark           old bytes     <span class="built_in">new</span> bytes     delta</div><div class="line">BenchmarkConcat    <span class="number"> 80</span>           <span class="number"> 48</span>           <span class="number"> -40.00</span>%</div></pre></td></tr></table></figure>

<p>第二个工具是<a href="https://github.com/cespare/prettybench" target="_blank" rel="external">prettybench</a>,它可以将Go自己的性能的测试报告美化，更好读：</p>
<pre class="highlight">
PASS
benchmark                                    iter    time/iter
---------                                    ----    ---------
BenchmarkCSSEscaper                       1000000   2843 ns/op
BenchmarkCSSEscaperNoSpecials             5000000    671 ns/op
BenchmarkDecodeCSS                        1000000   1183 ns/op
BenchmarkDecodeCSSNoSpecials             50000000     32 ns/op
BenchmarkCSSValueFilter                   5000000    501 ns/op
BenchmarkCSSValueFilterOk                 5000000    707 ns/op
BenchmarkEscapedExecute                    500000   6191 ns/op
BenchmarkHTMLNospaceEscaper               1000000   2523 ns/op
BenchmarkHTMLNospaceEscaperNoSpecials     5000000    596 ns/op
BenchmarkStripTags                        1000000   2351 ns/op
BenchmarkStripTagsNoSpecials             10000000    260 ns/op
BenchmarkJSValEscaperWithNum              1000000   1123 ns/op
BenchmarkJSValEscaperWithStr               500000   4882 ns/op
BenchmarkJSValEscaperWithStrNoSpecials    1000000   1461 ns/op
BenchmarkJSValEscaperWithObj               500000   5052 ns/op
BenchmarkJSValEscaperWithObjNoSpecials    1000000   1897 ns/op
BenchmarkJSStrEscaperNoSpecials           5000000    608 ns/op
BenchmarkJSStrEscaper                     1000000   2633 ns/op
BenchmarkJSRegexpEscaperNoSpecials        5000000    661 ns/op
BenchmarkJSRegexpEscaper                  1000000   2510 ns/op
BenchmarkURLEscaper                        500000   4424 ns/op
BenchmarkURLEscaperNoSpecials             5000000    422 ns/op
BenchmarkURLNormalizer                     500000   3068 ns/op
BenchmarkURLNormalizerNoSpecials          5000000    431 ns/op
ok      html/template    62.874s
</pre>

<p>第三个要介绍的工具是<a href="https://github.com/ajstarks/svgo/tree/master/benchviz" target="_blank" rel="external">benchviz</a>,它使用benchcmp的结果，但是可以图形化显示性能的提升:<br><img src="benchviz.svg" alt=""></p>
<p><a href="https://godoc.org/rsc.io/benchstat" target="_blank" rel="external">benchstat</a>这个工具可以将多次测试的结果汇总，生成概要信息。</p>
<p>参考：</p>
<ul>
<li><a href="http://dominik.honnef.co/posts/2014/12/an_incomplete_list_of_go_tools/" target="_blank" rel="external">http://dominik.honnef.co/posts/2014/12/an_incomplete_list_of_go_tools/</a></li>
</ul>
<h3 id="TDT_(Table_Driven_Tests)">TDT (Table Driven Tests)</h3>
<p>TDT也叫表格驱动方法，有时也被归为关键字驱动测试(keyword-driven testing，是针对自动化测试的软件测试方法，它将创建测试程序的步骤分为规划及实现二个阶段。</p>
<p>Go官方库中有些测试就使用了这种测试方法。</p>
<p>TDT中每个表格项就是一个完整的test case,包含输入和期望的输出，有时候还会加一些额外的信息比如测试名称。如果你发现你的测试中经常copy/paste操作，你就可以考虑把它们改造成TDT。</p>
<p>测试代码就一块，但是可以测试表格中的每一项。</p>
<p>下面是一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> flagtests = []<span class="keyword">struct</span> {</div><div class="line">    in  <span class="typename">string</span></div><div class="line">    out <span class="typename">string</span></div><div class="line">}{</div><div class="line">    {<span class="string">"%a"</span>, <span class="string">"[%a]"</span>},</div><div class="line">    {<span class="string">"%-a"</span>, <span class="string">"[%-a]"</span>},</div><div class="line">    {<span class="string">"%+a"</span>, <span class="string">"[%+a]"</span>},</div><div class="line">    {<span class="string">"%#a"</span>, <span class="string">"[%#a]"</span>},</div><div class="line">    {<span class="string">"% a"</span>, <span class="string">"[% a]"</span>},</div><div class="line">    {<span class="string">"%0a"</span>, <span class="string">"[%0a]"</span>},</div><div class="line">    {<span class="string">"%1.2a"</span>, <span class="string">"[%1.2a]"</span>},</div><div class="line">    {<span class="string">"%-1.2a"</span>, <span class="string">"[%-1.2a]"</span>},</div><div class="line">    {<span class="string">"%+1.2a"</span>, <span class="string">"[%+1.2a]"</span>},</div><div class="line">    {<span class="string">"%-+1.2a"</span>, <span class="string">"[%+-1.2a]"</span>},</div><div class="line">    {<span class="string">"%-+1.2abc"</span>, <span class="string">"[%+-1.2a]bc"</span>},</div><div class="line">    {<span class="string">"%-1.2abc"</span>, <span class="string">"[%-1.2a]bc"</span>},</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> TestFlagParser(t *testing.T) {</div><div class="line">    <span class="keyword">var</span> flagprinter flagPrinter</div><div class="line">    <span class="keyword">for</span> _, tt := <span class="keyword">range</span> flagtests {</div><div class="line">        s := Sprintf(tt.in, &flagprinter)</div><div class="line">        <span class="keyword">if</span> s != tt.out {</div><div class="line">            t.Errorf(<span class="string">"Sprintf(%q, &flagprinter) =&gt; %q, want %q"</span>, tt.in, s, tt.out)</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>参考</p>
<ul>
<li><a href="https://github.com/golang/go/wiki/TableDrivenTests" target="_blank" rel="external">https://github.com/golang/go/wiki/TableDrivenTests</a></li>
<li><a href="http://dave.cheney.net/2013/06/09/writing-table-driven-tests-in-go" target="_blank" rel="external">http://dave.cheney.net/2013/06/09/writing-table-driven-tests-in-go</a></li>
</ul>
<h3 id="测试覆盖率">测试覆盖率</h3>
<p>从 Go 1.2开始， Go就提供了一个生成代码覆盖率的工具<code>cover</code>。</p>
<p>代码覆盖率描述了包中代码有多少语句被测试所覆盖。</p>
<p>比如代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> size</div><div class="line"></div><div class="line"><span class="keyword">func</span> Size(a <span class="typename">int</span>) <span class="typename">string</span> {</div><div class="line">    <span class="keyword">switch</span> {</div><div class="line">    <span class="keyword">case</span> a &lt;<span class="number"> 0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="string">"negative"</span></div><div class="line">    <span class="keyword">case</span> a ==<span class="number"> 0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="string">"zero"</span></div><div class="line">    <span class="keyword">case</span> a &lt;<span class="number"> 10</span>:</div><div class="line">        <span class="keyword">return</span> <span class="string">"small"</span></div><div class="line">    <span class="keyword">case</span> a &lt;<span class="number"> 100</span>:</div><div class="line">        <span class="keyword">return</span> <span class="string">"big"</span></div><div class="line">    <span class="keyword">case</span> a &lt;<span class="number"> 1000</span>:</div><div class="line">        <span class="keyword">return</span> <span class="string">"huge"</span></div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="string">"enormous"</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> size</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"testing"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span> {</div><div class="line">    in  <span class="typename">int</span></div><div class="line">    out <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> tests = []Test{</div><div class="line">    <span class="number">{-1</span>, <span class="string">"negative"</span>},</div><div class="line">    <span class="number">{5</span>, <span class="string">"small"</span>},</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> TestSize(t *testing.T) {</div><div class="line">    <span class="keyword">for</span> i, test := <span class="keyword">range</span> tests {</div><div class="line">        size := Size(test.in)</div><div class="line">        <span class="keyword">if</span> size != test.out {</div><div class="line">            t.Errorf(<span class="string">"#%d: Size(%d)=%s; want %s"</span>, i, test.in, size, test.out)</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>查看代码覆盖率：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">% go test -cover</div><div class="line">PASS</div><div class="line">coverage: <span class="number">42.9</span>% of statements</div><div class="line">ok      size    <span class="number">0.026</span>s</div><div class="line">%</div></pre></td></tr></table></figure>

<p>想查看详细的覆盖率，可以生成<code>coverage profile</code>文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">% go test -coverprofile=coverage.out</div><div class="line">PASS</div><div class="line">coverage: <span class="number">42.9</span>% of statements</div><div class="line">ok      size    <span class="number">0.030</span>s</div><div class="line">%</div></pre></td></tr></table></figure>

<p>生成html测试报告：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go tool cover -html=coverage.out</div></pre></td></tr></table></figure>

<p>一些网站可以帮助你测试生成代码覆盖率，你还可以把你的项目的badge写在README文件中， 比如<a href="https://gocover.io" target="_blank" rel="external">gocover</a>、<a href="https://coveralls.io" target="_blank" rel="external">coveralls</a></p>
<p>参考</p>
<ul>
<li><a href="https://blog.golang.org/cover" target="_blank" rel="external">https://blog.golang.org/cover</a></li>
</ul>
<h3 id="性能测试">性能测试</h3>
<p>性能测试的写法和单元测试的写法类似，但是用&quot;Benchmark&quot;代替&quot;Test&quot;作为函数的开头，而且函数的参数改为<code>*testing.B</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> BenchmarkXxx(*testing.B)</div></pre></td></tr></table></figure>

<p>测试的时候，加上 <code>-bench</code>就可以执行性能的测试，如<code>go test -bench .</code>。</p>
<p>一个简单的性能测试代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> BenchmarkHello(b *testing.B) {</div><div class="line">    <span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; b.N; i++ {</div><div class="line">        fmt.Sprintf(<span class="string">"hello"</span>)</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>测试代码会执行<code>b.N</code>次，但是<code>N</code>会根据你的代码的性能进行调整，代码执行的快，N会大一些，代码慢，N就小一些。<br>测试结果如下，执行了10000000次测试，每次测试花费282纳秒：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">BenchmarkHello</span>    <span class="number">10000000</span>    <span class="number">282</span> ns/op</div></pre></td></tr></table></figure>

<p>如果测试之前你需要准备一些花费时间较长的工作，你可以调用<code>ResetTimer</code>指定测试开始的时机：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> BenchmarkBigLen(b *testing.B) {</div><div class="line">    big := NewBig()</div><div class="line">    b.ResetTimer()</div><div class="line">    <span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; b.N; i++ {</div><div class="line">        big.Len()</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果需要并行地执行测试，可以在测试的时候加上<code>-cpu</code>参数，可以执行<code>RunParallel</code>辅助方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> BenchmarkTemplateParallel(b *testing.B) {</div><div class="line">    templ := template.Must(template.New(<span class="string">"test"</span>).Parse(<span class="string">"Hello, { {.} }!"</span>))</div><div class="line">    b.RunParallel(<span class="keyword">func</span>(pb *testing.PB) {</div><div class="line">        <span class="keyword">var</span> buf bytes.Buffer</div><div class="line">        <span class="keyword">for</span> pb.Next() {</div><div class="line">            buf.Reset()</div><div class="line">            templ.Execute(&buf, <span class="string">"World"</span>)</div><div class="line">        }</div><div class="line">    })</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Example">Example</h3>
<p>一个代码示例函数就像一个测试函数一样，但是它并不使用<code>*testing.T</code>作为参数报告错误或失败，而是将输出结果输出到 os.Stdout 和 os.Stderr。<br>输出结果会和函数内的<code>Output:</code>注释中的结果比较， 这个注释在函数体的最底部。如果没有`Output:注释，或者它的后面没有文本，则代码只会编译，不会执行。</p>
<p>Godoc 可以显示 ExampleXXX 的实现代码， 用来演示函数XXX或者常量XXX或者变量XXX的使用。如果receiver为T或者*T的方法M,它的示例代码的命名方式应该是ExampleT_M。如果一个函数、常量或者变量有多可以在示例代码的方法名后加后缀_xxx, xxx的第一个字符不能大写。</p>
<p>举个例子:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> ch11</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> ExampleAdd() {</div><div class="line">	k := Add<span class="number">(1</span>,<span class="number"> 2</span>)</div><div class="line">	fmt.Println(k)</div><div class="line"></div><div class="line">	<span class="comment">// Output:</span></div><div class="line">	<span class="comment">// 3</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>相信你已经在godoc中看到了很多这样的例子，你也应该为你的库提供相应的例子，这样别人很容易熟悉你的代码。</p>
<p>你可以使用<code>go help testfunc</code>查看详细说明。</p>
<p>示例代码的文件名一般用<code>example_test.go</code>, 因为它们也是测试函数，所以文件名要以&quot;_test.go&quot;结尾。</p>
<p>运行测试代码：<code>go test -v</code>可以看到示例函数也被测试了。<br>如果我们将上例注释中的<code>// 3</code>改为<code>// 2</code>,运行<code>go test -v</code>可以看到出错，因为执行结果和我们的输出不一致。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">smallnestMBP:ch11 smallnest$ go test -v</div><div class="line">=== RUN   Test123</div><div class="line">--- PASS: Test123 (<span class="number">0.00</span>s)</div><div class="line">=== RUN   ExampleAdd</div><div class="line">--- FAIL: ExampleAdd (<span class="number">0.00</span>s)</div><div class="line">got:</div><div class="line"><span class="number">3</span></div><div class="line">want:</div><div class="line"><span class="number">2</span></div><div class="line">FAIL</div><div class="line"><span class="keyword">exit</span> status <span class="number">1</span></div><div class="line">FAIL	github.com/smallnest/dive-into-go/ch11	<span class="number">0.005</span>s</div><div class="line">smallnestMBP:ch11 smallnest$</div></pre></td></tr></table></figure>

<p>有时候，我们可能要为一组函数写一个示例，这个时候我们就需要一个<code>whole file example</code>,一个<code>whole file example</code>以&quot;_test.go&quot;结尾，只包含一个示例函数，没有测试函数或者性能测试函数，至少包含一个其它包级别的声明,如下例就是一个完整的文件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="typename">bool</span> { <span class="keyword">return</span> a[i].Age &lt; a[j].Age }</div><div class="line"></div><div class="line"><span class="keyword">func</span> Example() {</div><div class="line">    people := []Person{</div><div class="line">        {<span class="string">"Bob"</span>,<span class="number"> 31</span>},</div><div class="line">        {<span class="string">"John"</span>,<span class="number"> 42</span>},</div><div class="line">        {<span class="string">"Michael"</span>,<span class="number"> 17</span>},</div><div class="line">        {<span class="string">"Jenny"</span>,<span class="number"> 26</span>},</div><div class="line">    }</div><div class="line"></div><div class="line">    fmt.Println(people)</div><div class="line">    sort.Sort(ByAge(people))</div><div class="line">    fmt.Println(people)</div><div class="line"></div><div class="line">    <span class="comment">// Output:</span></div><div class="line">    <span class="comment">// [Bob: 31 John: 42 Michael: 17 Jenny: 26]</span></div><div class="line">    <span class="comment">// [Michael: 17 Jenny: 26 Bob: 31 John: 42]</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>参考</p>
<ul>
<li><a href="https://blog.golang.org/examples" target="_blank" rel="external">https://blog.golang.org/examples</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>本章介绍Go语言的代码的测试、性能测试以及示例的写法。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入Go语言 - 11]]></title>
    <link href="http://colobu.com/2016/07/04/dive-into-go-11/"/>
    <id>http://colobu.com/2016/07/04/dive-into-go-11/</id>
    <published>2016-07-03T22:12:42.000Z</published>
    <updated>2016-07-06T05:33:52.000Z</updated>
    <content type="html"><![CDATA[<p>本章重点介绍Go程序的调试和性能监控。</p>
<a id="more"></a>
<h3 id="GDB">GDB</h3>
<p>当你在Linux、macOS、FreeBSD、NetBSD环境中使用gc工具链编译和链接你的程序的时候，生成的二进制文件中包含 DWARFv3调试信息, 最新的GDB(&gt;7.1)可以用它们来调试程序。</p>
<p>gc工具链的名字来自Go前端编译器(compiler frontend), <code>cmd/gc</code>,以区分<code>gccgo</code>工具链。当人们谈论Go编译器的时候，通常所指就是gc工具链。</p>
<p>gc工具链包含一个Go编译器、一个C编译器、一个汇编工具和一个链接工具，所有这些工具都可以在<code>src\cmd</code>文件夹下找到，比如<code>5g</code>、<code>6g</code>、｀8g｀、<code>5c</code>、<code>6c</code>、<code>8c</code>、<code>5a</code>、<code>6a</code>、<code>8a</code>、<code>5l</code>、<code>6l</code>、<code>8l</code>等。</p>
<p>自Go 1.5 gc工具链改变了，从C的实现改变成Go的实现，所以你在Go1.5以上的版本中找不到这些工具，而是由统一的compile、link工具所取代。 你编译的时候可以看到工具链是如何工作的：</p>
<pre class="highlight">
smallnestMBP:ch10 smallnest$ go build  -x -gcflags "-N -l" pi.go
WORK=/var/folders/lv/5kl1rvvj2jsfqxyw_1_pvw380000gn/T/go-build974068189
mkdir -p $WORK/command-line-arguments/_obj/
mkdir -p $WORK/command-line-arguments/_obj/exe/
cd /Users/smallnest/go/src/github.com/smallnest/dive-into-go/ch10
/usr/local/go/pkg/tool/darwin_amd64/compile -o $WORK/command-line-arguments.a -trimpath $WORK -N -l -p main -complete -buildid ab0109c737108c5646adfbf53bff79b7a49b96d4 -D _/Users/smallnest/go/src/github.com/smallnest/dive-into-go/ch10 -I $WORK -pack ./pi.go
cd .
/usr/local/go/pkg/tool/darwin_amd64/link -o $WORK/command-line-arguments/_obj/exe/a.out -L $WORK -extld=clang -buildmode=exe -buildid=ab0109c737108c5646adfbf53bff79b7a49b96d4 $WORK/command-line-arguments.a
mv $WORK/command-line-arguments/_obj/exe/a.out pi
</pre>

<blockquote>
<p>The suites of programs that were the compilers (6g, 8g, etc.), the assemblers (6a, 8a, etc.), and the linkers (6l, 8l, etc.) have each been consolidated into a single tool that is configured by the environment variables GOOS and GOARCH. The old names are gone; the new tools are available through the go tool mechanism as go tool compile, go tool asm, and go tool link. Also, the file suffixes .6, .8, etc. for the intermediate object files are also gone; now they are just plain .o files.</p>
<p>For example, to build and link a program on amd64 for Darwin using the tools directly, rather than through go build, one would run:</p>
<pre class="highlight">
$ export GOOS=darwin GOARCH=amd64
$ go tool compile program.go
$ go tool link program.o
</pre>

<p>摘自 <a href="https://golang.org/doc/go1.5#rename" target="_blank" rel="external">https://golang.org/doc/go1.5#rename</a></p>
</blockquote>
<p><code>-w</code>参数会告诉连接器忽略这些调试信息(<code>go build -ldflags &quot;-w&quot; example.go</code>)。</p>
<p>gc编译器可能会做优化，比如inline函数，这会让gdb调试更加困难。如果不想让编译器做这些优化可以指定参数<code>-gcflags &quot;-N -l&quot;</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">go</span> build  -gcflags <span class="string">"-N -l"</span> pi.<span class="keyword">go</span></div></pre></td></tr></table></figure>

<p>GDB具体的执行命令你可以搜索相关的文档，网络上有居多的文章介绍。</p>
<p>以<a href="https://golang.org/doc/play/pi.go" target="_blank" rel="external">计算圆周率 Pi 的代码为例</a>，在<code>macOS</code>中你需要执行 <code>sudo gdb pi</code>,然后进入GDB的控制台。</p>
<p><code>list</code>可以显示源代码。</p>
<p><code>break</code>加断点，比如<code>break 16</code>。</p>
<p><code>bt</code> 、<code>frame n</code>可以显示调用栈信息。</p>
<p><code>info</code>显示变量的信息：</p>
<pre class="highlight">
(gdb) next
17            go term(ch, float64(k))
(gdb) info args
n = 5000
~r1 = 0
(gdb) info locals
k = 0
k = 16
f = 4.3922040662770145e-318
ch = 0xc820066000
(gdb) p ch
$1 = (chan float64) 0xc820066000
</pre>

<p>基本上，如果你熟悉gdb工具，可以轻松地进行调试，还可以使用<a href="https://golang.org/src/runtime/runtime-gdb.py" target="_blank" rel="external">扩展脚本</a>对复杂类型进行检查。</p>
<p>参考</p>
<ul>
<li><a href="https://golang.org/doc/gdb" target="_blank" rel="external">https://golang.org/doc/gdb</a></li>
<li><a href="https://astaxie.gitbooks.io/build-web-application-with-golang/content/en/11.2.html" target="_blank" rel="external">https://astaxie.gitbooks.io/build-web-application-with-golang/content/en/11.2.html</a></li>
<li><a href="https://lincolnloop.com/blog/introduction-go-debugging-gdb/" target="_blank" rel="external">https://lincolnloop.com/blog/introduction-go-debugging-gdb/</a></li>
<li><a href="https://blog.codeship.com/using-gdb-debugger-with-go/" target="_blank" rel="external">https://blog.codeship.com/using-gdb-debugger-with-go/</a></li>
<li><a href="http://dave.cheney.net/2013/10/15/how-does-the-go-build-command-work" target="_blank" rel="external">http://dave.cheney.net/2013/10/15/how-does-the-go-build-command-work</a></li>
<li><a href="https://github.com/golang/go/wiki/GcToolchainTricks" target="_blank" rel="external">https://github.com/golang/go/wiki/GcToolchainTricks</a></li>
<li><a href="https://github.com/golang/go/wiki/GcToolchainTricks" target="_blank" rel="external">https://github.com/golang/go/wiki/GcToolchainTricks</a></li>
</ul>
<h3 id="delve及IDE集成调试">delve及IDE集成调试</h3>
<p>虽然gdb工具很强大，但是这种基于命令行的调试方式确实不方便，而且它也不是专门为Go语言提供的调试工具，尤其对于并发程序的调试。</p>
<p>但是G官方一直没有提供一个Go调试器。</p>
<p>幸运地是，有人提供了专门针对 Go语言的调试器：<br><img src="https://raw.githubusercontent.com/derekparker/delve/master/assets/delve_horizontal.png" alt=""></p>
<p>网址： <a href="https://github.com/derekparker/delve" target="_blank" rel="external">https://github.com/derekparker/delve</a></p>
<p>虽然当前delve的版本还是pre 1.0，但是已经提供了很好的Go调试的功能，并且可以很好的Intellj、Atom、Vscode等Go IDE工具集成。</p>
<p>当然你可以用命令行的方式调试,它有多种方式启动<code>dlv</code>： <code>dlv attach</code>、<code>dlv debug</code>、<code>dlv exec</code>、<code>dlv test</code>、<code>dlv trace</code>等，用来调试一个进程或者程序等。我们用<code>dlv exec ./pi</code>调试刚才编译好的程序。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(dlv) b pi.go:<span class="number">16</span> <span class="comment">#在 pi.go 的第 16 行设置断点。</span></div><div class="line">(dlv) bp   <span class="comment">#查看当前所有断点</span></div><div class="line">(dlv) c    <span class="comment">#运行到下一个断点或者程序结尾</span></div><div class="line">(dlv) n    <span class="comment">#单步执行代码</span></div><div class="line">(dlv) p ch  <span class="comment">#打印变量 ch 的值</span></div><div class="line">(dlv) goroutines  <span class="comment">#打印所有的goroutine</span></div><div class="line">(dlv) goroutine  <span class="comment">#打印当前的或者指定的goroutine信息</span></div></pre></td></tr></table></figure>

<p>它的信息要比gdb的详细，更适合Go程序的调试。</p>
<p>以下IDE工具可以集成delve。</p>
<ul>
<li><a href="https://github.com/go-lang-plugin-org/go-lang-idea-plugin" target="_blank" rel="external">Golang Plugin for IntelliJ IDEA</a></li>
<li><a href="https://github.com/Microsoft/vscode-go" target="_blank" rel="external">Go for Visual Studio Code</a></li>
<li><a href="https://github.com/benma/go-dlv.el/" target="_blank" rel="external">Emacs plugin</a></li>
<li><a href="https://github.com/visualfc/liteide" target="_blank" rel="external">LiteIDE</a></li>
<li><a href="https://github.com/lloiser/go-debug" target="_blank" rel="external">Go Debugger for Atom</a></li>
</ul>
<p>关于vscode IDE,你可以参考: <a href="http://colobu.com/2016/04/21/use-vscode-to-develop-go-programs/" target="_blank" rel="external">使用visual studio code开发Go程序
</a>。</p>
<p><img src="http://colobu.com/2016/04/21/use-vscode-to-develop-go-programs/vscode.png" alt=""></p>
<p>参考</p>
<ul>
<li><a href="https://github.com/derekparker/delve" target="_blank" rel="external">https://github.com/derekparker/delve</a></li>
<li><a href="https://github.com/derekparker/delve/tree/master/Documentation" target="_blank" rel="external">https://github.com/derekparker/delve/tree/master/Documentation</a></li>
<li><a href="https://blog.gopheracademy.com/advent-2015/debugging-with-delve/" target="_blank" rel="external">https://blog.gopheracademy.com/advent-2015/debugging-with-delve/</a></li>
<li><a href="http://blog.ralch.com/tutorial/golang-debug-with-delve/" target="_blank" rel="external">http://blog.ralch.com/tutorial/golang-debug-with-delve/</a></li>
<li><a href="https://github.com/joefitzgerald/go-plus" target="_blank" rel="external">https://github.com/joefitzgerald/go-plus</a></li>
<li><a href="https://atom.io/packages/go-debug" target="_blank" rel="external">https://atom.io/packages/go-debug</a></li>
<li><a href="https://code.visualstudio.com/" target="_blank" rel="external">https://code.visualstudio.com/</a></li>
<li><a href="https://www.reddit.com/r/golang/comments/3jyfvd/go_plugin_for_intellij_ides_now_has_delve/" target="_blank" rel="external">https://www.reddit.com/r/golang/comments/3jyfvd/go_plugin_for_intellij_ides_now_has_delve/</a></li>
<li><a href="https://github.com/go-lang-plugin-org/go-lang-idea-plugin" target="_blank" rel="external">https://github.com/go-lang-plugin-org/go-lang-idea-plugin</a></li>
<li><a href="https://github.com/DisposaBoy/GoSublime" target="_blank" rel="external">https://github.com/DisposaBoy/GoSublime</a></li>
<li><a href="https://github.com/fatih/vim-go" target="_blank" rel="external">https://github.com/fatih/vim-go</a></li>
<li><a href="https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins" target="_blank" rel="external">https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins</a></li>
</ul>
<h3 id="pprof">pprof</h3>
<p>Go官方库提供了两个类似的包pprof,分别为HTTP应用和通用应用提供了性能监控的功能。我们先看看 &quot;runtime/pprof&quot;包的使用，正好Go项目组有一个使用的例子，而且他们专门写了一篇文章介绍： <a href="https://blog.golang.org/profiling-go-programs" target="_blank" rel="external">profiling go programs</a>:</p>
<p>2011年的Scala Days会议上，Robert Hundt介绍了论文: <a href="http://research.google.com/pubs/pub37122.html" target="_blank" rel="external">Loop Recognition in C++/Java/Go/Scala</a>,这个文章中的Go程序运行的非常慢。</p>
<p>Go项目组正好利用Go profiling tool查找程序的瓶颈。他们选择了一个开发环境，测试C++和Go程序，发现C++程序用了17.8秒，内存使用700M,而Go称许用了25.2秒，内存占用1302M,所以他们尝试使用<code>go tool pprof</code>查找原因。</p>
<p>首先输入<code>runtime/pprof</code>,并使用两个参数<code>-cpuprofile</code>和<code>-memprofile</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> cpuprofile = flag.String(<span class="string">"cpuprofile"</span>, <span class="string">""</span>, <span class="string">"write cpu profile to file"</span>)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    flag.Parse()</div><div class="line">    <span class="keyword">if</span> *cpuprofile != <span class="string">""</span> {</div><div class="line">        f, err := os.Create(*cpuprofile)</div><div class="line">        <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">            log.Fatal(err)</div><div class="line">        }</div><div class="line">        pprof.StartCPUProfile(f)</div><div class="line">        <span class="keyword">defer</span> pprof.StopCPUProfile()</div><div class="line">    }</div><div class="line">    ...</div></pre></td></tr></table></figure>

<p>程序启动的时候启动<a href="https://golang.org/pkg/runtime/pprof/#StartCPUProfile），程序结束的时候记得一定要调用[StopCPUProfile](" target="_blank" rel="external">CPU性能监控</a><a href="http://golang.org/pkg/runtime/pprof/#StopCPUProfile，这样才能将缓存的监控数据写入都文件中。" target="_blank" rel="external">http://golang.org/pkg/runtime/pprof/#StopCPUProfile，这样才能将缓存的监控数据写入都文件中。</a></p>
<p>执行程序，执行完后用<code>go tool pprof</code>工具分析性能数据。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ make havlak1.prof</div><div class="line">./havlak1 -cpuprofile=havlak1.prof</div><div class="line"><span class="comment"># of loops: 76000 (including 1 artificial root node)</span></div><div class="line">$ go tool pprof havlak1 havlak1.prof</div><div class="line">Welcome to pprof!  For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">'help'</span>.</div><div class="line">(pprof)</div></pre></td></tr></table></figure>

<p><code>go tool pprof</code>是 <a href="https://code.google.com/p/gperftools/wiki/GooglePerformanceTools" target="_blank" rel="external">Google&#39;s pprof C++ profiler</a> 的变种。最重要的命令就是<code>topN</code>,它显示top N的采样结果:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(pprof) top10</div><div class="line">Total: <span class="number">2525</span> samples</div><div class="line">     <span class="number">298</span>  <span class="number">11.8</span>%  <span class="number">11.8</span>%      <span class="number">345</span>  <span class="number">13.7</span>% runtime.mapaccess1_fast64</div><div class="line">     <span class="number">268</span>  <span class="number">10.6</span>%  <span class="number">22.4</span>%     <span class="number">2124</span>  <span class="number">84.1</span>% main.FindLoops</div><div class="line">     <span class="number">251</span>   <span class="number">9.9</span>%  <span class="number">32.4</span>%      <span class="number">451</span>  <span class="number">17.9</span>% scanblock</div><div class="line">     <span class="number">178</span>   <span class="number">7.0</span>%  <span class="number">39.4</span>%      <span class="number">351</span>  <span class="number">13.9</span>% <span class="built_in">hash</span>_insert</div><div class="line">     <span class="number">131</span>   <span class="number">5.2</span>%  <span class="number">44.6</span>%      <span class="number">158</span>   <span class="number">6.3</span>% sweepspan</div><div class="line">     <span class="number">119</span>   <span class="number">4.7</span>%  <span class="number">49.3</span>%      <span class="number">350</span>  <span class="number">13.9</span>% main.DFS</div><div class="line">      <span class="number">96</span>   <span class="number">3.8</span>%  <span class="number">53.1</span>%       <span class="number">98</span>   <span class="number">3.9</span>% flushptrbuf</div><div class="line">      <span class="number">95</span>   <span class="number">3.8</span>%  <span class="number">56.9</span>%       <span class="number">95</span>   <span class="number">3.8</span>% runtime.aeshash64</div><div class="line">      <span class="number">95</span>   <span class="number">3.8</span>%  <span class="number">60.6</span>%      <span class="number">101</span>   <span class="number">4.0</span>% runtime.settype_flush</div><div class="line">      <span class="number">88</span>   <span class="number">3.5</span>%  <span class="number">64.1</span>%      <span class="number">988</span>  <span class="number">39.1</span>% runtime.mallocgc</div></pre></td></tr></table></figure>

<p>当监控的时候(profiling),Go程序每0.01秒采样一次，每次采样会记录当前执行的goroutine的程序计数器。上例中共2525次采样，所以它运行了大约25秒。 （注意go tool pprof执行的时候需要程序和采样数据，无果没有指定程序，则不会出现上面的结果）。如果程序执行太快，还没来得及采样，则无法分析其数据。</p>
<p>我们也可以分析一下上一节的Pi程序<code>go tool pprof pi pi.prof</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">smallnestMBP:ch10 smallnest$ go tool pprof pi pi.prof</div><div class="line">Entering interactive mode (<span class="built_in">type</span> <span class="string">"help"</span> <span class="keyword">for</span> commands)</div><div class="line">(pprof) top10</div><div class="line"><span class="number">64.75</span>s of <span class="number">73.30</span>s total (<span class="number">88.34</span>%)</div><div class="line">Dropped <span class="number">73</span> nodes (cum &lt;= <span class="number">0.37</span>s)</div><div class="line">Showing top <span class="number">10</span> nodes out of <span class="number">65</span> (cum &gt;= <span class="number">1.56</span>s)</div><div class="line">      flat  flat%   sum%        cum   cum%</div><div class="line">    <span class="number">21.66</span>s <span class="number">29.55</span>% <span class="number">29.55</span>%     <span class="number">21.66</span>s <span class="number">29.55</span>%  fmt.(*fmt).padString</div><div class="line">    <span class="number">10.45</span>s <span class="number">14.26</span>% <span class="number">43.81</span>%     <span class="number">10.45</span>s <span class="number">14.26</span>%  fmt.(*fmt).integer</div><div class="line">    <span class="number">10.26</span>s <span class="number">14.00</span>% <span class="number">57.80</span>%     <span class="number">10.28</span>s <span class="number">14.02</span>%  runtime.send</div><div class="line">     <span class="number">6.60</span>s  <span class="number">9.00</span>% <span class="number">66.81</span>%      <span class="number">6.60</span>s  <span class="number">9.00</span>%  fmt.(*fmt).pad</div><div class="line">     <span class="number">4.52</span>s  <span class="number">6.17</span>% <span class="number">72.97</span>%      <span class="number">4.77</span>s  <span class="number">6.51</span>%  runtime.stackfree</div><div class="line">     <span class="number">3.26</span>s  <span class="number">4.45</span>% <span class="number">77.42</span>%      <span class="number">3.26</span>s  <span class="number">4.45</span>%  fmt.(*fmt).fmt_boolean</div><div class="line">     <span class="number">2.86</span>s  <span class="number">3.90</span>% <span class="number">81.32</span>%     <span class="number">11.13</span>s <span class="number">15.18</span>%  type..hash.[<span class="number">1</span>]interface {}</div><div class="line">     <span class="number">2.06</span>s  <span class="number">2.81</span>% <span class="number">84.13</span>%      <span class="number">2.06</span>s  <span class="number">2.81</span>%  reflect.Kind.String</div><div class="line">     <span class="number">1.91</span>s  <span class="number">2.61</span>% <span class="number">86.74</span>%      <span class="number">2.18</span>s  <span class="number">2.97</span>%  runtime.SetFinalizer</div><div class="line">     <span class="number">1.17</span>s  <span class="number">1.60</span>% <span class="number">88.34</span>%      <span class="number">1.56</span>s  <span class="number">2.13</span>%  reflect.chanrecv</div><div class="line">(pprof)</div></pre></td></tr></table></figure>

<p>前两列显示采样中函数正在执行的次数和百分比（不包含等待函数调用返回的值），数值越大函数执行的频率越大。第三列显示的是前面的数值在整个列表中总数的百分比，Go team的例子中前三行的占比已经达到了32.4%。第4列、第5列显示正在运行和等待的函数出现的数量和占比，虽然函数<code>main.FindLoops</code>运行的次数才占10.6%,但是它确出现在84.1％采样的调用堆栈上(call stack)。</p>
<p>如果要按照第4列第5列排序，可以<code>(pprof) top5 -cum</code> :</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(pprof) top5 -cum</div><div class="line">Total:<span class="number"> 2525</span> samples</div><div class="line">      <span class="number"> 0</span>  <span class="number"> 0.0</span>%  <span class="number"> 0.0</span>%    <span class="number"> 2144</span> <span class="number"> 84.9</span>% gosched0</div><div class="line">      <span class="number"> 0</span>  <span class="number"> 0.0</span>%  <span class="number"> 0.0</span>%    <span class="number"> 2144</span> <span class="number"> 84.9</span>% main.main</div><div class="line">      <span class="number"> 0</span>  <span class="number"> 0.0</span>%  <span class="number"> 0.0</span>%    <span class="number"> 2144</span> <span class="number"> 84.9</span>% runtime.main</div><div class="line">      <span class="number"> 0</span>  <span class="number"> 0.0</span>%  <span class="number"> 0.0</span>%    <span class="number"> 2124</span> <span class="number"> 84.1</span>% main.FindHavlakLoops</div><div class="line">    <span class="number"> 268</span> <span class="number"> 10.6</span>% <span class="number"> 10.6</span>%    <span class="number"> 2124</span> <span class="number"> 84.1</span>% main.FindLoops</div><div class="line">(pprof) top5 -cum</div></pre></td></tr></table></figure>

<p>事实上<code>main.FindLoops</code>和<code>main.main</code>的占比应该是100%，但是由于每次采样只分析最底部的100个栈帧(stack frame)，大于四分之一的采样中，<code>main.DFS</code>递归调用的太深，超过了100帧，所有有些没有计数。</p>
<p>起始，性能数据中还包含更有趣的函数调用关系。<br>使用命令 web 可以产生SVG图形，用一个浏览器就能打开它，不过需要你的机器安装graphviz: <code>(pprof) web</code></p>
<p><img src="profiling-go-programs_havlak1a-75.png" alt=""></p>
<p>图形中的每个方框代表一个函数，方框的大小代表函数运行的采样数据大小。箭头x指向Y表示X调用Y,箭头指向自身表示递归调用。箭头上的数量代表一次采样中的调用次数。</p>
<p>从图中可以看出，程序花费了很多的时间在hash值的计算上，使用go map对象。我们可以让web只显示特定函数的采样，比如<code>runtime.mapaccess1_fast64</code>: <code>(pprof) web mapaccess1</code>。</p>
<p><img src="profiling-go-programs_havlak1-hash_lookup-75.png" alt=""></p>
<p>好了，我们知道了性能的大概情况以及哪个函数占的时间太多，现在通过<code>list</code>命令查看函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">(pprof) list DFS</div><div class="line">Total:<span class="number"> 2525</span> samples</div><div class="line">ROUTINE ====================== main.DFS in /home/rsc/g/benchgraffiti/havlak/havlak1.<span class="keyword">go</span></div><div class="line">  <span class="number"> 119</span>   <span class="number"> 697</span> Total samples (flat / cumulative)</div><div class="line">    <span class="number"> 3</span>     <span class="number"> 3</span> <span class="number"> 240</span>: <span class="keyword">func</span> DFS(currentNode *BasicBlock, nodes []*UnionFindNode, number <span class="keyword">map</span>[*BasicBlock]<span class="typename">int</span>, last []<span class="typename">int</span>, current <span class="typename">int</span>) <span class="typename">int</span> {</div><div class="line">    <span class="number"> 1</span>     <span class="number"> 1</span> <span class="number"> 241</span>:     nodes[current].Init(currentNode, current)</div><div class="line">    <span class="number"> 1</span>    <span class="number"> 37</span> <span class="number"> 242</span>:     number[currentNode] = current</div><div class="line">     .      . <span class="number"> 243</span>:</div><div class="line">    <span class="number"> 1</span>     <span class="number"> 1</span> <span class="number"> 244</span>:     lastid := current</div><div class="line">   <span class="number"> 89</span>    <span class="number"> 89</span> <span class="number"> 245</span>:     <span class="keyword">for</span> _, target := <span class="keyword">range</span> currentNode.OutEdges {</div><div class="line">    <span class="number"> 9</span>   <span class="number"> 152</span> <span class="number"> 246</span>:             <span class="keyword">if</span> number[target] == unvisited {</div><div class="line">    <span class="number"> 7</span>   <span class="number"> 354</span> <span class="number"> 247</span>:                     lastid = DFS(target, nodes, number, last, lastid<span class="number">+1</span>)</div><div class="line">     .      . <span class="number"> 248</span>:             }</div><div class="line">     .      . <span class="number"> 249</span>:     }</div><div class="line">    <span class="number"> 7</span>    <span class="number"> 59</span> <span class="number"> 250</span>:     last[number[currentNode]] = lastid</div><div class="line">    <span class="number"> 1</span>     <span class="number"> 1</span> <span class="number"> 251</span>:     <span class="keyword">return</span> lastid</div><div class="line">(pprof)</div></pre></td></tr></table></figure>

<p>前三列分别代表程序运行都此的采样数、运行到此或者在此调用的采样数、代码行数。</p>
<p>前面已经知道性能出现在map查找的实现上，我们重点分析第二列。时间很多花费在第247行。除了这个递归调用，其它时间花费较高的是 242、246和250行。分析得知map对于一些特殊的查找并不总是有效，所以我们可以用<code>[]int</code>代替<code>map [*BasicBlock]int</code>，根据索引查找更有效。</p>
<p>Go team根据分析修改了代码实现，再一次运行测试，果然有效。</p>
<p>整个源代码在 <a href="https://code.google.com/archive/p/benchgraffiti/source/default/source" target="_blank" rel="external">google code</a> 上可以下载，你可以测试演练一把。</p>
<p>测试修改后的结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">make</span> havlak2.prof</div><div class="line">./havlak2 -cpuprofile=havlak2.prof</div><div class="line"># of loops:<span class="number"> 76000</span> (including<span class="number"> 1</span> artificial root node)</div><div class="line">$ <span class="keyword">go</span> tool pprof havlak2 havlak2.prof</div><div class="line">Welcome to pprof!  For help, <span class="keyword">type</span> <span class="string">'help'</span>.</div><div class="line">(pprof)</div><div class="line">(pprof) top5</div><div class="line">Total:<span class="number"> 1652</span> samples</div><div class="line">    <span class="number"> 197</span> <span class="number"> 11.9</span>% <span class="number"> 11.9</span>%     <span class="number"> 382</span> <span class="number"> 23.1</span>% scanblock</div><div class="line">    <span class="number"> 189</span> <span class="number"> 11.4</span>% <span class="number"> 23.4</span>%    <span class="number"> 1549</span> <span class="number"> 93.8</span>% main.FindLoops</div><div class="line">    <span class="number"> 130</span>  <span class="number"> 7.9</span>% <span class="number"> 31.2</span>%     <span class="number"> 152</span>  <span class="number"> 9.2</span>% sweepspan</div><div class="line">    <span class="number"> 104</span>  <span class="number"> 6.3</span>% <span class="number"> 37.5</span>%     <span class="number"> 896</span> <span class="number"> 54.2</span>% runtime.mallocgc</div><div class="line">     <span class="number"> 98</span>  <span class="number"> 5.9</span>% <span class="number"> 43.5</span>%     <span class="number"> 100</span>  <span class="number"> 6.1</span>% flushptrbuf</div><div class="line">(pprof)</div></pre></td></tr></table></figure>

<p><code>main.DFS</code>不再出现在前几个占用时间较多的函数列表中，但是内存分配和垃圾回收占用确很多。使用<code>-memprofile</code>参数监控内存：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> memprofile = flag.String(<span class="string">"memprofile"</span>, <span class="string">""</span>, <span class="string">"write memory profile to this file"</span>)</div><div class="line">...</div><div class="line"></div><div class="line">    FindHavlakLoops(cfgraph, lsgraph)</div><div class="line">    <span class="keyword">if</span> *memprofile != <span class="string">""</span> {</div><div class="line">        f, err := os.Create(*memprofile)</div><div class="line">        <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">            log.Fatal(err)</div><div class="line">        }</div><div class="line">        pprof.WriteHeapProfile(f)</div><div class="line">        f.Close()</div><div class="line">        <span class="keyword">return</span></div><div class="line">    }</div></pre></td></tr></table></figure>

<p>执行程序，得到内存采样数据：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ make havlak3.mprof</div><div class="line">go build havlak3.go</div><div class="line">./havlak3 -memprofile=havlak3.mprof</div><div class="line">$</div></pre></td></tr></table></figure>

<p>使用<code>go tool pprof</code>分析采样数据：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ go tool pprof havlak3 havlak3.mprof</div><div class="line">Adjusting heap profiles <span class="keyword">for</span> <span class="number">1</span>-in-<span class="number">524288</span> sampling rate</div><div class="line">Welcome to pprof!  For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">'help'</span>.</div><div class="line">(pprof) top5</div><div class="line">Total: <span class="number">82.4</span> MB</div><div class="line">    <span class="number">56.3</span>  <span class="number">68.4</span>%  <span class="number">68.4</span>%     <span class="number">56.3</span>  <span class="number">68.4</span>% main.FindLoops</div><div class="line">    <span class="number">17.6</span>  <span class="number">21.3</span>%  <span class="number">89.7</span>%     <span class="number">17.6</span>  <span class="number">21.3</span>% main.(*CFG).CreateNode</div><div class="line">     <span class="number">8.0</span>   <span class="number">9.7</span>%  <span class="number">99.4</span>%     <span class="number">25.6</span>  <span class="number">31.0</span>% main.NewBasicBlockEdge</div><div class="line">     <span class="number">0.5</span>   <span class="number">0.6</span>% <span class="number">100.0</span>%      <span class="number">0.5</span>   <span class="number">0.6</span>% itab</div><div class="line">     <span class="number">0.0</span>   <span class="number">0.0</span>% <span class="number">100.0</span>%      <span class="number">0.5</span>   <span class="number">0.6</span>% fmt.init</div><div class="line">(pprof)</div></pre></td></tr></table></figure>

<p><code>FindLoops</code>函数分配了大约56.3M内存，占总分配内存82.4M的68.4%。<br><code>CreateNode</code>分配了17.6M的内存。</p>
<p><code>list FindLoop</code>可以显示函数的详细的内存分配：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">(pprof) list FindLoops</div><div class="line">Total: <span class="number">82.4</span> MB</div><div class="line">ROUTINE ====================== main.FindLoops <span class="keyword">in</span> /home/rsc/g/benchgraffiti/havlak/havlak3.go</div><div class="line">  <span class="number">56.3</span>   <span class="number">56.3</span> Total MB (flat / cumulative)</div><div class="line">...</div><div class="line">   <span class="number">1.9</span>    <span class="number">1.9</span>  <span class="number">268</span>:     nonBackPreds := make([]map[int]bool, size)</div><div class="line">   <span class="number">5.8</span>    <span class="number">5.8</span>  <span class="number">269</span>:     backPreds := make([][]int, size)</div><div class="line">     .      .  <span class="number">270</span>:</div><div class="line">   <span class="number">1.9</span>    <span class="number">1.9</span>  <span class="number">271</span>:     number := make([]int, size)</div><div class="line">   <span class="number">1.9</span>    <span class="number">1.9</span>  <span class="number">272</span>:     header := make([]int, size, size)</div><div class="line">   <span class="number">1.9</span>    <span class="number">1.9</span>  <span class="number">273</span>:     types := make([]int, size, size)</div><div class="line">   <span class="number">1.9</span>    <span class="number">1.9</span>  <span class="number">274</span>:     last := make([]int, size, size)</div><div class="line">   <span class="number">1.9</span>    <span class="number">1.9</span>  <span class="number">275</span>:     nodes := make([]*UnionFindNode, size, size)</div><div class="line">     .      .  <span class="number">276</span>:</div><div class="line">     .      .  <span class="number">277</span>:     <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ {</div><div class="line">   <span class="number">9.5</span>    <span class="number">9.5</span>  <span class="number">278</span>:             nodes[i] = new(UnionFindNode)</div><div class="line">     .      .  <span class="number">279</span>:     }</div><div class="line">...</div><div class="line">     .      .  <span class="number">286</span>:     <span class="keyword">for</span> i, bb := range cfgraph.Blocks {</div><div class="line">     .      .  <span class="number">287</span>:             number[bb.Name] = unvisited</div><div class="line">  <span class="number">29.5</span>   <span class="number">29.5</span>  <span class="number">288</span>:             nonBackPreds[i] = make(map[int]bool)</div><div class="line">     .      .  <span class="number">289</span>:     }</div><div class="line">...</div></pre></td></tr></table></figure>

<p>问题出在第28行，还是map对象。<br>如果我们使用<code>--inuse_objects</code>参数,它将显示分配的对象数量而不是大小：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">$ go tool pprof --inuse_objects havlak3 havlak3.mprof</div><div class="line">Adjusting heap profiles <span class="keyword">for</span> <span class="number">1</span>-in-<span class="number">524288</span> sampling rate</div><div class="line">Welcome to pprof!  For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">'help'</span>.</div><div class="line">(pprof) list FindLoops</div><div class="line">Total: <span class="number">1763108</span> objects</div><div class="line">ROUTINE ====================== main.FindLoops <span class="keyword">in</span> /home/rsc/g/benchgraffiti/havlak/havlak3.go</div><div class="line"><span class="number">720903</span> <span class="number">720903</span> Total objects (flat / cumulative)</div><div class="line">...</div><div class="line">     .      .  <span class="number">277</span>:     <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ {</div><div class="line"><span class="number">311296</span> <span class="number">311296</span>  <span class="number">278</span>:             nodes[i] = new(UnionFindNode)</div><div class="line">     .      .  <span class="number">279</span>:     }</div><div class="line">     .      .  <span class="number">280</span>:</div><div class="line">     .      .  <span class="number">281</span>:     // Step a:</div><div class="line">     .      .  <span class="number">282</span>:     //   - initialize all nodes as unvisited.</div><div class="line">     .      .  <span class="number">283</span>:     //   - depth-first traversal and numbering.</div><div class="line">     .      .  <span class="number">284</span>:     //   - unreached BB<span class="string">'s are marked as dead.</span></div><div class="line">     .      .  285:     //</div><div class="line">     .      .  286:     for i, bb := range cfgraph.Blocks {</div><div class="line">     .      .  287:             number[bb.Name] = unvisited</div><div class="line">409600 409600  288:             nonBackPreds[i] = make(map[int]bool)</div><div class="line">     .      .  289:     }</div><div class="line">...</div><div class="line">(pprof)</div></pre></td></tr></table></figure>

<p>原因map会保存一个键值对，太浪费空间，可以用一个slice代替，当然程序逻辑要求要保存一个不重复的对象，所以我们可以提供一个辅助方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> appendUnique(a []<span class="typename">int</span>, x <span class="typename">int</span>) []<span class="typename">int</span> {</div><div class="line">    <span class="keyword">for</span> _, y := <span class="keyword">range</span> a {</div><div class="line">        <span class="keyword">if</span> x == y {</div><div class="line">            <span class="keyword">return</span> a</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="built_in">append</span>(a, x)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>测试内存和CPU都比最开始的程序要好很多。</p>
<p>web 命令也可以显示内存分配和垃圾回收的占比图<code>(pprof) web mallocgc</code>：</p>
<p><img src="profiling-go-programs_havlak4a-mallocgc.png" alt=""></p>
<p>如果你觉得图中太多节点不好分析，可以忽略占比小于 10%的节点：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ go tool pprof --nodefraction=<span class="number">0.1</span> havlak4 havlak4.prof</div><div class="line">Welcome to pprof!  For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">'help'</span>.</div><div class="line">(pprof) web mallocgc</div></pre></td></tr></table></figure>

<p>这节上面的分析翻译自Go的官方文档。我觉得官方的这篇文档很详细，很好的演示了如何对一个性能有问题的命令行程序进行代码分析。</p>
<p>除了上面的两个profile,Go还提供了heap profile、block profile、trace信息。</p>
<p>如果你正在开发HTTP程序，你可以使用<code>net/http/pprof</code>包来得到这些监控数据。</p>
<p>在包引入时增加：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> _ <span class="string">"net/http/pprof"</span></div></pre></td></tr></table></figure>

<p>它会增加一些handler在/debug/pprof/下。你可以直接运行<code>go tool pprof</code>访问这些链接:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">go tool pprof http://localhost:<span class="number">6060</span>/debug/pprof/profile   <span class="comment"># 30-second CPU profile</span></div><div class="line">go tool pprof http://localhost:<span class="number">6060</span>/debug/pprof/heap      <span class="comment"># heap profile</span></div><div class="line">go tool pprof http://localhost:<span class="number">6060</span>/debug/pprof/block     <span class="comment"># goroutine blocking profile</span></div></pre></td></tr></table></figure>

<p>你可以访问<code>http://localhost:6060/debug/pprof</code>查看这些profile。</p>
<p>可以看一下这些profile handler如何配置的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> init() {</div><div class="line">    		http.Handle(<span class="string">"/debug/pprof/"</span>, http.HandlerFunc(Index))</div><div class="line">    		http.Handle(<span class="string">"/debug/pprof/cmdline"</span>, http.HandlerFunc(Cmdline))</div><div class="line">    		http.Handle(<span class="string">"/debug/pprof/profile"</span>, http.HandlerFunc(Profile))</div><div class="line">    		http.Handle(<span class="string">"/debug/pprof/symbol"</span>, http.HandlerFunc(Symbol))</div><div class="line">    		http.Handle(<span class="string">"/debug/pprof/trace"</span>, http.HandlerFunc(Trace))</div><div class="line">    	}</div></pre></td></tr></table></figure>

<p>可以看到它们设置在缺省的Mux上。所以如果你使用自己的Mux，或者使用第三方的框架，你可以模仿这个实现自己添建，甚至加上访问权限的控制。</p>
<p>具体可以看一个<code>Profile</code>方法的实现:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Profile(w http.ResponseWriter, r *http.Request) {</div><div class="line">    		sec, _ := strconv.ParseInt(r.FormValue(<span class="string">"seconds"</span>),<span class="number"> 10</span>,<span class="number"> 64</span>)</div><div class="line">    		<span class="keyword">if</span> sec ==<span class="number"> 0</span> {</div><div class="line">    			sec =<span class="number"> 30</span></div><div class="line">   		}</div><div class="line"></div><div class="line">   		<span class="comment">// Set Content Type assuming StartCPUProfile will work,</span></div><div class="line">   		<span class="comment">// because if it does it starts writing.</span></div><div class="line">   		w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"application/octet-stream"</span>)</div><div class="line">   		<span class="keyword">if</span> err := pprof.StartCPUProfile(w); err != <span class="constant">nil</span> {</div><div class="line">   			<span class="comment">// StartCPUProfile failed, so no writes yet.</span></div><div class="line">   			<span class="comment">// Can change header back to text content</span></div><div class="line">   			<span class="comment">// and send error code.</span></div><div class="line">   			w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"text/plain; charset=utf-8"</span>)</div><div class="line">   			w.WriteHeader(http.StatusInternalServerError)</div><div class="line">   			fmt.Fprintf(w, <span class="string">"Could not enable CPU profiling: %s\n"</span>, err)</div><div class="line">   			<span class="keyword">return</span></div><div class="line">   		}</div><div class="line">   		sleep(w, time.Duration(sec)*time.Second)</div><div class="line">   		pprof.StopCPUProfile()</div><div class="line">   	}</div></pre></td></tr></table></figure>

<p>可见它会暂停n秒取得采样数据后才完全返回给客户端。</p>
<p>参考</p>
<ul>
<li><a href="https://golang.org/pkg/net/http/pprof/" target="_blank" rel="external">https://golang.org/pkg/net/http/pprof/</a></li>
<li><a href="https://golang.org/pkg/runtime/pprof/" target="_blank" rel="external">https://golang.org/pkg/runtime/pprof/</a></li>
<li><a href="https://blog.golang.org/profiling-go-programs" target="_blank" rel="external">https://blog.golang.org/profiling-go-programs</a></li>
<li><a href="https://github.com/gperftools/gperftools" target="_blank" rel="external">https://github.com/gperftools/gperftools</a></li>
<li><a href="http://saml.rilspace.org/profiling-and-creating-call-graphs-for-go-programs-with-go-tool-pprof" target="_blank" rel="external">http://saml.rilspace.org/profiling-and-creating-call-graphs-for-go-programs-with-go-tool-pprof</a></li>
<li><a href="http://stackoverflow.com/questions/30871691/cant-get-golang-pprof-working" target="_blank" rel="external">http://stackoverflow.com/questions/30871691/cant-get-golang-pprof-working</a></li>
<li><a href="https://signalfx.com/blog/a-pattern-for-optimizing-go-2/" target="_blank" rel="external">https://signalfx.com/blog/a-pattern-for-optimizing-go-2/</a></li>
<li><a href="http://blog.ralch.com/tutorial/golang-performance-and-memory-analysis/" target="_blank" rel="external">http://blog.ralch.com/tutorial/golang-performance-and-memory-analysis/</a></li>
</ul>
<h3 id="benchmark测试">benchmark测试</h3>
<p>Go提供了benchmark的通用解决方案，但我不准备在本文中介绍了，而是和Go测试技术放在一起介绍。</p>
<p>Go 测试技术一文会介绍官方的测试方法、benchmark的测试方法，示例代码的编写，文档的生成等。</p>
<p>在这里需要提到的是<code>go test</code>提供了生成这些profile数据的参数<code>cpuprofile</code>、``memprofile等，所以很容易的分析测试时的性能的问题。</p>
<h3 id="Go调试参数">Go调试参数</h3>
<p>go的运行时<code>runtime</code>提供了一堆的参数。</p>
<p><code>GOGC</code>环境变量可以设置触发GC时的内存占用。<code>runtime/debug</code>的<code>SetFGCPercent</code>可以在运行时修改这个参数。</p>
<p>另一个重要的环境变量就是<code>GODEBUG</code>。它包含多个参数可以逗号分隔<code>name=val</code>设置多个变量：</p>
<pre class="highlight">
allocfreetrace: 设置 allocfreetrace=1 会监控每次分配，但因每次分配和释放的栈信息（stack trace）

cgocheck: 设置 cgocheck=0 禁用所有cgo检查将Go指针传递给非Go代码是否正确。
cgocheck=1 (缺省值) 轻量级检查。cgocheck=2 重量级检查。

efence: 设置 efence=1 导致分配器 allocator将每个对象分配在一个唯一的页page上，地址不重用。

gccheckmark: 设置 gccheckmark=1 允许垃圾回收器执行并发mark阶段的校验。会导致Stop The World。

gcpacertrace: 设置 gcpacertrace=1 会让来几回收器打印出concurrent pacer的内部状态。

gcshrinkstackoff: 设置 gcshrinkstackoff=1 则禁止将 goroutines 的栈缩小为更小栈。

gcstackbarrieroff: 设置 gcstackbarrieroff=1 禁用stack barriers，会影响垃圾回收器的重复搜索栈的功能。

gcstackbarrierall: 设置 gcstackbarrierall=1 会为每个栈帧安装一 stack barriers。

gcstoptheworld: 设置 gcstoptheworld=1 则禁用并发垃圾回收,每次回收都会触发STW。设置gcstoptheworld=2则禁用垃圾回收后的concurrent sweeping。

gctrace: 设置 gctrace=1导致每次垃圾回收器触发一行日志，包含内存回收的概要信息和暂停的时间。设置gctrace=2起同样的效果，but also repeats each collection。格式如下：

    gc # @#s #%: #+#+# ms clock, #+#/#/#+# ms cpu, #->#-># MB, # MB goal, # P
where the fields are as follows:
    gc #        GC id,每次GC加一
    @#s         程序启动后的时间，单位秒
    #%          程序启动后GC所用的时间比
    #+...+#     此次GC所用的wall-clock/CPU时间
    #->#-># MB  GC开始时的堆大小, GC结束时的堆大小, 活着的(live)堆大小
    # MB goal   总的堆大小
    # P         CPU使用数
垃圾回收分为下面的几个阶段：stop-the-world (STW) sweep termination, concurrent
mark and scan, and STW mark termination。 mark/scan的CPU时间又分为 assist time (GC performed in
line with allocation), background GC time, and idle GC time。
如果日志后以"(forced)"结尾,则GC通过runtime.GC()调用执行，此时所有的阶段都是STW.

memprofilerate: 设置 memprofilerate=X 会更新runtime.MemProfileRate的值。0则禁用这个profie。

invalidptr: 默认设为invalidptr=1, 如果指针被赋予一个无效值,会引起程序的崩溃，设置该值为0，会停止该检查，
0只能临时用于查找bug，真正的解决方法是不要把整数类型的值存在指针变量里面。

sbrk: 设置 sbrk=1 会使用实验性的实现替换memory allocator 和 garbage collector。

scavenge: scavenge=1 允许heap scavenger的debug模式。

scheddetail: 设置 schedtrace=X 和 scheddetail=1 会导致goroutine调度器每个X毫秒输出多行调度信息。

schedtrace: 设置 schedtrace=X导致调度器每个X秒输出一行调度器的概要信息。
</pre>

<p>包<code>runtime/debug</code>提供了程序设置/查看运行时的一些方法。</p>
<p>垃圾回收信息相当有用，有一个工具提供了可视化显示垃圾回收的信息，拿就是<a href="https://github.com/davecheney/gcvis" target="_blank" rel="external">gcvis</a>,你可以通过<br><code>env GOMAXPROCS=4 gcvis godoc -index -http=:6060</code><br>或者<br><code>GODEBUG=gctrace=1 godoc -index -http=:6060 2&gt;&amp;1 | gcvis</code><br>或者</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">GODEBUG=gctrace=<span class="number">1</span> godoc -index -<span class="keyword">http</span>=:<span class="number">6060</span> <span class="number">2</span>&gt; <span class="keyword">stderr</span>.<span class="built_in">log</span></div><div class="line">cat <span class="keyword">stderr</span>.<span class="built_in">log</span> | gcvis</div></pre></td></tr></table></figure>

<p>来执行。</p>
<p>下面是一个图例：<br><img src="gcvis.png" alt=""></p>
<p>参考</p>
<ul>
<li><a href="https://golang.org/pkg/runtime/" target="_blank" rel="external">https://golang.org/pkg/runtime/</a></li>
<li><a href="http://golanghome.com/post/158" target="_blank" rel="external">http://golanghome.com/post/158</a></li>
<li><a href="http://dave.cheney.net/2014/07/11/visualising-the-go-garbage-collector" target="_blank" rel="external">http://dave.cheney.net/2014/07/11/visualising-the-go-garbage-collector</a></li>
<li><a href="https://holys.im/2016/07/01/monitor-golang-gc/" target="_blank" rel="external">https://holys.im/2016/07/01/monitor-golang-gc/</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>本章重点介绍Go程序的调试和性能监控。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]JVM上最快的Bloom filter实现]]></title>
    <link href="http://colobu.com/2016/07/02/bloom-filter-for-scala/"/>
    <id>http://colobu.com/2016/07/02/bloom-filter-for-scala/</id>
    <published>2016-07-02T15:52:19.000Z</published>
    <updated>2016-07-04T02:03:17.000Z</updated>
    <content type="html"><![CDATA[<p>英文原始出处: <a href="https://alexandrnikitin.github.io/blog/bloom-filter-for-scala/" target="_blank" rel="external">Bloom filter for Scala, the fastest for JVM</a></p>
<p>本文介绍的是我用Scala实现的Bloom filter。 源代码在<a href="https://github.com/alexandrnikitin/bloom-filter-scala" target="_blank" rel="external">github</a>上。依照<a href="">性能测试结果</a>，它是JVM上的<strong>最快</strong>的Bloom filter实现。零分配(Zero-allocation)和高度优化的代码。 无内存限制，所以没有包含元素的数量限制和可控的误报率(false positive rate)。<br>扩展：可插拔的Hash算法，任意的元素类型。<br>没错，它使用<code>sun.misc.unsafe</code>。<br><a id="more"></a></p>
<h3 id="介绍">介绍</h3>
<blockquote>
<p>&quot;A Bloom filter is a space-efficient probabilistic data structure that is used to test whether an element is a member of a set. False positive matches are possible, but false negatives are not. In other words, a query returns either “possibly in set” or “definitely not in set”. Elements can be added to the set, but not removed,” says <a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank" rel="external">Wikipedia</a>.</p>
<p>Bloom filter 是由 Howard Bloom 在 1970 年提出的二进制向量数据结构，它具有很好的空间和时间效率，被用来检测一个元素是不是集合中的一个成员。如果检测结果为是，该元素不一定在集合中；但如果检测结果为否，该元素一定不在集合中。因此Bloom filter具有100%的召回率。这样每个检测请求返回有“在集合内（可能错报）”和“不在集合内（绝对不在集合内）”两种情况，可见 Bloom filter 是牺牲了正确率和时间以节省空间。 引自 <a href="http://baike.baidu.com/view/1912944.htm" target="_blank" rel="external">百度百科</a></p>
</blockquote>
<p>简而言之，Bloom filter是:</p>
<ul>
<li>优化内存占用， 当整个集合太大而不能全部放到内存中。Optimization for memory. It comes into play when you cannot put whole set into memory.</li>
<li>解决成员存在性的问题。它可以回答下面的问题：一个元素属于一个集合还是不属于？</li>
<li>概率(有损)数据结构。它可以返回一个元素有多大的概率属于一个集合</li>
</ul>
<p>后面这篇文章介绍的Bloom filter很详尽 - <a href="https://sc5.io/posts/what-are-bloom-filters-and-why-are-they-useful/" target="_blank" rel="external">“What are Bloom filters, and why are they useful?”</a> by <a href="https://twitter.com/maxpagels" target="_blank" rel="external">@Max Pagels</a>。我没必要再献丑了，如果你还不熟悉Bloom filter不妨看一看。</p>
<h3 id="为何再造轮子？">为何再造轮子？</h3>
<p>因为性能或者内存限制的原因，已有的Bloom filter并不能满足我们的需求，或者你发现你可以做的更好。坦率的说，都不是。只不过有时候你厌倦了而已。(作者吐槽，可忽略之)</p>
<p>主要的原因是性能。当开发高性能和低延迟的系统的时候，你可不想被外部的库所拖累，甚至分配了很多的内存。你的注意力应该集中在业务逻辑上，依赖的库应该尽可能的有效。</p>
<p>另一个原因还是内存限制。所有的实现都会因为JVM数组的大小的限制而受限制。JVM中，数字使用整数integer做索引，所以数组的最大长度也就是整数的最大值<strong>2147483647</strong>。如果我们创建一个元素类型为long的数组存储比特位bit的值，那么最多我们可以存储64 bit * 2147483647 = 137438953408 bits,大概需要15 GB左右的内存。你可以放入大约10000000000左右的元素到误报率为0.1%的Bloom filter。这对于大部分软件来说足够了，但是当你处理大数据，比如URL，图标广告，实时竞价请求或者是事件流的时候，100亿的数据只是一个起步量。当然你可以有一些变通的办法：部署多个Bloom filter,将它们分布到多个节点，或者设计你的软件适应这些限制，但这些办法并不总是有效，可能花费较高护着不满足你的架构。</p>
<p>让我们看看当前已有的一些Bllom filter的实现。</p>
<h4 id="Google_guava">Google guava</h4>
<p><a href="https://github.com/google/guava" target="_blank" rel="external">Guava</a>是Google开发的一个高质量的核心库，它包含集合、基本数据、并发、I/O、Cache等模块。 它也包含一个<a href="https://github.com/google/guava/wiki/HashingExplained#bloomfilter" target="_blank" rel="external">Bloom filter</a>实现。Guava是我的初始选择，它经受考验、也很快，但是……</p>
<p>令人咂舌的是，它会额外分配内存。我使用Google的<a href="https://github.com/google/allocation-instrumenter" target="_blank" rel="external">Allocation Instrumenter</a>监控所有的分配allocation。下面的分配监控显示了检查包含100字符的字符串是否存在于一个Bloom filter中:</p>
<pre class="highlight">
I just allocated the object [B@39420d59 of type byte whose size is 40 It's an array of size 23
I just allocated the object java.nio.HeapByteBuffer[pos=0 lim=23 cap=23] of type java/nio/HeapByteBuffer whose size is 48
I just allocated the object com.google.common.hash.Murmur3_128HashFunction$Murmur3_128Hasher@5dd227b7 of type com/google/common/hash/Murmur3_128HashFunction$Murmur3_128Hasher whose size is 48
I just allocated the object [B@3d3b852e of type byte whose size is 24 It's an array of size 1
I just allocated the object [B@14ba7f15 of type byte whose size is 24 It's an array of size 1
I just allocated the object sun.nio.cs.UTF_8$Encoder@55cb3b7 of type sun/nio/cs/UTF_8$Encoder whose size is 56
I just allocated the object [B@497fd334 of type byte whose size is 320 It's an array of size 300
I just allocated the object [B@280c3dc0 of type byte whose size is 312 It's an array of size 296
I just allocated the object java.nio.HeapByteBuffer[pos=0 lim=296 cap=296] of type java/nio/HeapByteBuffer whose size is 48
I just allocated the object [B@6f89ad03 of type byte whose size is 32 It's an array of size 16
I just allocated the object java.nio.HeapByteBuffer[pos=0 lim=16 cap=16] of type java/nio/HeapByteBuffer whose size is 48
I just allocated the object 36db757cdd5ae408ef61dca2406d0d35 of type com/google/common/hash/HashCode$BytesHashCode whose size is 16
</pre>

<p>一共1016个字节。想象一下，我们计算一个短字符串的hash值，检查它相应的bit位设置已经设置，它需要分配大于1Kb的数据。太多了。那你可能会说内存占用已经很小了，好吧，当你做一个单独的微性能测试的时候，影响不是很大，但是在产品级的环境中，它会变得更糟：它会影响GC，导致分配变慢，触发GC，导致更高的延迟等。</p>
<p>不管怎样，review一下代码会很有趣，有时候你会发现一些复活节彩蛋在里面，比如下面的例子：<br><img src="guava-review.png" alt=""></p>
<p>这些注释行来自Naughty by Nature说唱组合的歌曲“O.P.P.”,在上世纪90年代早期很流行。这段代码的开发者可能那时是四五十岁的人(偏题了)。</p>
<h4 id="Twitter_Algebird">Twitter Algebird</h4>
<p>Algebird &quot;为Scala提供的抽象代数库，这些代码主要是用于建立聚合系统（通过Scalding或Storm）。 它是函数式functional，不可变<br>immutable, monadic,但是非常非常非常慢，并且仅仅支持字符串作为元素类型。字符串是万能的数据格式，你可硬用它存任何值 :) 。</p>
<p>它使用人人皆爱的MurmurHash3算法，它是最好的通用的hash算法。它计算出128-bit的 hash值，分割成4个32-bit的数字。然后它为每个32-bit的数字设置相应的位，而不是整个的hash值。这是相当有争议的设计，我进行了粗略的测试，测试表明Teitter Bloom filter有超过 10% 的误报率。</p>
<p>更深一步，有趣的是Twitter Bloom filter 底层使用 <a href="https://github.com/lemire/javaewah" target="_blank" rel="external">EWAHCompressedBitmap</a>,它是一个压缩的可替代BitSet的实现。它专门为内存占用而优化，适合稀疏数据的场景。比如，如果你的位数从1000000开始，EWAH可以优化set而不会为前面的0位分配内存。集合的操作如交集、并集和差也更快。但是随机访问却很慢。 而且hash的目标就是有一个均匀分布的hash值，越均匀越好。这两点就排除了使用压缩bitset的好处。我做了一点点测试来检查整个的内存分配，结果显示Twitter Bloom filter比我的实现还要分配更多的内存。 同样，在我看来，Twitter的实现也是相当有争议。</p>
<p>内存检查的结果很长我就不贴了。为包含100个字符的字符串的检查要分配<strong>1808</strong>字节，我哭!</p>
<p>同样，它是函数式functional, 不可变immutable, 使用持久化数据结构, monad, 但这些不足以让我们使用它。 大话说在前， 它的读性能要比我的实现慢10倍，写要慢100倍。</p>
<h4 id="ScalaNLP’s_Breeze">ScalaNLP’s Breeze</h4>
<blockquote>
<p>Breeze is a generic, clean and powerful Scala numerical processing library… Breeze is a part of ScalaNLP project, a scientific computing platform for Scala</p>
</blockquote>
<p>Breeze的介绍看起来很有吸引力，如清爽的新风，但是，有一个<a href="https://github.com/scalanlp/breeze/blob/c12763387cb0741e6d588435d7da92b505f12843/math/src/main/scala/breeze/util/BloomFilter.scala#L36" target="_blank" rel="external">花招在它的实现里</a>。它直接使用对象的hash值。 &quot;WTF,我钟爱的MurmurHash3哪去了&quot;，你可能会问。MurmurHash3仅仅用来计算最终的对象的hash值，没错，它可以和任意类型一起工作，但是你不会知道你的大数据集的细微差别(编者按:较难理解，需要配合代码一起理解。 英文原意为：It’s used only for “finalizing” the object’s hash. Yeah, it works with any type out-of-the-box but if you don’t know that little nuance you are done with large datasets.)</p>
<p>测试中它会分配544字节，看看代码你会发现通用的Scala的问题：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> {</div><div class="line">  i &lt;- <span class="number">0</span> to numHashFunctions</div><div class="line">} <span class="keyword">yield</span> {</div><div class="line">  <span class="keyword">val</span> h = hash1 + i * hash2</div><div class="line">  <span class="keyword">val</span> nextHash = <span class="keyword">if</span> (h &lt; <span class="number">0</span>) ~h <span class="keyword">else</span> h</div><div class="line">  nextHash % numBuckets</div><div class="line">}</div></pre></td></tr></table></figure>

<p>看起来很简洁：for语句，延迟计算,漂亮的DSL。但是当它编译成Java代码的时候就不那么好看了，它会分配很多对象: intWrapper(), RichInt, Range.Inclusive, VectorBuilder/Vector, boxing/unboxing 等等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> (IndexedSeq)RichInt$.MODULE$.to$extension0(Predef$.MODULE$.intWrapper(<span class="number">0</span>), numHashFunctions()).map(<span class="keyword">new</span> Serializable(hash1, hash2) {</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">apply</span>(<span class="keyword">int</span> i)</div><div class="line">    {</div><div class="line">        <span class="keyword">return</span> apply$mcII$sp(i);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> apply$mcII$<span class="title">sp</span>(<span class="keyword">int</span> i)</div><div class="line">    {</div><div class="line">        <span class="keyword">int</span> h = hash1$<span class="number">1</span> + i * hash2$<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> nextHash = h &gt;= <span class="number">0</span> ? h : ~h;</div><div class="line">        <span class="keyword">return</span> nextHash % $outer.numBuckets();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">volatile</span> Object <span class="title">apply</span>(Object v1)</div><div class="line">    {</div><div class="line">        <span class="keyword">return</span> BoxesRunTime.boxToInteger(apply(BoxesRunTime.unboxToInt(v1)));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">0</span>L;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BloomFilter $outer;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> hash1$1;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> hash2$1;</div><div class="line"></div><div class="line">    <span class="keyword">public</span></div><div class="line">    {</div><div class="line">        <span class="keyword">if</span>(BloomFilter.<span class="keyword">this</span> == <span class="keyword">null</span>)</div><div class="line">        {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">null</span>;</div><div class="line">        } <span class="keyword">else</span></div><div class="line">        {</div><div class="line">            <span class="keyword">this</span>.$outer = BloomFilter.<span class="keyword">this</span>;</div><div class="line">            <span class="keyword">this</span>.hash1$<span class="number">1</span> = hash1$<span class="number">1</span>;</div><div class="line">            <span class="keyword">this</span>.hash2$<span class="number">1</span> = hash2$<span class="number">1</span>;</div><div class="line">            <span class="keyword">super</span>();</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line">, IndexedSeq$.MODULE$.canBuildFrom());</div></pre></td></tr></table></figure>

<p>震撼吗？我想你被震惊了。接下来看看我的实现。</p>
<h3 id="我是如何实现的？">我是如何实现的？</h3>
<p>一句话，我重新实现了Bloom filter的数据结构。源代码在<a href="https://github.com/alexandrnikitin/bloom-filter-scala" target="_blank" rel="external">github</a>上，可以通过<a href="https://mvnrepository.com/artifact/com.github.alexandrnikitin/bloom-filter_2.11" target="_blank" rel="external">maven repository引用</a>:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">libraryDependencies += <span class="string">"com.github.alexandrnikitin"</span> %% <span class="string">"bloom-filter"</span> % <span class="string">"0.3.1"</span></div></pre></td></tr></table></figure>

<p>下面是使用的例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> bloomfilter.mutable.BloomFilter</div><div class="line"></div><div class="line"><span class="keyword">val</span> expectedElements = <span class="number">1000</span></div><div class="line"><span class="keyword">val</span> falsePositiveRate = <span class="number">0.1</span></div><div class="line"><span class="keyword">val</span> bf = BloomFilter[String](expectedElements, falsePositiveRate)</div><div class="line">bf.add(<span class="string">"some string"</span>)</div><div class="line">bf.mightContain(<span class="string">"some string"</span>)</div><div class="line">bf.dispose()</div></pre></td></tr></table></figure>

<h4 id="Unsafe">Unsafe</h4>
<p>一个重要的设计就是底层使用<code>sun.misc.unsafe</code>包。使用它分配一块内存来保存bit，所以你需要主动dispose Bloom filter 实例和不受管的内存释放。而且我的实现还使用 <code>usafe</code>做了一些花招以避免内存分配，比如直接访问字符串内部的char数组。</p>
<h4 id="type_class模式">type class模式</h4>
<p>我的实现是可扩展的，你可以为任意类型使用任意的hash算法。它通过<strong>type class模式</strong>实现。如果你不熟悉它，你可以阅读<a href="https://twitter.com/kaffeecoder" target="_blank" rel="external">@Daniel Westheide</a>的文章 <a href="http://danielwestheide.com/blog/2013/02/06/the-neophytes-guide-to-scala-part-12-type-classes.html" target="_blank" rel="external">“The Neophyte’s Guide to Scala”</a>。</p>
<p>基本上，你所需的就是实现<code>CanGenerateHashFrom[From]</code> trait,就像这样:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">CanGenerateHashFrom</span>[<span class="title">From</span>] </span>{</div><div class="line">  <span class="keyword">def</span> generateHash(from: From): Long</div><div class="line">}</div></pre></td></tr></table></figure>

<p>不幸的是，它是<code>invariant</code>不变类型。我想实现为逆变类型contravariant但是Scala编译器不能正确的解决contravariant implicits,将来在<a href="http://dotty.epfl.ch/#so-features" target="_blank" rel="external">Dotty</a>编译器中会支持。</p>
<p>缺省地提供了一个<code>MurmurHash3</code>的通用实现。我使用Scala实现了它，比Guava、Algebird、Cassandra的实现更快（希望我没有犯错）。为<code>Long</code>、<code>String</code>、<code>Array[Byte]</code>提供可开箱即用的库。作为一个福利，为无限唯一性(unlimited uniqueness)提供了128bit的版本。</p>
<h4 id="零分配Zero-allocation">零分配Zero-allocation</h4>
<p>我的Bloom filter实现没有分配任何对象，代码被高度优化。我计划写一篇独立的文章来描述这些优化，敬请关注。通过一系列的<code>unsafe</code>技巧来实现的。下面是为String类型实现的 <code>CanGenerateHashFrom</code> trait:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">implicit <span class="class"><span class="keyword">object</span> <span class="title">CanGenerateHashFromString</span> <span class="keyword">extends</span> <span class="title">CanGenerateHashFrom</span>[<span class="title">String</span>] </span>{</div><div class="line"></div><div class="line">  <span class="keyword">import</span> scala.concurrent.util.Unsafe.{instance =&gt; unsafe}</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">val</span> valueOffset = unsafe.objectFieldOffset(classOf[String].getDeclaredField(<span class="string">"value"</span>))</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> generateHash(from: String): Long = {</div><div class="line">    <span class="keyword">val</span> value = unsafe.getObject(from, valueOffset).asInstanceOf[Array[Char]]</div><div class="line">    MurmurHash3Generic.murmurhash3_x64_64(value, <span class="number">0</span>, from.length, <span class="number">0</span>)</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>使用<code>unsafe.objectFieldOffset()</code>方法获取String类型的value字段，它是字符串底层的char数组。然后使用<code>unsafe.getObject()</code>方法访问字符数组,用来计算hash值。</p>
<p>不幸的是，128-bit的实现会分配一个对象。我在<code>(Long, Long)</code> tuple和 <code>ThreadLocal</code>的字段选择上很犹豫，对于整体的性能，没有影响，有什么意见吗？在我的有生之年我希望能看到<a href="http://mail.openjdk.java.net/pipermail/valhalla-dev/2016-June/001981.html" target="_blank" rel="external">JVM的值类型</a>, <a href="https://twitter.com/giltene" target="_blank" rel="external">@Gil Tene</a>的<a href="http://objectlayout.github.io/ObjectLayout/" target="_blank" rel="external">ObjectLayout</a>尝试实现它。</p>
<h4 id="限制">限制</h4>
<p>你可能已经注意到了，当前实现有一些限制。<code>CanGenerateHashFrom[From]</code> trait是不可变的invariant,它不允许回退到对象的<code>hashCode()</code>方法。你需要为你的类型实现它的hash算法。但我相信，为了性能这也是值得的。</p>
<p>并不是所有的JVM都支持，因为底层使用了“unsafe” 包，而且这也没有退路(fallback )的实现。</p>
<blockquote>
<p><code>sun.misc.Unsafe</code>至少从2004年Java1.4开始就存在于Java中了。在Java9中，为了提高JVM的可维护性，Unsafe和许多其他的东西一起都被作为内部使用类隐藏起来了。但是究竟是什么取代Unsafe不得而知。 摘自: <a href="http://www.importnew.com/14511.html" target="_blank" rel="external">http://www.importnew.com/14511.html</a></p>
</blockquote>
<h4 id="可以在Java中用它吗？">可以在Java中用它吗？</h4>
<p>可以，但是代码不会和Scala一样漂亮，当然你已经习惯了这一切。Java中没有implicit，而且Java编译器也不会帮你调用它。在Java中使用它很丑但是能工作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> bloomfilter.CanGenerateHashFrom;</div><div class="line"><span class="keyword">import</span> bloomfilter.mutable.BloomFilter;</div><div class="line"></div><div class="line"><span class="keyword">long</span> expectedElements = <span class="number">10000000</span>;</div><div class="line"><span class="keyword">double</span> falsePositiveRate = <span class="number">0.1</span>;</div><div class="line">BloomFilter&lt;<span class="keyword">byte</span>[]&gt; bf = BloomFilter.apply(</div><div class="line">        expectedElements,</div><div class="line">        falsePositiveRate,</div><div class="line">        CanGenerateHashFrom.CanGenerateHashFromByteArray$.MODULE$);</div><div class="line"></div><div class="line"><span class="keyword">byte</span>[] element = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</div><div class="line">bf.add(element);</div><div class="line">bf.mightContain(element);</div><div class="line">bf.dispose();</div></pre></td></tr></table></figure>

<h3 id="性能benchmark">性能benchmark</h3>
<p>我们都喜欢性能基准数据，对不？令人兴奋的数字在空中游荡，是那么的迷人。如果你准备写性能基准的测试，请使用<a href="http://openjdk.java.net/projects/code-tools/jmh/" target="_blank" rel="external">JMH</a>。 它是Oracle的性能工程师 <a href="https://www.youtube.com/watch?v=dQw4w9WgXcQ" target="_blank" rel="external">@Aleksey Shipilev</a>创建的一个微性能基准库： “for building, running, and analyzing nano/micro/milli/macro benchmarks written in Java and other languages targeting the JVM.”， <a href="https://twitter.com/ktosopl" target="_blank" rel="external">@Konrad Malawski</a>写了一个<a href="https://github.com/ktoso/sbt-jmh" target="_blank" rel="external">SBT的插件</a>。</p>
<p>下面是一个<code>String</code>类型的基准测试，其它类型的测试结果和此类似：</p>
<pre class="highlight">
[info] Benchmark                                              (length)   Mode  Cnt          Score         Error  Units
[info] alternatives.algebird.StringItemBenchmark.algebirdGet      1024  thrpt   20    1181080.172 ▒    9867.840  ops/s
[info] alternatives.algebird.StringItemBenchmark.algebirdPut      1024  thrpt   20     157158.453 ▒     844.623  ops/s
[info] alternatives.breeze.StringItemBenchmark.breezeGet          1024  thrpt   20    5113222.168 ▒   47005.466  ops/s
[info] alternatives.breeze.StringItemBenchmark.breezePut          1024  thrpt   20    4482377.337 ▒   19971.209  ops/s
[info] alternatives.guava.StringItemBenchmark.guavaGet            1024  thrpt   20    5712237.339 ▒  115453.495  ops/s
[info] alternatives.guava.StringItemBenchmark.guavaPut            1024  thrpt   20    5621712.282 ▒  307133.297  ops/s

// My Bloom filter
[info] bloomfilter.mutable.StringItemBenchmark.myGet              1024  thrpt   20   11483828.730 ▒  342980.166  ops/s
[info] bloomfilter.mutable.StringItemBenchmark.myPut              1024  thrpt   20   11634399.272 ▒   45645.105  ops/s
[info] bloomfilter.mutable._128bit.StringItemBenchmark.myGet      1024  thrpt   20   11119086.965 ▒   43696.519  ops/s
[info] bloomfilter.mutable._128bit.StringItemBenchmark.myPut      1024  thrpt   20   11303765.075 ▒   52581.059  ops/s
</pre>

<p>我的实现大致要比Goole Guava的实现快2倍， 比Twitter Algebird快10 ~ 80倍，其它的benchmark你可以在<a href="https://github.com/alexandrnikitin/bloom-filter-scala/tree/0e9d0ba103c314ae2c071a107ff7fbc48af4c904/benchmarks/src/main/scala" target="_blank" rel="external">github上的“benchmarks’模块</a>找到。</p>
<p>警告：这是在独立环境中的综合测试。通常吞吐率和延迟的差别要比产品环境中要大，因为它会对GC有压力，导致分配很慢，更高的延迟，触发GC等。</p>
<h3 id="用在哪里？">用在哪里？</h3>
<p>高性能和低延迟系统。</p>
<p>大数据和机器学习系统，有巨量唯一的数据。</p>
<h4 id="什么时候不用它?">什么时候不用它?</h4>
<p>如果你当前的解决方案已满足需求，大部分软件都不需要这么快。</p>
<p>你只信任那些大公司如Google、Twitter出品的已被证明的、经受考验的库。</p>
<p>你想要开箱即用的库。</p>
<h3 id="下一步">下一步</h3>
<p>欢迎你的意见和建议。下一步我会实现一个稳定的<a href="https://webdocs.cs.ualberta.ca/~drafiei/papers/DupDet06Sigmod.pdf" target="_blank" rel="external">(Stable) Bloom filter 数据结构</a>，因为目前没有好的实现。我计划研究一下 <a href="https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf" target="_blank" rel="external">Cuckoo filer 数据结构</a>。对此有何经验吗？</p>
<p>谢谢</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>英文原始出处: <a href="https://alexandrnikitin.github.io/blog/bloom-filter-for-scala/" target="_blank" rel="external">Bloom filter for Scala, the fastest for JVM</a></p>
<p>本文介绍的是我用Scala实现的Bloom filter。 源代码在<a href="https://github.com/alexandrnikitin/bloom-filter-scala" target="_blank" rel="external">github</a>上。依照<a href="">性能测试结果</a>，它是JVM上的<strong>最快</strong>的Bloom filter实现。零分配(Zero-allocation)和高度优化的代码。 无内存限制，所以没有包含元素的数量限制和可控的误报率(false positive rate)。<br>扩展：可插拔的Hash算法，任意的元素类型。<br>没错，它使用<code>sun.misc.unsafe</code>。<br>]]>
    
    </summary>
    
      <category term="Scala" scheme="http://colobu.com/categories/Scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Go net/http 超时机制完全手册]]></title>
    <link href="http://colobu.com/2016/07/01/the-complete-guide-to-golang-net-http-timeouts/"/>
    <id>http://colobu.com/2016/07/01/the-complete-guide-to-golang-net-http-timeouts/</id>
    <published>2016-07-01T06:56:19.000Z</published>
    <updated>2016-07-25T01:22:50.000Z</updated>
    <content type="html"><![CDATA[<p>英文原始出处: <a href="https://blog.cloudflare.com/the-complete-guide-to-golang-net-http-timeouts/" target="_blank" rel="external">The complete guide to Go net/http timeouts</a>, 作者: <a href="https://blog.cloudflare.com/author/filippo/" target="_blank" rel="external">Filippo Valsorda</a></p>
<p>当用Go写HTTP的服务器和客户端的时候，超时处理总是最易犯错和最微妙的地方之一。错误可能来自很多地方，一个错误可能等待很长时间没有结果，直到网络故障或者进程挂起。</p>
<p>HTTP是一个复杂的、多阶段(multi-stage)协议，所以没有一个放之四海而皆准的超时解决方案，比如一个流服务、一个JSON API和一个Comet服务对超时的需求都不相同， 往往默认值不是你想要的。</p>
<p>本文我将拆解需要超时设置的各个阶段，看看用什么不同的方式去处理它， 包括服务器端和客户端。</p>
<a id="more"></a>
<h3 id="SetDeadline">SetDeadline</h3>
<p>首先，你需要了解Go实现超时的网络原语(primitive): <strong>Deadline</strong> (最后期限)。</p>
<p><code>net.Conn</code>为Deadline提供了多个方法<code>Set[Read|Write]Deadline(time.Time)</code>。Deadline是一个绝对时间值，当到达这个时间的时候，所有的 I/O 操作都会失败，返回超时(timeout)错误。</p>
<p><strong>Deadline不是超时</strong>(timeout)。一旦设置它们永久生效(或者直到下一次调用SetDeadline), 不管此时连接是否被使用和怎么用。所以如果想使用<code>SetDeadline</code>建立超时机制，你不得不每次在<code>Read/Write</code>操作之前调用它。</p>
<p>你可能不想自己调用<code>SetDeadline</code>, 而是让<code>net/http</code>代替你调用，所以你可以调用更高级的timeout方法。但是请记住，所有的超时的实现都是基于Deadline,  所以它们不会每次接收或者发送重新设置这个值(so they <strong>do NOT reset every time data is sent or received</strong>)。</p>
<blockquote>
<p>江南雨的指正：<br>应该是由于“Deadline是一个绝对时间值”，不是真的超时机制，所以作者特别提醒，这个值不会自动重置的，需要每次手动设置。</p>
</blockquote>
<h3 id="服务器端超时设置">服务器端超时设置</h3>
<p><img src="server-timeout.png" alt=""></p>
<p>对于暴露在网上的服务器来说，为客户端连接设置超时至关重要，否则巨慢的或者隐失的客户端可能导致文件句柄无法释放，最终导致服务器出现下面的错误:</p>
<pre class="highlight">
http: Accept error: accept tcp [::]:80: accept4: too many open files; retrying in 5ms  
</pre>


<p><code>http.Server</code>有两个设置超时的方法: <code>ReadTimeout</code> 和 <code>and</code>WriteTimeout`。你可以显示地设置它们：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">srv := &http.Server{  </div><div class="line">    ReadTimeout:<span class="number"> 5</span> * time.Second,</div><div class="line">    WriteTimeout:<span class="number"> 10</span> * time.Second,</div><div class="line">}</div><div class="line">log.Println(srv.ListenAndServe())</div></pre></td></tr></table></figure>

<p><code>ReadTimeout</code>的时间计算是从连接被接受(accept)到request body完全被读取(如果你不读取body，那么时间截止到读完header为止)。它的内部实现是在<code>Accept</code>立即调用<code>SetReadDeadline</code>方法(<a href="https://github.com/golang/go/blob/3ba31558d1bca8ae6d2f03209b4cae55381175b3/src/net/http/server.go#L750" target="_blank" rel="external">代码行</a>)。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">  ……</div><div class="line">  <span class="keyword">if</span> d := c.server.ReadTimeout; d !=<span class="number"> 0</span> {</div><div class="line">	c.rwc.SetReadDeadline(time.Now().Add(d))</div><div class="line">}</div><div class="line"><span class="keyword">if</span> d := c.server.WriteTimeout; d !=<span class="number"> 0</span> {</div><div class="line">	c.rwc.SetWriteDeadline(time.Now().Add(d))</div><div class="line">}</div><div class="line">  ……</div></pre></td></tr></table></figure>

<p><code>WriteTimeout</code>的时间计算正常是从request header的读取结束开始，到 response write结束为止 (也就是 ServeHTTP 方法的声明周期), 它是通过在<code>readRequest</code>方法结束的时候调用<code>SetWriteDeadline</code>实现的(<a href="https://github.com/golang/go/blob/3ba31558d1bca8ae6d2f03209b4cae55381175b3/src/net/http/server.go#L753-L755" target="_blank" rel="external">代码行</a>)。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (c *conn) readRequest(ctx context.Context) (w *response, err error) {</div><div class="line">	<span class="keyword">if</span> c.hijacked() {</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span>, ErrHijacked</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">if</span> d := c.server.ReadTimeout; d !=<span class="number"> 0</span> {</div><div class="line">		c.rwc.SetReadDeadline(time.Now().Add(d))</div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> d := c.server.WriteTimeout; d !=<span class="number"> 0</span> {</div><div class="line">		<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">			c.rwc.SetWriteDeadline(time.Now().Add(d))</div><div class="line">		}()</div><div class="line">	}</div><div class="line"></div><div class="line">  ……</div><div class="line">}</div></pre></td></tr></table></figure>

<p>但是，当连接是HTTPS的时候，<code>SetWriteDeadline</code>会在<code>Accept</code>之后立即调用(<a href="https://github.com/golang/go/blob/3ba31558d1bca8ae6d2f03209b4cae55381175b3/src/net/http/server.go#L1477-L1483" target="_blank" rel="external">代码</a>)，所以它的时间计算也包括 TLS握手时的写的时间。 讨厌的是， 这就意味着(也只有这种情况) <code>WriteTimeout</code>设置的时间也包含读取Headerd到读取body第一个字节这段时间。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> tlsConn, ok := c.rwc.(*tls.Conn); ok {</div><div class="line">		<span class="keyword">if</span> d := c.server.ReadTimeout; d !=<span class="number"> 0</span> {</div><div class="line">			c.rwc.SetReadDeadline(time.Now().Add(d))</div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> d := c.server.WriteTimeout; d !=<span class="number"> 0</span> {</div><div class="line">			c.rwc.SetWriteDeadline(time.Now().Add(d))</div><div class="line">		}</div><div class="line">    ……</div></pre></td></tr></table></figure>

<p>当你处理不可信的客户端和网络的时候，你应该同时设置读写超时，这样客户端就不会因为读慢或者写慢长久的持有这个连接了。</p>
<p>最后，还有一个<code>http.TimeoutHandler</code>方法。 它并不是Server参数，而是一个Handler包装函数，可以限制 <code>ServeHTTP</code>调用。它缓存response, 如果deadline超过了则发送 <em>504 Gateway Timeout</em> 错误。 注意这个功能<a href="https://github.com/golang/go/issues/15327" target="_blank" rel="external">在 1.6 中有问题，在1.6.2中改正了</a>。</p>
<h4 id="http-ListenAndServe_的错误">http.ListenAndServe 的错误</h4>
<p>顺便提一句，<code>net/http</code>包下的封装的绕过<code>http.Server</code>的函数<code>http.ListenAndServe</code>, <code>http.ListenAndServeTLS</code> 和 <code>http.Serve</code>并不适合实现互联网的服务器。这些函数让超时设置默认不启用，并且你没有办法设置启用超时处理。所以如果你使用它们，你会很快发现连接泄漏，太多的文件句柄。我犯过这种错误至少五六次。</p>
<p>取而代之，你应该创建一个<code>http.Server</code>示例，设置<code>ReadTimeout</code>和<code>WriteTimeout</code>,像上面的例子中一样使用相应的方法。</p>
<h4 id="关于流">关于流</h4>
<p>令人心塞的是， 没有办法从<code>ServeHTTP</code>中访问底层的<code>net.Conn</code>，所以提供流服务强制不去设置<code>WriteTimeout</code>（这也可能是为什么这些值的默认值总为0）。如果无法访问<code>net.Conn</code>就不能在每次<code>Write</code>的时候调用<code>SetWriteDeadline</code>来实现一个正确的idle timeout。</p>
<p>而且，也没有办法取消一个阻塞的<code>ResponseWriter.Write</code>，因为<code>ResponseWriter.Close</code>没有文档指出它可以取消一个阻塞并发写。也没有办法使用Timer创建以俄国手工的timeout 杯具就是流服务器不能对于慢读的客户端进行防护。我提交的了一个［bug](<a href="https://github.com/golang/go/issues/16100)，欢迎大家反馈。" target="_blank" rel="external">https://github.com/golang/go/issues/16100)，欢迎大家反馈。</a></p>
<blockquote>
<p><em>编者按</em>: 作者此处的说法是有问题的，可以通过Hijack获取net.Conn,既然可以可以获取net.Conn,我们就可以调用它的SetWriteDeadline方法。代码例子如下：</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"net/http"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	http.HandleFunc(<span class="string">"/hijack"</span>, <span class="keyword">func</span>(w http.ResponseWriter, r *http.Request) {</div><div class="line">		hj, ok := w.(http.Hijacker)</div><div class="line">		<span class="keyword">if</span> !ok {</div><div class="line">			http.Error(w, <span class="string">"webserver doesn't support hijacking"</span>, http.StatusInternalServerError)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		}</div><div class="line">		conn, bufrw, err := hj.Hijack()</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			http.Error(w, err.Error(), http.StatusInternalServerError)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		}</div><div class="line">		<span class="comment">// Don't forget to close the connection:</span></div><div class="line">		<span class="keyword">defer</span> conn.Close()</div><div class="line"></div><div class="line">		conn.SetWriteDeadline(time.Now().Add<span class="number">(10</span> * time.Second))</div><div class="line"></div><div class="line">		bufrw.WriteString(<span class="string">"Now we're speaking raw TCP. Say hi: "</span>)</div><div class="line">		bufrw.Flush()</div><div class="line">		s, err := bufrw.ReadString(<span class="string">'\n'</span>)</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			log.Printf(<span class="string">"error reading string: %v"</span>, err)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		}</div><div class="line">		fmt.Fprintf(bufrw, <span class="string">"You said: %q\nBye.\n"</span>, s)</div><div class="line">		bufrw.Flush()</div><div class="line">	})</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="客户端超时设置">客户端超时设置</h3>
<p><img src="client-timeout.png" alt=""></p>
<p>Client端的超时设置说复杂也复杂，说简单也简单，看你怎么用了，最重要的就是不要有资源泄漏的情况或者程序被卡住。</p>
<p>最简单的方式就是使用<code>http.Client</code>的 <code>Timeout</code>字段。 它的时间计算包括从连接(Dial)到读完response body。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">c := &http.Client{  </div><div class="line">    Timeout:<span class="number"> 15</span> * time.Second,</div><div class="line">}</div><div class="line">resp, err := c.Get(<span class="string">"https://blog.filippo.io/"</span>)</div></pre></td></tr></table></figure>

<p>就像服务器端一样，<code>http.GET</code>使用Client的时候也<a href="https://golang.org/pkg/net/http/#DefaultClient" target="_blank" rel="external">没有超时设置</a>,所以在互联网上使用也很危险。</p>
<p>有一些更细粒度的超时控制：</p>
<ul>
<li><code>net.Dialer.Timeout</code> 限制建立TCP连接的时间</li>
<li><code>http.Transport.TLSHandshakeTimeout</code> 限制 TLS握手的时间</li>
<li><code>http.Transport.ResponseHeaderTimeout</code> 限制读取response header的时间</li>
<li><code>http.Transport.ExpectContinueTimeout</code> 限制client在发送包含 <code>Expect: 100-continue</code>的header到收到继续发送body的response之间的时间等待。注意在1.6中设置这个值会<a href="https://github.com/golang/go/issues/14391" target="_blank" rel="external">禁用HTTP/2</a>(<code>DefaultTransport</code>自1.6.2起是个特例)</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">c := &http.Client{  </div><div class="line">    Transport: &Transport{</div><div class="line">        Dial: (&net.Dialer{</div><div class="line">                Timeout:  <span class="number"> 30</span> * time.Second,</div><div class="line">                KeepAlive:<span class="number"> 30</span> * time.Second,</div><div class="line">        }).Dial,</div><div class="line">        TLSHandshakeTimeout:  <span class="number"> 10</span> * time.Second,</div><div class="line">        ResponseHeaderTimeout:<span class="number"> 10</span> * time.Second,</div><div class="line">        ExpectContinueTimeout:<span class="number"> 1</span> * time.Second,</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如我所讲，没有办法限制发送request的时间。读取response body (原文是读取request body，按照理解应该是读取response可以手工控制)的时间花费可以手工的通过一个<code>time.Timer</code>来实现, 读取发生在调用Client.Do之后（详见下一节）。</p>
<p>最后将一点，在Go 1.7中，增加了一个<code>http.Transport.IdleConnTimeout</code>， 它不控制client request的阻塞阶段，但是可以控制连接池中一个连接可以idle多长时间。</p>
<p>注意一个Client缺省的可以执行 <em>redirect</em>。<code>http.Client.Timeout</code>包含所有的<code>redirect</code>，而细粒度的超时控制参数只针对单次请求有效， 因为<code>http.Transport</code>是一个底层的类型，没有<code>redirect</code>的概念。</p>
<h3 id="Cancel_和_Context">Cancel 和 Context</h3>
<p><code>net/http</code>提供了两种方式取消一个client的请求: <code>Request.Cancel</code>以及Go 1.7新加的<code>Context</code>。</p>
<p><code>Request.Cancel</code>是一个可选的channel, 当设置这个值并且close它的时候，request就会终止，就好像超时了一样(实际它们的实现是一样的，在写本文的时候我还发现一个1.7 的 一个<a href="https://github.com/golang/go/issues/16094" target="_blank" rel="external">bug</a>, 所有的cancel操作返回的错误还是timeout error )。</p>
<p>我们可以使用<code>Request.Cancel</code>和<code>time.Timer</code>来构建一个细粒度的超时控制，允许读取流数据的时候推迟deadline:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (  </div><div class="line">    <span class="string">"io"</span></div><div class="line">    <span class="string">"io/ioutil"</span></div><div class="line">    <span class="string">"log"</span></div><div class="line">    <span class="string">"net/http"</span></div><div class="line">    <span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {  </div><div class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{})</div><div class="line">    timer := time.AfterFunc<span class="number">(5</span>*time.Second, <span class="keyword">func</span>() {</div><div class="line">        <span class="built_in">close</span>(c)</div><div class="line">    })</div><div class="line"></div><div class="line">        <span class="comment">// Serve 256 bytes every second.</span></div><div class="line">    req, err := http.NewRequest(<span class="string">"GET"</span>, <span class="string">"http://httpbin.org/range/2048?duration=8&chunk_size=256"</span>, <span class="constant">nil</span>)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        log.Fatal(err)</div><div class="line">    }</div><div class="line">    req.Cancel = c</div><div class="line"></div><div class="line">    log.Println(<span class="string">"Sending request..."</span>)</div><div class="line">    resp, err := http.DefaultClient.Do(req)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        log.Fatal(err)</div><div class="line">    }</div><div class="line">    <span class="keyword">defer</span> resp.Body.Close()</div><div class="line"></div><div class="line">    log.Println(<span class="string">"Reading body..."</span>)</div><div class="line">    <span class="keyword">for</span> {</div><div class="line">        timer.Reset<span class="number">(2</span> * time.Second)</div><div class="line">                <span class="comment">// Try instead: timer.Reset(50 * time.Millisecond)</span></div><div class="line">        _, err = io.CopyN(ioutil.Discard, resp.Body,<span class="number"> 256</span>)</div><div class="line">        <span class="keyword">if</span> err == io.EOF {</div><div class="line">            <span class="keyword">break</span></div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">            log.Fatal(err)</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的例子中我们为Do方法执行阶段设置5秒的超时，但是我们至少花费8秒执行8次才能读完所欲的body，每一次设置2秒的超时。我们可以为流 API这样处理避免程序死在那里。 如果超过两秒我们没有从服务器读取到数据， io.CopyN会返回<code>net/http: request canceled</code>错误。</p>
<p>在1.7中， context包升级了，进入到标准库中。Context有很多<a href="https://blog.golang.org/context" target="_blank" rel="external">值得学习的功能</a>，但是对于本文介绍的内容来讲，你只需直到它可以用来替换和扔掉<code>Request.Cancel</code>。</p>
<p>用Context取消请求很简单，我们只需得到一个新的Context和它的cancel()函数，这是通过context.WithCancel方法得到的，然后创建一个request并使用<code>Request.WithContext</code>绑定它。当我们想取消这个请求是，我们调用<code>cancel()</code>取消这个Context:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ctx, cancel := context.WithCancel(context.TODO())  </div><div class="line">timer := time.AfterFunc<span class="number">(5</span>*time.Second, <span class="keyword">func</span>() {  </div><div class="line">    cancel()</div><div class="line">})</div><div class="line"></div><div class="line">req, err := http.NewRequest(<span class="string">"GET"</span>, <span class="string">"http://httpbin.org/range/2048?duration=8&chunk_size=256"</span>, <span class="constant">nil</span>)  </div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {  </div><div class="line">    log.Fatal(err)</div><div class="line">}</div><div class="line">req = req.WithContext(ctx)</div></pre></td></tr></table></figure>

<p>Context好处还在于如果parent context被取消的时候(在<code>context.WithCancel</code>调用的时候传递进来的)，子context也会取消， 命令会进行传递。</p>
<p>好了，这就是本文要讲的全部，希望我没有超过你的阅读deadline。</p>
<p><a href="https://www.cloudflare.com/join-our-team/" target="_blank" rel="external">作者的公司cloudflare在英国、美国和新加坡招人</a>。云初创公司，挺知名。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>英文原始出处: <a href="https://blog.cloudflare.com/the-complete-guide-to-golang-net-http-timeouts/" target="_blank" rel="external">The complete guide to Go net/http timeouts</a>, 作者: <a href="https://blog.cloudflare.com/author/filippo/" target="_blank" rel="external">Filippo Valsorda</a></p>
<p>当用Go写HTTP的服务器和客户端的时候，超时处理总是最易犯错和最微妙的地方之一。错误可能来自很多地方，一个错误可能等待很长时间没有结果，直到网络故障或者进程挂起。</p>
<p>HTTP是一个复杂的、多阶段(multi-stage)协议，所以没有一个放之四海而皆准的超时解决方案，比如一个流服务、一个JSON API和一个Comet服务对超时的需求都不相同， 往往默认值不是你想要的。</p>
<p>本文我将拆解需要超时设置的各个阶段，看看用什么不同的方式去处理它， 包括服务器端和客户端。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入Go语言 - 10]]></title>
    <link href="http://colobu.com/2016/06/30/dive-into-go-10/"/>
    <id>http://colobu.com/2016/06/30/dive-into-go-10/</id>
    <published>2016-06-30T02:57:02.000Z</published>
    <updated>2016-07-06T05:33:31.000Z</updated>
    <content type="html"><![CDATA[<p>本章介绍Go如何调用C代码，以及如何调用动态链接库。</p>
<p>如果你正准备使用Go开发你的程序，或者你正将一个C构建的项目转换成Go项目，请尽量使用Go构建你的项目，而不是偷巧的导入C代码，尽量保持Go项目的纯粹，原因可以查看<a href="http://www.oschina.net/translate/cgo-is-not-go" target="_blank" rel="external">cgo 和 Go 语言是两码事</a>,文末的参考文档中也有这篇文章的原始英文。</p>
<p>但是，有些情况下，我们不得不使用C代码构建，那么我们就可以使用cgo技术。</p>
<a id="more"></a>
<h3 id="Go代码调用C函数">Go代码调用C函数</h3>
<p>cgo可以让Go代码调用C代码。</p>
<p>C代码被封装进“package C”中，你可以访问C实现的类型<code>C.size_t</code>、 变量<code>C.stdout</code> 和 方法<code>C.putchar</code>,即使它们的首字母是小写的。</p>
<p>在代码<code>import &quot;C&quot;</code>之前有注释(紧接着这个import),那么这个注释称之为<code>preamble</code>(序言、开场白)。它可以包含编译C package的头文件:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">*/</div><div class="line"><span class="keyword">import</span> <span class="string">"C"</span></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	C.srandom(C.<span class="typename">uint</span>(time.Now().UTC().UnixNano()))</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 10</span>; i++ {</div><div class="line">		fmt.Printf(<span class="string">"%d "</span>, <span class="typename">int</span>(C.random()))</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>preamble还可以包含C代码，你可以在C代码中定义变量和函数，它们可以在Go代码中通过包C来引用。C代码中的静态变量不能在G中使用，但是静态函数可以。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cgoexample</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line"></div><div class="line">void myprint(char* s) {</div><div class="line">    printf("%s\n", s);</div><div class="line">}</div><div class="line">*/</div><div class="line"><span class="keyword">import</span> <span class="string">"C"</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"unsafe"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> Example() {</div><div class="line">    cs := C.CString(<span class="string">"Hello from stdio\n"</span>)</div><div class="line">    C.myprint(cs)</div><div class="line">    C.free(unsafe.Pointer(cs))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>你可以在Go官方代码库中看到这样的例子， 比如<a href="https://github.com/golang/go/tree/master/misc/cgo/stdio" target="_blank" rel="external">misc/cgo/stdio</a>。</p>
<p>工具<a href="https://golang.org/cmd/cgo/" target="_blank" rel="external">cmd/tool</a>将包含导入包C的Go文件转换成几个Go文件和C文件。如果你运行<code>go tool cgo main1.go</code>转换上面的例子，你会发现在本地文件夹下生成了一个_obj的文件夹：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">smallnestMBP:ch9 smallnest$ ls _obj/</div><div class="line">_cgo_.o         _cgo_export.h   _cgo_gotypes.go main1.cgo1.go</div><div class="line">_cgo_export.<span class="built_in">c</span>   _cgo_flags      _cgo_main.<span class="built_in">c</span>     main1.cgo2.<span class="built_in">c</span></div></pre></td></tr></table></figure>

<p>它会包含一个编译器在编译这些C文件后生成的目标文件<em>cgo</em>.o。</p>
<p>在实际开发中，我们不会直接调用cgo工具，因为<code>go build</code>会自动完成这一切，让我们编译这个程序<code>go build main1.go</code>或者直接运行<code>go run main1.go</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">smallnestMBP:ch9 smallnest$ <span class="keyword">go</span> run main1.<span class="keyword">go</span><span class="number"></span></div><div class="line">991076780<span class="number"> 1985136578</span><span class="number"> 1492569085</span><span class="number"> 555504684</span><span class="number"> 104261718</span><span class="number"> 1646436258</span><span class="number"> 1683793209</span><span class="number"> 1521143308</span><span class="number"> 547922631</span><span class="number"> 1875795366</span></div></pre></td></tr></table></figure>

<p>这是引用C的标准库,我们不需要额外的编译参数设置，要引入特定的库，我们还需要设置一些额外的参数。</p>
<p>我们可以使用<code>#cgo</code>指令符(directive)为C/C++编译器提供 <strong>CFLAGS</strong>、 <strong>CPPFLAGS</strong>、<strong>CXXFLAGS</strong> 和 <strong>LDFLAGS</strong> 设置,同时也可以提供一些编译的<a href="https://golang.org/pkg/go/build/#hdr-Build_Constraints" target="_blank" rel="external">约束</a>，比如为特定的平台的参数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// #cgo CFLAGS: -DPNG_DEBUG=1</span></div><div class="line"><span class="comment">// #cgo amd64 386 CFLAGS: -DX86=1</span></div><div class="line"><span class="comment">// #cgo LDFLAGS: -lpng</span></div><div class="line"><span class="comment">// #include &lt;png.h&gt;</span></div><div class="line"><span class="keyword">import</span> <span class="string">"C"</span></div></pre></td></tr></table></figure>

<p>开发C/C++程序的程序员和经常使用make工具链的开发者应该对这些参数很熟悉了， flags给编译器提供开关，比如指定头文件的位置等， ldflags提供链接选项，比如提供库的位置。</p>
<p><code>CFLAGS</code> 用来给 <strong>C</strong> 编译器提供开关。<br><code>CXXFLAGS</code> 用来给 <strong>C++</strong> 编译器提供开关。<br><code>CPPFLAGS</code> 用来给C预处理提供开关，对 <strong>C</strong> / <strong>C++</strong> 都有效。<br><code>LDFLAGS</code> 用来指定链接选项,比如链接库的位置，以及使用哪些链接库。</p>
<p>我们在编译C文件的时候，一般会经过四个步骤： 预处理、编译、汇编和链接，你可以看到这些开发参数的用处:</p>
<figure class="highlight make"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 预处理</span></div><div class="line">$(CC) $(CPPFLAGS) $(CFLAGS) -E main.c  -o main.i</div><div class="line"></div><div class="line"><span class="comment">// 编译</span></div><div class="line">$(CC) $(CPPFLAGS) $(CFLAGS) -S main.i  -o main.s</div><div class="line"></div><div class="line"><span class="comment">// 汇编， "-c"选项表示不执行链接步骤</span></div><div class="line">$(CC) $(CPPFLAGS) $(CFLAGS) -c main.s  -o main.o</div><div class="line"></div><div class="line"><span class="comment">// 也可以将前面的三个步骤合起来(预处理,编译,汇编)</span></div><div class="line">$(CC) $(CPPFLAGS) $(CFLAGS) -c main.c -o main.o</div><div class="line"></div><div class="line"><span class="comment">// 然后将目标文件链接为最终的结果</span></div><div class="line">$(CC) $(LDFLAGS) main.o   -o main</div><div class="line"></div><div class="line"><span class="comment">// 也可以一次完成上面的步骤。</span></div><div class="line">$(CC) $(CPPFLAGS) $(CFLAGS) $(LDFLAGS) main.c   -o main</div></pre></td></tr></table></figure>

<p>gcc可用的开关可以查看它的文档: <a href="https://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html#Invoking-GCC" target="_blank" rel="external">Invoking-GCC</a>。</p>
<p><code>CPPFLAGS</code>、<code>LDFLAGS</code>可以通过 <strong>pkg-config</strong> 工具获得：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// #cgo pkg-config: png cairo</span></div><div class="line"><span class="comment">// #include &lt;png.h&gt;</span></div><div class="line"><span class="keyword">import</span> <span class="string">"C"</span></div></pre></td></tr></table></figure>

<p>编译的时候，四个环境变量会增加它们的flag到编译参数中，这适合设置通用的，包无关的编译参数。</p>
<p>还有一个变量 ${SRCDIR} 用来指代原文件所在的文件夹的绝对路径，这允许你将预先编译好的静态库放在本地文件夹中，让编译器可以找到这些库以便正确的链接。比如包foo在文件夹/go/src/foo下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// #cgo LDFLAGS: -L${SRCDIR}/libs -lfoo</span></div></pre></td></tr></table></figure>

<p>上面的指令等价于:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// #cgo LDFLAGS: -L/go/src/foo/libs -lfoo</span></div></pre></td></tr></table></figure>

<p>可以看一个使用libsqlite3库的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">#cgo pkg-config: sqlite3</div><div class="line"></div><div class="line">#include &lt;sqlite3.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">*/</div><div class="line"><span class="keyword">import</span> <span class="string">"C"</span></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Conn <span class="keyword">struct</span> {</div><div class="line">	db *C.sqlite3</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> c Conn</div><div class="line">	fmt.Println(c.db)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>实际上，你不使用<code>#cgo pkg-config: sqlite3</code>也可以，因为在我们的机器上(Mac OS X)，libsqlite3被安装在标准的路径中，库在/usr/lib中，头文件安装在/usr/include文件下，如果你为PKG_CONFIG_PATH指定了特殊的文件夹，你可以使用这个指令:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">smallnestMBP:ch9 smallnest$ pkg-config --libs --cflags protobuf</div><div class="line">-D_THREAD_SAFE -I<span class="regexp">/usr/</span>local<span class="regexp">/Cellar/</span>protobuf<span class="regexp">/2.6.1/i</span>nclude -L<span class="regexp">/usr/</span>local<span class="regexp">/Cellar/</span>protobuf<span class="regexp">/2.6.1/</span>lib -lprotobuf -D_THREAD_SAFE</div></pre></td></tr></table></figure>

<p>当Go工具访问一个或者多个Go文件导入包C的时候， 它也会查找其它的非Go的文件并把它们编译到Go包中 以 <code>.c</code>, <code>.s</code>, <code>.S</code>结尾的C文件或者汇编文件使用C编译器编译，以<code>.cc</code>, <code>.cpp</code>, <code>.cxx</code>结尾的文件以C++编译器编译以<code>.h</code>, <code>.hh</code>, <code>.hpp</code>, <code>.hxx</code>文件不会独立编译，但是这些头文件如果有改动，相应的C和C++文件会重新被编译。默认的C和C++编译器可以通过CC 和 CXX 环境变量改变。</p>
<p>所以文件夹下的汇编语言也可以被编译。</p>
<p>交叉编译的时候cgo被禁止，如果想启用，设置CGO_ENABLED＝1。还需要额外的设置，比如C交叉编译器。</p>
<p>下面以一个计算圆周率的前1000位的例子看看我们自己实现的C库如何被我们的 Go代码实现 (假定所有的文件都在同一个文件夹下，这样编译和使用动态库时比较方便)：<br>首先是计算Pi的C代码 <code>pi.c</code>，函数calc用来计算Pi的值，返回结果是一个C的字符串：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> a=<span class="number">10000</span>, b, c=<span class="number">2800</span>, d, e, f[<span class="number">2801</span>], g,i;</div><div class="line"><span class="keyword">char</span> r[<span class="number">1000</span>];</div><div class="line"><span class="keyword">char</span>* pr = r;</div><div class="line"></div><div class="line"><span class="keyword">char</span>* calc() {</div><div class="line">	<span class="keyword">for</span>(;b-c;)</div><div class="line">	f[b++]=a/<span class="number">5</span>;</div><div class="line">	<span class="comment">//for(;d=0,g=c*2;c-=14,printf("%.4d",e+d/a),e=d%a)</span></div><div class="line">	<span class="keyword">for</span>(;d=<span class="number">0</span>,g=c*<span class="number">2</span>;c-=<span class="number">14</span>,<span class="built_in">sprintf</span>(pr,<span class="string">"%.4d"</span>,e+d/a),pr +=<span class="number">4</span>,e=d%a)</div><div class="line">	<span class="keyword">for</span>(b=c;d+=f[b]*a,f[b]=d%--g,d/=g--,--b;d*=b);</div><div class="line">	<span class="keyword">return</span> r;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>编译成动态库:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -shared <span class="operator">-f</span>PIC -olibpi.dylib pi.c</div></pre></td></tr></table></figure>

<p>定义一个头文件<code>pi.h</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span>* calc();</div></pre></td></tr></table></figure>

<p>我们可以写一个C程序 <code>test.c</code> 调用这个动态库，测试一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "pi.h"</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, calc());</div><div class="line">}</div></pre></td></tr></table></figure>

<p>编译执行一下，确保动态库没有问题:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -L. -I. -lpi <span class="keyword">test</span>.c  -o <span class="keyword">test</span></div></pre></td></tr></table></figure>

<p>现在就可以在Go代码中使用这个库了。写一个Go文件 <code>main3.go</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">#cgo CFLAGS: -I${SRCDIR}</div><div class="line">#cgo LDFLAGS: -L${SRCDIR} -lpi</div><div class="line"></div><div class="line">#include "pi.h"</div><div class="line">*/</div><div class="line"><span class="keyword">import</span> <span class="string">"C"</span></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	fmt.Println(<span class="string">"计算PI值:"</span>)</div><div class="line">	v := C.GoString(C.calc())</div><div class="line">	fmt.Println(v)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>编译：<code>go build main3.go</code>,因为动态库和生成的可执行文件<code>main3</code>在同一个目录下，没有问题，执行main3:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">smallnestMBP:</span>ch9 smallnest<span class="variable">$ </span>./main3</div><div class="line">计算<span class="constant">PI</span>值<span class="symbol">:</span></div><div class="line"><span class="number">31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185</span></div></pre></td></tr></table></figure>

<p>上面这个计算Pi的例子我们将C的字符串转换成Go的字符串。 cgo定义了Go和C之间的类型对应关系。</p>
<ul>
<li>如果C的struct的字段类型是Go的关键字,如<code>type</code>, 那么在Go代码中可以在字段前加关键字如<code>x._type</code></li>
<li>C中的整数类型已经在包C中定义，如<code>C.char</code>、<code>C.short</code>、<code>C.ushort</code>、<code>C.int</code>、<code>C.uint</code>、<code>C.longlong</code>、<code>C.float</code>,不一一列举，请看参考文档1</li>
<li>访问C的<code>struct</code>、<code>union</code>、<code>enum</code>类型需要加类型前缀<code>struct_</code>、<code>union_</code>、<code>enum_</code>，如C.struct_stat</li>
<li>访问C中的类型T的size用 C.sizeof_T，如C.sizeof_struct_stat</li>
<li>Go不支持C的union的概念，只是把它作为相同长度的字节数组</li>
<li>Go的Struct不能嵌入C的类型</li>
<li>Go的API不应该再暴露C的类型给外部</li>
<li>调用C的函数可以进行多值赋值，一个值作为返回值，一个作为errno</li>
<li>当前不支持C的函数指针</li>
<li>C中参数是固定长度的数组，可以把数组名传递给函数，但是Go代码调用中必须显示地将指针指向数组的第一个元素,如C.f(&amp;C.x[0])</li>
</ul>
<p>对应的类型转换：</p>
<pre class="highlight">
char -->  C.char -->  byte
signed char -->  C.schar -->  int8
unsigned char -->  C.uchar -->  uint8
short int -->  C.short -->  int16
short unsigned int -->  C.ushort -->  uint16
int -->  C.int -->  int
unsigned int -->  C.uint -->  uint32
long int -->  C.long -->  int32 or int64
long unsigned int -->  C.ulong -->  uint32 or uint64
long long int -->  C.longlong -->  int64
long long unsigned int -->  C.ulonglong -->  uint64
float -->  C.float -->  float32
double -->  C.double -->  float64
wchar_t -->  C.wchar_t  -->  
void * -> unsafe.Pointer
</pre>

<p>项目<a href="https://github.com/giorgisio/cgo" target="_blank" rel="external">giorgisio/cgo</a>提供了一些Go调用C代码各种类型的例子。</p>
<h3 id="调用动态链接库">调用动态链接库</h3>
<p>对于Windows环境，Go提供了直接加载动态链接库的方法。 首先syscall包下实现了<code>LoadDLL</code>、<code>FindProc</code>、<code>Release</code>方法，可以加载动态链接库以及得到相应的函数。</p>
<p>另外包<code>golang.org/x/sys/windows</code>提供了更多的方法，如<code>LoadLibrary</code>、<code>LoadLibraryEx</code>、 <code>DLL</code>、 <code>LazyDLL</code>等方法和类型。</p>
<p>举个栗子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">h, err := windows.LoadLibrary(<span class="string">"kernel32.dll"</span>)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">    abort(<span class="string">"LoadLibrary"</span>, err)</div><div class="line">}</div><div class="line"><span class="keyword">defer</span> windows.FreeLibrary(h)</div><div class="line">proc, err := windows.GetProcAddress(h, <span class="string">"GetVersion"</span>)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">    abort(<span class="string">"GetProcAddress"</span>, err)</div><div class="line">}</div><div class="line">r, _, _ := syscall.Syscall(<span class="typename">uintptr</span>(proc),<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>)</div><div class="line">major := <span class="typename">byte</span>(r)</div><div class="line">minor := <span class="typename">uint8</span>(r &gt;&gt;<span class="number"> 8</span>)</div><div class="line">build := <span class="typename">uint16</span>(r &gt;&gt;<span class="number"> 16</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"windows version "</span>, major, <span class="string">"."</span>, minor, <span class="string">" (Build "</span>, build, <span class="string">")\n"</span>)</div></pre></td></tr></table></figure>

<p>其它平台我还没有发现官方的调用.so或者.dylib的方法， 但是我看到有第三方的作者写了相应的库，提供类似C中的dlopen和dlsym方法：<br><a href="https://github.com/rainycape/dl" target="_blank" rel="external">Runtime dynamic library loader</a></p>
<p>还有<a href="https://bitbucket.org/binet/go-ffi" target="_blank" rel="external">go-ffi</a>,也提供了dlopen和dlsym的功能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// dl-open a library: here, libm on macosx</span></div><div class="line">lib, err := ffi.NewLibrary(<span class="string">"libm.dylib"</span>)</div><div class="line">handle_err(err)</div><div class="line"></div><div class="line"><span class="comment">// get a handle to 'cos', with the correct signature</span></div><div class="line">cos, err := lib.Fct(<span class="string">"cos"</span>, ffi.Double, []Type{ffi.Double})</div><div class="line">handle_err(err)</div><div class="line"></div><div class="line"><span class="comment">// call it</span></div><div class="line">out := cos<span class="number">(0</span>.).Float()</div><div class="line"><span class="built_in">println</span>(<span class="string">"cos(0.)="</span>, out)</div><div class="line"></div><div class="line">err = lib.Close()</div><div class="line">handle_err(err)</div></pre></td></tr></table></figure>

<p>参考</p>
<ul>
<li><a href="https://golang.org/cmd/cgo/" target="_blank" rel="external">https://golang.org/cmd/cgo/</a></li>
<li><a href="https://github.com/golang/go/wiki/cgo" target="_blank" rel="external">https://github.com/golang/go/wiki/cgo</a></li>
<li><a href="http://akrennmair.github.io/golang-cgo-slides/#1" target="_blank" rel="external">http://akrennmair.github.io/golang-cgo-slides/#1</a></li>
<li><a href="http://dave.cheney.net/2016/01/18/cgo-is-not-go" target="_blank" rel="external">http://dave.cheney.net/2016/01/18/cgo-is-not-go</a></li>
<li><a href="http://dominik.honnef.co/posts/2015/06/statically_compiled_go_programs__always__even_with_cgo__using_musl/" target="_blank" rel="external">http://dominik.honnef.co/posts/2015/06/statically_compiled_go_programs__always__even_with_cgo__using_musl/</a></li>
<li><a href="http://blog.giorgis.io/cgo-examples" target="_blank" rel="external">http://blog.giorgis.io/cgo-examples</a></li>
<li><a href="http://blog.madewithdrew.com/post/statically-linking-c-to-go/" target="_blank" rel="external">http://blog.madewithdrew.com/post/statically-linking-c-to-go/</a></li>
<li><a href="https://github.com/hyper-carrot/go_command_tutorial/blob/master/0.13.md" target="_blank" rel="external">https://github.com/hyper-carrot/go_command_tutorial/blob/master/0.13.md</a></li>
<li><a href="https://www.goinggo.net/2013/08/using-c-dynamic-libraries-in-go-programs.html" target="_blank" rel="external">https://www.goinggo.net/2013/08/using-c-dynamic-libraries-in-go-programs.html</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>本章介绍Go如何调用C代码，以及如何调用动态链接库。</p>
<p>如果你正准备使用Go开发你的程序，或者你正将一个C构建的项目转换成Go项目，请尽量使用Go构建你的项目，而不是偷巧的导入C代码，尽量保持Go项目的纯粹，原因可以查看<a href="http://www.oschina.net/translate/cgo-is-not-go" target="_blank" rel="external">cgo 和 Go 语言是两码事</a>,文末的参考文档中也有这篇文章的原始英文。</p>
<p>但是，有些情况下，我们不得不使用C代码构建，那么我们就可以使用cgo技术。</p>
]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入Go语言 - 9]]></title>
    <link href="http://colobu.com/2016/06/29/dive-into-go-9/"/>
    <id>http://colobu.com/2016/06/29/dive-into-go-9/</id>
    <published>2016-06-29T08:03:25.000Z</published>
    <updated>2016-07-06T05:33:13.000Z</updated>
    <content type="html"><![CDATA[<p>本章介绍Go语言的其它部分，算是Go语言规范的深入学习的收尾工作。</p>
<a id="more"></a>
<h3 id="内建函数">内建函数</h3>
<p>前面几章我们已经认识了几个内建的函数，这里我们将所有的内建函数罗列一下。</p>
<p>如果你查看它们的定义的话，你可以访问<a href="https://golang.org/src/builtin/builtin.go" target="_blank" rel="external">builtin/builtin.go</a>,但这些内建的函数只有声明，没有方法体，它们不是标准的Go类型，你不能把它们作为函数值进行参数传递，只能出现在调用表达式中。事实上这些内建类型并不真的在builtin包中，只是为了生成文档的需要。</p>
<p>你可以在任意的包中调用这些内建函数，不必引入特定的包如&quot;builtin&quot;。</p>
<p>1、<strong>close</strong>: 关闭channel<br>2、<strong>len(s)</strong>:得到字符串、数组、数值指针、slice、map、chan的长度<br>3、<strong>cap(s)</strong>:得到数组、数组指针的长度，得到slice、channel的容量<br>4、<strong>new(T)</strong>: 生成类型T的零值指针,注意它返回的是指针 *T<br>5、<strong>make</strong>: 生成slice、map、channel对象</p>
<pre class="highlight">
调用              类型 T     结果

make(T, n)       slice      slice of type T with length n and capacity n
make(T, n, m)    slice      slice of type T with length n and capacity m

make(T)          map        map of type T
make(T, n)       map        map of type T,初始可以容纳 n 元素的空间

make(T)          channel    不带缓存的channel of type T,比如我们在声明信号channel的时候
make(T, n)       channel    带缓存的 channel of type T, 缓存大小为 n
</pre>

<p>6、<strong>append(s S, x ...T) S</strong>: 增加0到n个元素到slice中，返回新的slice<br>7、<strong>copy(dst, src []T) int</strong>: 复制源src slice的元素到目标dst slice中,返回复制的元素的数量n, n是src和dst长度的最小值。字符串也可以作为src,但是T的类型必须是byte<br>8、<strong>delete(m,k)</strong>: 删除map中的一个映射， m为nil或者m[k]不存在也不会panic,而是一个空操作<br>9、<strong>complex</strong>、<strong>real</strong>、<strong>imag</strong>: 复数操作<br>10、<strong>panic</strong>、<strong>recover</strong>: 报告panic和处理panic,后面讲<br>11、<strong>print</strong>、<strong>println</strong>: 尽量不用这两个函数，因为保证将来它们还会留在Go语言中，使用fmt.Print、fmt.Println</p>
<h3 id="包">包</h3>
<p>Go的代码文件中都会有包(package)的定义，在import声明的前面。</p>
<p>同一个文件夹下的所有的文件都要使用同一个包名(当然，你如果单独编译每一个文件的话，可以不遵守，但是要编译整个项目，必须遵守)。</p>
<p>但是测试文件可以叫另外的包名，比如正常代码的包名为&quot;package abc&quot;,测试代码和示例代码的包名为&quot;package abc_test&quot;. Go标准库中混用了这两种风格。</p>
<p><code>main</code>包是一个特殊的包，必须声明一个main函数，main函数无参数，无返回值，它用来创建可执行程序。</p>
<p>包名不一定和文件夹的名字保持一致，经常我们的项目的名称很长，不太适合做包名，所以包名可以用一个简短的名称，但是如果可能，尽量用一样的名字，这样在下载库的时候就能直到包的名字了。</p>
<h3 id="import">import</h3>
<p>import用来引入所需要的类型，允许你访问另外的包中的导出类型。</p>
<p>以下四种形式都是可以接受的mport:</p>
<pre class="highlight">
Import declaration          Local name of Sin

import   "lib/math"         math.Sin
import m "lib/math"         m.Sin
import . "lib/math"         Sin
import _ "lib/math"
</pre>

<p>为了避免同名的包名冲突，你可以为导入的包名起一个名字，比如上例中的&quot;m&quot;。<br>你也可以使用<code>.</code>,这样无需包名标识符，可以直接使用这个包下的导出类型。<br>最后一个情况是使用空标识符，主要是想利用包的初始化，而不是使用它的导出类型。</p>
<p>import不能导入包自己，不管是直接的还是间接的(循环引用)。你也不能直接导入一个包而不使用它的导出类型，所幸一些工具可以自动帮我们修正import的错误，或者自动帮我们导入，比如<a href="https://github.com/bradfitz/goimports" target="_blank" rel="external">goimports</a>。</p>
<p>import可以导入相对路径，如&quot;import \&quot;../foo/bar\&quot;&quot;,但是强烈你不要这么做，这不是常用的导入风格。</p>
<p>import可以用小括号括起来导入多个包。</p>
<h3 id="包的初始化">包的初始化</h3>
<p>包变量的初始化顺序和它们声明的顺序一致，但是也得考虑它们的依赖。<br>循环依赖初始化也不可以：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> abc</div><div class="line"></div><div class="line"><span class="keyword">var</span> i <span class="typename">int</span> = j</div><div class="line"><span class="keyword">var</span> j <span class="typename">int</span> = k</div><div class="line"><span class="keyword">var</span> k <span class="typename">int</span> = i</div></pre></td></tr></table></figure>

<p>包变量的初始化之后可以调用一个init函数实现其它的初始化过程，你可以显示地定义这个函数，它可以出现在同一个包下的多个文件中，执行的顺序由编译器决定。<br>如果包导入了其它包，则导入的包会先初始化。如果多个包都导入同一个包，则导入的包只被初始化一次。</p>
<h3 id="error、panic和recover">error、panic和recover</h3>
<p>Go预定义了<code>error</code>类型，虽然它的首字母不是大写的，但是确可以在任何包下使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> {</div><div class="line">	Error() <span class="typename">string</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>而errors包定义了生成简单Error的方法<code>errors.New(text String) error</code>。如果你想自定义Error类型，你可以实现error接口。</p>
<p>运行时Error，比如数组索引越界会触发一个运行时的panic，它等价调用panic函数，panic的值是一个runtime.Error:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> runtime</div><div class="line"></div><div class="line"><span class="keyword">type</span> Error <span class="keyword">interface</span> {</div><div class="line">	error</div><div class="line">	<span class="comment">// and perhaps other methods</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>而panic的处理是在一个defer函数中执行的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">		fmt.Println(<span class="string">"foo"</span>)</div><div class="line">	}()</div><div class="line">	<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">if</span> x := <span class="built_in">recover</span>(); x != <span class="constant">nil</span> {</div><div class="line">			fmt.Println(x)</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">		fmt.Println(<span class="string">"bar"</span>)</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="built_in">panic</span>(<span class="string">"trigger panic"</span>)</div><div class="line">  fmt.Println(<span class="string">"end"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>注意defer的执行顺序，前面已经讲过，和它们声明的顺序相反，所以输出结果为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">bar</span></div><div class="line">trigger panic</div><div class="line">foo</div></pre></td></tr></table></figure>

<p>最后一句没有机会继续执行，因为recover执行完后函数就终止了。<br>这带来一个问题，如果函数有返回值，recover后函数的返回值是什么？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	i := z()</div><div class="line">	fmt.Println(i)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> z() <span class="typename">int</span> {</div><div class="line">	<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">		fmt.Println(<span class="string">"foo"</span>)</div><div class="line">	}()</div><div class="line">	<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">if</span> x := <span class="built_in">recover</span>(); x != <span class="constant">nil</span> {</div><div class="line">			fmt.Println(x)</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">		fmt.Println(<span class="string">"bar"</span>)</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="built_in">panic</span>(<span class="string">"trigger panic"</span>)</div><div class="line">	fmt.Println(<span class="string">"end"</span>)</div><div class="line">	<span class="keyword">return</span><span class="number"> 100</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>输出结果是:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">bar</div><div class="line">trigger <span class="built_in">panic</span></div><div class="line">foo<span class="number"></span></div><div class="line">0</div></pre></td></tr></table></figure>

<p>可以函数的返回是返回类型的零值。</p>
<p>当然说零值也不完全正确，如果函数有命名的返回参数，并且命名的返回参数在panic之前赋值了的话，返回的结果还是最后的赋值结果,下面的代码中函数的返回结果为50:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	i := z()</div><div class="line">	fmt.Println(i)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> z() (r <span class="typename">int</span>) {</div><div class="line">	<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">		fmt.Println(<span class="string">"foo"</span>)</div><div class="line">	}()</div><div class="line">	<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">if</span> x := <span class="built_in">recover</span>(); x != <span class="constant">nil</span> {</div><div class="line">			fmt.Println(x)</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">		fmt.Println(<span class="string">"bar"</span>)</div><div class="line">	}()</div><div class="line"></div><div class="line">	r =<span class="number"> 50</span></div><div class="line">	<span class="built_in">panic</span>(<span class="string">"trigger panic"</span>)</div><div class="line">	fmt.Println(<span class="string">"end"</span>)</div><div class="line">	<span class="keyword">return</span><span class="number"> 100</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>panic如果没有处理，会传递给它的调用者，这就是panic的bubble。当然如果可以预见panic,最好的处理方式就是在本函数内进行处理，因为你不能控制外部调用者的行为，而且外部调用者不一定知道会有panic发生：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">if</span> x := <span class="built_in">recover</span>(); x != <span class="constant">nil</span> {</div><div class="line">			fmt.Println(<span class="string">"recover from main:"</span>, x)</div><div class="line">		}</div><div class="line">	}()</div><div class="line"></div><div class="line">	f1()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> f1() {</div><div class="line">	fmt.Println(<span class="string">"start f1"</span>)</div><div class="line">	f2()</div><div class="line">	fmt.Println(<span class="string">"end f1"</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> f2() {</div><div class="line">	fmt.Println(<span class="string">"start f2"</span>)</div><div class="line">	f3()</div><div class="line">	fmt.Println(<span class="string">"end f2"</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> f3() {</div><div class="line">	fmt.Println(<span class="string">"start f3"</span>)</div><div class="line">	<span class="built_in">panic</span>(<span class="string">"triggered from f3"</span>)</div><div class="line">	fmt.Println(<span class="string">"end f3"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的代码输出:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="operator"><span class="keyword">start</span> f1</span></div><div class="line"><span class="keyword">start</span> f2</div><div class="line"><span class="keyword">start</span> f3</div><div class="line">recover <span class="keyword">from</span> main: triggered <span class="keyword">from</span> f3</div></pre></td></tr></table></figure>

<p>如果连main都没有 recover，则程序异常退出。</p>
<p>还有一个不太引人注意的地方就是如果在recover中产生panic会怎么样？还是看例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">if</span> x := <span class="built_in">recover</span>(); x != <span class="constant">nil</span> {</div><div class="line">			fmt.Println(<span class="string">"recover from main:"</span>, x)</div><div class="line">		}</div><div class="line">	}()</div><div class="line"></div><div class="line">	f1()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> f1() {</div><div class="line">	<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">if</span> x := <span class="built_in">recover</span>(); x != <span class="constant">nil</span> {</div><div class="line">			fmt.Println(<span class="string">"recover from f1:"</span>, x)</div><div class="line">			<span class="built_in">panic</span>(<span class="string">"triggered from f1"</span>)</div><div class="line">		}</div><div class="line">	}()</div><div class="line"></div><div class="line">	f2()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> f2() {</div><div class="line">	<span class="built_in">panic</span>(<span class="string">"triggered from f2"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>函数f2产生的panic会被函数f1处理， f1在recover的过程中产生一个新的panic,这个panic会把它的调用者main捕获。<br>所以recover产生的panic会往上传递。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本章介绍Go语言的其它部分，算是Go语言规范的深入学习的收尾工作。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入Go语言 - 8]]></title>
    <link href="http://colobu.com/2016/06/27/dive-into-go-8/"/>
    <id>http://colobu.com/2016/06/27/dive-into-go-8/</id>
    <published>2016-06-27T08:21:43.000Z</published>
    <updated>2016-07-25T01:15:30.000Z</updated>
    <content type="html"><![CDATA[<p>本章介绍 go语句、goroutine调度。</p>
<a id="more"></a>
<h3 id="go_语句">go 语句</h3>
<p>go语句用来产生一个新的goroutine，并执行一个函数，它的使用非常简单，就是在函数调用或者方法调用的前面加上go关键字即可。</p>
<p>函数可以是已有函数、匿名函数、方法等,注意匿名方法(方法字面量)不要忘记调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> foo(i <span class="typename">int</span>) <span class="typename">int</span> {</div><div class="line">	<span class="keyword">return</span> i * i</div><div class="line">}</div><div class="line"></div><div class="line">……</div><div class="line"></div><div class="line"><span class="keyword">go</span> foo<span class="number">(10</span>)</div><div class="line"><span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line"></div><div class="line">}()</div><div class="line"></div><div class="line"><span class="keyword">go</span> os.Open(<span class="string">"./test.txt"</span>)</div><div class="line"></div><div class="line">buf := bytes.NewBufferString(<span class="string">"hello world"</span>)</div><div class="line"><span class="keyword">go</span> buf.ReadString<span class="number">(0</span>)</div></pre></td></tr></table></figure>

<h3 id="深入go语句">深入go语句</h3>
<p>看下面一段代码,你觉得会输出什么:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 3</span>; i++ {</div><div class="line">		<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">			fmt.Println(i)</div><div class="line">		}()</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>有的人说输出&quot;0 1 2&quot;,有的人说输出&quot;3 3 3&quot;。</p>
<p>但实际上什么都没有输出。这是因为main goroutine马上就执行完了，它不会等待生成的goroutine的执行。</p>
<blockquote>
<p>Program execution begins by initializing the main package and then invoking the function main. When that function invocation returns, the program exits. It does not wait for other (non-main) goroutines to complete.</p>
</blockquote>
<p>你可以增加下面一行，等待所有的<code>goroutine</code>执行完：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> {}</div></pre></td></tr></table></figure>

<p>因为select语句会被阻塞，所以前面生成的所有的goroutine会被执行。</p>
<p>你可能会发现程序最后会出下面一个错误信息：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">fatal</span> <span class="built_in">error</span>: all goroutines are asleep - deadlock!</div></pre></td></tr></table></figure>

<p>它的意思是所有的goroutine都已经执行完了，你的select还在那里阻塞着，不会有case等你执行的，所以有死锁的可能。Go强制杀死了这个等待，并抛出了一个错误。因此你可以忽略这个错误，它对我们前面的程序执行没有影响。</p>
<p>如果你不想看到这个错误，你可以使用<code>sync.WaitGroup</code>，或者像其它语言中的处理方法一样，从命令行读取一个值造成main goroutine阻塞，抑或加一行time.Sleep让main goroutine休眠较长的一个时间也可以：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">os.Stdin.Read(<span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number"> 1</span>))</div></pre></td></tr></table></figure>

<p>那么，加上上面一行，会输出什么?</p>
<p>答案是 &quot;3 3 3&quot;,为什么呢？</p>
<p>这是因为对于closure的情况(闭包closure的概念在很多语言中都有使用。在Go中，可以简单的认为匿名函数保持对外部变量的引用)，for循环的每次迭代都会使用相同的变量i,这样每个goroutine都持有对相同的变量的引用，因为main gororutine 很快就执行了， 三个goroutine还没来得及执行，等它们执行的时候，i已经等于 2了，所以它们都打印出2来。</p>
<p>我们可以稍微修改一下，让main goroutine不要执行那么快，每次迭代暂停1秒:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 3</span>; i++ {</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		fmt.Println(i)</div><div class="line">	}()</div><div class="line"></div><div class="line">	time.Sleep<span class="number">(1</span> * time.Second)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这段代码输出的结果为&quot;0 1 2&quot;。因为在main goroutine 暂停的时候， 生成的go routine有机会执行。</p>
<p>但是我们无法精确控制goroutine的执行，如果期望输出结果总是使用当前的迭代的值，可以改造成下面的样子:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 3</span>; i++ {</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>(v <span class="typename">int</span>) {</div><div class="line">		fmt.Println(v)</div><div class="line">	}(i)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>输出结果为&quot;2 0 1&quot; (goroutine的执行顺序有可能不同,但是如果你看到最后一节的分析，这个执行顺序也能讲得通，最后一个输出2的goroutine作为runnext优先级最高，输出1的goroutine本来在runnext的位置，不幸被挤掉了，放在了本地队列的队尾)。</p>
<p>如果你不想对匿名函数进行改造的话，也可以像下面的这样，生成一个局部变量:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 3</span>; i++ {</div><div class="line">	i := i</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		fmt.Println(i)</div><div class="line">	}()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>输出 &quot;2 0 1&quot;, 注意我们使用一个同名的局部变量shadow了迭代的变量i。</p>
<p>参考:</p>
<ul>
<li><a href="https://golang.org/doc/faq#closures_and_goroutines" target="_blank" rel="external">https://golang.org/doc/faq#closures_and_goroutines</a></li>
</ul>
<h3 id="goroutine是什么">goroutine是什么</h3>
<p>goroutine是Go语言独有的概念。</p>
<p>并发和多线程编程总是被认为很困难，多少是由于它们的实现，对于线程和并发访问的控制很复杂。 Go语言并发的基础是goroutine和channel。<br>这些概念来源于著名计算机科学家C.A.R.Hoare的Communication Sequential Process （简称<a href="http://baike.baidu.com/subview/93641/8244751.htm" target="_blank" rel="external">CSP</a>)。<br>在该语言中，一个并发系统由若干并行运行的顺序进程组成，每个进程不能对其他进程的变量赋值。进程之间只能通过 一对通信原语实现协作：Q-&gt;x表示从进程Q输入一个值到变量x中；P&lt;-e表示把表达式e的值发送给进程P。当P进程执行Q-&gt;x， 同时Q进程执行P&lt;-e时，发生通信，e的值从Q进程传送给P进程的变量x。<br>Occam和Erlang基于CSP的理论实现的并发模型。</p>
<p>Go也借鉴了CSP的理论，但又有所不同，最大的不同是Go显示地使用channel, channel在Go中是第一类的对象，goroutine通信完全通过通过channel实现的。<br>CSP模型中消息的分发是即时和同步的，Go的Channel则不同，消息会缓存在Channel中。</p>
<p>我看到的一个有趣的项目是使用Go语言实现Hoare论文中的例子，有兴趣的朋友可以仔细观看，<a href="https://github.com/thomas11/csp" target="_blank" rel="external">csp</a>。</p>
<p>幸运地是，这些实现的细节对于Go语言的学习和应用来说不是必须的，对于语言的设计者来说，倒是值得比较和研究和出论文。</p>
<p>但是，对于开发者来说，至少应该明白goroutine和线程的不同，为什么一个Go应用可以存在成千上万个goroutine为线程确不行。</p>
<p><strong>goroutine vs thread</strong><br>对于线程来讲，Java的线程是最有名了。我们从三个方面进行比较：<br>1、内存占用<br>goroutine并不需要太多太多的内存占用，初始只需2kB的栈空间即可(自Go 1.4起)，按照需要可以增长。</p>
<p>线程初始1MB，并且会分配一个防护页(guard page)。</p>
<p>在使用Java开发服务器的过程中经常会遇到request per thread的问题，如果为每个请求都分配一个线程的话，大并发的情况下服务器很快就死掉，因为内存不够了，所以很多Java框架比如Netty都会使用线程池来处理请求，而不会让线程任意增长。</p>
<p>而使用goroutine则没有这个问题，你页可以看到官方的net/http库就是使用request per goroutine这种模式进行处理的，内存占用不会是问题。</p>
<p>2、对象的创建和销毁<br>线程的创建和销毁肯定有花费，因为需要从OS中请求／返还资源。</p>
<p>而goroutine的创建和销毁花费很少，因为它是用户态的操作。并且Go语言也不提供goroutine的手工管理。</p>
<p>3、切换时间<br>当线程阻塞时，其它的线程进可能被执行，这叫做线程的切换。切换的时候，调度器需要保存当前阻塞的线程的状态，恢复要执行的线程状态，包括所有的寄存器，16个通用寄存器、程序计数器、栈指针、段寄存器、16个XMM寄存器、FP协处理器、16个 AVX寄存器、所有的MSR等等。</p>
<p>goroutine的保存和恢复只需要三个寄存器：程序计数器、栈指针和DX寄存器。因为goroutine之间共享堆空间，不共享栈空间，所以只需把goroutine的栈指针和程序执行到那里的信息保存和恢复即可，花费很低。</p>
<p>通过上面三个方面的分析，可以看到goroutine比线程有更多的优势。实际上Go使用少量线程来执行这些goroutine,通过GOMAXPROCS环境变量可以控制有多少线程可以并发执行用户态的代码。由于系统调用而被阻塞的线程不受这个变量的限制。以前版本的Go中这个变量为1,自Go 1.5后它的默认值为CPU的核数。</p>
<blockquote>
<p><strong>进程</strong>拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。<br><strong>线程</strong>拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。<br><strong>协程</strong>和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。</p>
</blockquote>
<p><strong>goroutine vs coroutine</strong><br>两个类似，都是共享堆，不共享栈，切换的时候需要保存和恢复栈信息。</p>
<p>但是coroutine(协程)需要显示地控制coroutine的转换，程序员需要在切换的地方调用<code>yield</code>让度当前的coroutine的执行，这样其它coroutine才有可能在这个线程中执行,等暂停的coroutine恢复执行的时候，它会接着上次暂停的地方继续执行，而不像普通的函数从头开始执行。 看一段lua的coroutine代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="params">(a)</span></span></div><div class="line">    <span class="built_in">print</span>(<span class="string">"foo"</span>, a)</div><div class="line">    <span class="keyword">return</span> <span class="built_in">coroutine</span>.yield(<span class="number">2</span>*a)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  co = <span class="built_in">coroutine</span>.create(<span class="function"><span class="keyword">function</span> <span class="params">(a,b)</span></span></div><div class="line">        <span class="built_in">print</span>(<span class="string">"co-body"</span>, a, b)</div><div class="line">        <span class="keyword">local</span> r = foo(a+<span class="number">1</span>)</div><div class="line">        <span class="built_in">print</span>(<span class="string">"co-body"</span>, r)</div><div class="line">        <span class="keyword">local</span> r, s = <span class="built_in">coroutine</span>.yield(a+b, a-b)</div><div class="line">        <span class="built_in">print</span>(<span class="string">"co-body"</span>, r, s)</div><div class="line">        <span class="keyword">return</span> b, <span class="string">"end"</span></div><div class="line">  <span class="keyword">end</span>)</div><div class="line"></div><div class="line">  <span class="built_in">print</span>(<span class="string">"main"</span>, <span class="built_in">coroutine</span>.resume(co, <span class="number">1</span>, <span class="number">10</span>))</div><div class="line">  <span class="built_in">print</span>(<span class="string">"main"</span>, <span class="built_in">coroutine</span>.resume(co, <span class="string">"r"</span>))</div><div class="line">  <span class="built_in">print</span>(<span class="string">"main"</span>, <span class="built_in">coroutine</span>.resume(co, <span class="string">"x"</span>, <span class="string">"y"</span>))</div><div class="line">  <span class="built_in">print</span>(<span class="string">"main"</span>, <span class="built_in">coroutine</span>.resume(co, <span class="string">"x"</span>, <span class="string">"y"</span>))</div></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">co-<span class="keyword">body</span> <span class="number">1</span>       <span class="number">10</span></div><div class="line">foo     <span class="number">2</span></div><div class="line"></div><div class="line">main    <span class="literal">true</span>    <span class="number">4</span></div><div class="line">co-<span class="keyword">body</span> r</div><div class="line">main    <span class="literal">true</span>    <span class="number">11</span>      -<span class="number">9</span></div><div class="line">co-<span class="keyword">body</span> x       y</div><div class="line">main    <span class="literal">true</span>    <span class="number">10</span>      end</div><div class="line">main    <span class="literal">false</span>   cannot resume dead coroutine</div></pre></td></tr></table></figure>

<p>可以看到coroutine切换都是通过代码中的yield触发的。</p>
<p>goroutine也是由一组线程执行，也会暂停，也会继续执行，但是这个控制不是程序员实现安排好的，它是由go运行时后台控制的。goroutine的调度不能手工的执行，这是和coroutine最大的区别。当goroutine阻塞的时候，就有可能让度出线程以便其它goroutine执行，以下几种情况goroutine可能暂停自己的运行：</p>
<ul>
<li>调用runtime.Gosched()将当前goroutine放入到全局队列</li>
<li>调用runtime.Goexit，终止G任务</li>
<li>网络读取</li>
<li>sleep</li>
<li>channel操作</li>
<li>调用sync包中的对象进行阻塞</li>
<li>其它gouroutine被阻塞的情况,比如io读取,空无限循环，长时间占用线程执行的goroutine</li>
</ul>
<p>利用goroutine和channel也可以实现cororutine,比如下面的<a href="https://github.com/Jxck/goroutine-sample/blob/master/coroutine.go" target="_blank" rel="external">代码</a>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> f(yield <span class="keyword">chan</span> <span class="typename">string</span>) {</div><div class="line">	yield &lt;- <span class="string">"one"</span></div><div class="line">	yield &lt;- <span class="string">"two"</span></div><div class="line">	yield &lt;- <span class="string">"three"</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	co := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">string</span>)</div><div class="line">	<span class="keyword">go</span> f(co)</div><div class="line">	log.Println(&lt;-co) <span class="comment">// one</span></div><div class="line">	log.Println(&lt;-co) <span class="comment">// two</span></div><div class="line">	log.Println(&lt;-co) <span class="comment">// three</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>参考</p>
<ul>
<li><a href="https://talks.golang.org/2012/concurrency.slide" target="_blank" rel="external">https://talks.golang.org/2012/concurrency.slide</a></li>
<li><a href="https://talks.golang.org/2012/waza.slide" target="_blank" rel="external">https://talks.golang.org/2012/waza.slide</a></li>
<li><a href="http://blog.nindalf.com/how-goroutines-work/" target="_blank" rel="external">http://blog.nindalf.com/how-goroutines-work/</a></li>
<li><a href="http://stackoverflow.com/questions/18058164/is-a-go-goroutine-a-coroutine" target="_blank" rel="external">http://stackoverflow.com/questions/18058164/is-a-go-goroutine-a-coroutine</a></li>
<li><a href="http://www.golangpatterns.info/concurrency/coroutines" target="_blank" rel="external">http://www.golangpatterns.info/concurrency/coroutines</a></li>
<li><a href="https://golang.org/doc/faq#goroutines" target="_blank" rel="external">https://golang.org/doc/faq#goroutines</a></li>
<li><a href="https://blog.golang.org/share-memory-by-communicating" target="_blank" rel="external">https://blog.golang.org/share-memory-by-communicating</a></li>
<li><a href="http://stackoverflow.com/questions/32651557/golang-main-difference-from-csp-language-by-hoare" target="_blank" rel="external">http://stackoverflow.com/questions/32651557/golang-main-difference-from-csp-language-by-hoare</a></li>
<li><a href="http://www.informit.com/articles/printerfriendly/1768317" target="_blank" rel="external">http://www.informit.com/articles/printerfriendly/1768317</a></li>
<li><a href="https://en.wikipedia.org/wiki/Coroutine" target="_blank" rel="external">https://en.wikipedia.org/wiki/Coroutine</a></li>
<li><a href="http://www.jianshu.com/p/36e246c6153d" target="_blank" rel="external">http://www.jianshu.com/p/36e246c6153d</a></li>
<li><a href="https://github.com/golang/go/issues/4056" target="_blank" rel="external">https://github.com/golang/go/issues/4056</a></li>
<li><a href="http://stackoverflow.com/questions/28354141/c-code-and-goroutine-scheduling" target="_blank" rel="external">http://stackoverflow.com/questions/28354141/c-code-and-goroutine-scheduling</a></li>
</ul>
<h3 id="goroutine的调度">goroutine的调度</h3>
<p>goroutine调度(Scheduling)的文章网上非常多了，而且分析的都很深入。本文重点的介绍其中的一些细节。</p>
<p>goroutine调度器有三个重要的数据结构，都是以单字母命名: G、P、M,因为Golang以及实现了自举，所以绝大部分的代码都是由Go本身实现的，少部分的以汇编实现，因为你已经由Go的基础知识了，所以你可以查看这些实现的代码不会感到特别困难。</p>
<p><img src="models.jpg" alt=""></p>
<ul>
<li>M代表系统线程(Machine)，由操作系统管理。</li>
<li>G代表goroutine,包括栈／指令指针以及其它对调度goroutine有用的信息。</li>
<li>P代表处理器(processor),注意不是CPU处理器，而是调度处理器，包含调度的上下文。</li>
</ul>
<p>这三个个对象的数据结构定义在Go源代码的<a href="https://golang.org/src/runtime/runtime2.go" target="_blank" rel="external">src/runtime/runtime2.go</a>中定义，另外还包括一个很重要的数据结构schedt。</p>
<p>P必须和M组合起来执行G，但是两者也并不是完全1:1对应，通常情况下P的数量固定和CPU的核数一样(GOMAXPROCS参数)，M则是按需创建，比如当M因为陷入系统调用而长时间阻塞的时候，P就会被监控线程抢回，去新建或者唤醒另一个M去执行，因此M的数量会增加，系统中可能存在一些阻塞的M。</p>
<p>当一个G被创建的时候，它可能被放入到一个P的本地队列或者全局队列中：<br><img src="p.jpg" alt=""></p>
<p>由于goroutine的执行的时间不会一样，goroutine不可能均匀地分布在所有的P的本地队列中，如果其中的一个P执行地很快，它的队列中没有其它的gouroutine需要执行了，它就会从全局队列中拿一批goroutine过来。</p>
<p>如果全局队列中也没有要执行的goroutine，那么这个P可能要从其它的P中“偷”一些goroutine过来。</p>
<p>这样设计的目的就是不要让一部分P忙的要死，另外一部分P确很清闲，这是一个balance的过程。<br><img src="steal.jpg" alt=""></p>
<p>编译器会将&quot;go func(……){}(……)&quot;翻译成&quot;newproc&quot;调用,这个方法在runtime/proc.go中定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Create a new g running fn with siz bytes of arguments.</span></div><div class="line"><span class="comment">// Put it on the queue of g's waiting to run.</span></div><div class="line"><span class="comment">// The compiler turns a go statement into a call to this.</span></div><div class="line"><span class="comment">// Cannot split the stack because it assumes that the arguments</span></div><div class="line"><span class="comment">// are available sequentially after &fn; they would not be</span></div><div class="line"><span class="comment">// copied if a stack split occurred.</span></div><div class="line"><span class="comment">//go:nosplit</span></div><div class="line"><span class="keyword">func</span> newproc(siz <span class="typename">int32</span>, fn *funcval) {</div><div class="line">	argp := add(unsafe.Pointer(&fn), sys.PtrSize)</div><div class="line">	pc := getcallerpc(unsafe.Pointer(&siz))</div><div class="line">	systemstack(<span class="keyword">func</span>() {</div><div class="line">		newproc1(fn, (*<span class="typename">uint8</span>)(argp), siz,<span class="number"> 0</span>, pc)</div><div class="line">	})</div><div class="line">}</div></pre></td></tr></table></figure>

<p>它的创建G的主要逻辑在newproc1中实现，并调用<code>runqput</code>将创建的G放入到队列中。注意G是可以重用的，如果有重用的G，则选择一个，否则创建一个新的，而且它也有本地复用链表和全局复用链表。</p>
<p><code>runqput</code>首先尝试将G放入到P本地队列的本地队列中，而且在不设置&quot;-race&quot;的情况下,可能会尝试将这个G放在p.runnext中，作为下一个优先处理的G，而原先的runnext放回队尾。如果本地队列已满，则放入到全局队列中，而且还会将本地队列的一部分放入到全局队列中。</p>
<p>任务队列的优先级分三种：P.runnext、P.runq和全局的Schedt.runq。</p>
<p><code>schedule</code>方法用来实现goroutine的调用，你可以在proc.go文件中搜索对它的调用。</p>
<p>如果你浏览schedule()方法的实现，可以看到每隔一定时间，会先尝试从全局队列中获取g去执行，这样就避免全局队列中的g没机会执行。</p>
<p>然后尝试本地队列中获取g, 依照优先级选择g,先是P.runnext,然后从队列的头部依次获取。</p>
<p>如果本地队列没有g,则调用<code>findrunnable</code>方法从其它地方获取,这是一个block方法，直到有g获取到。<br>findrunnable首先从本地队列获取(runqget方法)，然后从全局队列获取(globrunqget),然后检查netpoll的goroutine,<br>如果还没有，随机选择一个P,偷一些任务过来(runqsteal方法，如果“饿”的厉害，连别人的runnext都偷过来)。<br>具体的获取过程你可以查看每个选择的方法。</p>
<p>你可以通过schedtrace调试参数查看Go调度的细节：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GOMAXPROCS<span class="number">=1</span> GODEBUG=schedtrace<span class="number">=1000</span> ./example</div></pre></td></tr></table></figure>

<p>详细的文章可以查看我翻译的William Kennedy的<a href="http://colobu.com/2016/04/19/Scheduler-Tracing-In-Go/" target="_blank" rel="external">Scheduler Tracing In Go</a></p>
<p>参考</p>
<ul>
<li><a href="https://golang.org/pkg/runtime/" target="_blank" rel="external">https://golang.org/pkg/runtime/</a></li>
<li><a href="http://www.cs.columbia.edu/~aho/cs6998/reports/12-12-11_DeshpandeSponslerWeiss_GO.pdf" target="_blank" rel="external">http://www.cs.columbia.edu/~aho/cs6998/reports/12-12-11_DeshpandeSponslerWeiss_GO.pdf</a></li>
<li><a href="https://morsmachine.dk/go-scheduler" target="_blank" rel="external">https://morsmachine.dk/go-scheduler</a></li>
<li><a href="http://studygolang.com/articles/6070" target="_blank" rel="external">http://studygolang.com/articles/6070</a></li>
<li><a href="http://www.slideshare.net/matthewrdale/demystifying-the-go-scheduler" target="_blank" rel="external">http://www.slideshare.net/matthewrdale/demystifying-the-go-scheduler</a></li>
<li><a href="https://github.com/qyuhen/book/blob/master/Go%201.5%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90.pdf" target="_blank" rel="external">https://github.com/qyuhen/book/blob/master/Go%201.5%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90.pdf</a></li>
<li><a href="https://www.goinggo.net/2015/02/scheduler-tracing-in-go.html" target="_blank" rel="external">https://www.goinggo.net/2015/02/scheduler-tracing-in-go.html</a></li>
<li><a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/05.1.html" target="_blank" rel="external">https://tiancaiamao.gitbooks.io/go-internals/content/zh/05.1.html</a></li>
<li><a href="http://dave.cheney.net/2015/08/08/performance-without-the-event-loop" target="_blank" rel="external">http://dave.cheney.net/2015/08/08/performance-without-the-event-loop</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>本章介绍 go语句、goroutine调度。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入Go语言 - 7]]></title>
    <link href="http://colobu.com/2016/06/22/dive-into-go-7/"/>
    <id>http://colobu.com/2016/06/22/dive-into-go-7/</id>
    <published>2016-06-22T08:26:47.000Z</published>
    <updated>2016-07-06T05:31:56.000Z</updated>
    <content type="html"><![CDATA[<p>本章介绍Go语言的各种语句。</p>
<a id="more"></a>
<p>Go语言的语法定义罗列了所有的语句类型:</p>
<pre class="highlight">
Statement =
    Declaration | LabeledStmt | SimpleStmt |
    GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |
    FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |
    DeferStmt .

SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .
</pre>


<p>语句控制程序逻辑的运行。终止语句(terminating statement)代表结束当前程序逻辑单元的运行。<br>1、 A &quot;return&quot; or &quot;goto&quot; statement.<br>2、A call to the built-in function panic.<br>3、A block in which the statement list ends in a terminating statement.<br>4、 An &quot;if&quot; statement in which:</p>
<ul>
<li>the &quot;else&quot; branch is present, and</li>
<li>both branches are terminating statements.</li>
</ul>
<p>5、A &quot;for&quot; statement in which:</p>
<ul>
<li>there are no &quot;break&quot; statements referring to the &quot;for&quot; statement, and</li>
<li>the loop condition is absent.</li>
</ul>
<p>6、A &quot;switch&quot; statement in which:</p>
<ul>
<li>there are no &quot;break&quot; statements referring to the &quot;switch&quot; statement,</li>
<li>there is a default case, and</li>
<li>the statement lists in each case, including the default, end in a terminating statement, or a possibly labeled &quot;fallthrough&quot; statement.</li>
</ul>
<p>7、A &quot;select&quot; statement in which:</p>
<ul>
<li>there are no &quot;break&quot; statements referring to the &quot;select&quot; statement, and</li>
<li>the statement lists in each case, including the default if present, end in a terminating statement.</li>
</ul>
<p>8、A labeled statement labeling a terminating statement.</p>
<p>其它的语句都不会终止程序单元的执行。</p>
<p>参考</p>
<ul>
<li><a href="https://github.com/golang/go/issues/14422" target="_blank" rel="external">https://github.com/golang/go/issues/14422</a></li>
<li><a href="https://github.com/golang/go/issues/14537" target="_blank" rel="external">https://github.com/golang/go/issues/14537</a></li>
</ul>
<h3 id="空语句">空语句</h3>
<p>空语句不错任何事</p>
<h3 id="标签语句">标签语句</h3>
<p>增加一个标签， 为 goto、break、continue 使用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error: log.Panic(<span class="string">"error encountered"</span>)</div></pre></td></tr></table></figure>

<h3 id="表达式语句">表达式语句</h3>
<p>除了特别的内置函数， 一般函数和方法调用、receive 操作都可以出现在语句的上下文中，<br>这样的语句可以用括号括起来。</p>
<p>下面的内置的函数不能在语句中：</p>
<pre class="highlight">
append cap complex imag len make new real
unsafe.Alignof unsafe.Offsetof unsafe.Sizeof
</pre>

<p>下面的操作都可以作为语句：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">h(x+y)</div><div class="line">f.Close()</div><div class="line">&lt;-ch</div><div class="line">(&lt;-ch)</div></pre></td></tr></table></figure>

<p>但是下面的内置函数调用就不可以:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">len</span>(<span class="string">"foo"</span>) <span class="comment">//错误</span></div></pre></td></tr></table></figure>

<h3 id="send语句">send语句</h3>
<p>可以通过send的语句往channel发送一个值。</p>
<h3 id="自增和自减语句">自增和自减语句</h3>
<p>注意，Go语言中&quot;++&quot;和&quot;--&quot;是语句(statement)，而不是表达式(expression)，并且只能放在操作数的后面(postfix)。操作数必须是可寻址的或者是map索引表达式。</p>
<p><code>x++</code> 等价于 <code>x += 1</code>，<code>x--</code> 等价于 <code>x -= 1</code>。</p>
<p>因为它们不是表达式，所以不能以表达式的方式给其它变量赋值，下面的代码是错误的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span>{<span class="string">"1"</span>:<span class="number"> 1</span>, <span class="string">"2"</span>:<span class="number"> 2</span>}</div><div class="line">m[<span class="string">"1"</span>]++</div><div class="line"></div><div class="line">i :=<span class="number"> 0</span></div><div class="line">i++</div><div class="line"></div><div class="line"><span class="keyword">var</span> j = i++ <span class="comment">//错误</span></div></pre></td></tr></table></figure>

<h3 id="赋值语句">赋值语句</h3>
<p>赋值语句左边的操作数必须是可寻址的、或者是map索引表达式、抑或是空标识符_。</p>
<p>操作数可以用括号括起来，不管是左边的操作数还是右边的操作数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i, j <span class="typename">int</span></div><div class="line">(i), (j) = <span class="number">(3</span>),<span class="number"> 4</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> k <span class="typename">int</span></div><div class="line">(k) = i</div><div class="line">_, _, _ = i, j, k</div></pre></td></tr></table></figure>

<p>复合的赋值操作 <code>x op= y</code>等价于<code>x = x op (y)</code>,但是x只会被计算一次。运算符的左右两边只能是单值的表达式，而且左边的操作符不能是空标识符。</p>
<p>前面也有代码举例，Go支持多值赋值(tuple)，左边的操作数的数量必须和右边的值的数量相同。</p>
<p>赋值过程分为两阶段：</p>
<ol>
<li>计算左边的索引表达式的操作数和指针， 右边的表达式</li>
<li>从左到右赋值</li>
</ol>
<p>下面是赋值语句的一些例子，你可以琢磨琢磨。</p>
<pre class="highlight">
a, b = b, a  // exchange a and b

x := []int{1, 2, 3}
i := 0
i, x[i] = 1, 2  // set i = 1, x[0] = 2

i = 0
x[i], i = 2, 1  // set x[0] = 2, i = 1

x[0], x[0] = 1, 2  // set x[0] = 1, then x[0] = 2 (so x[0] == 2 at end)

x[1], x[3] = 4, 5  // set x[1] = 4, then panic setting x[3] = 5.

type Point struct { x, y int }
var p *Point
x[2], p.x = 6, 7  // set x[2] = 6, then panic setting p.x = 7

i = 2
x = []int{3, 5, 7}
for i, x[i] = range x {  // set i, x[2] = 0, x[0]
    break
}
// after this loop, i == 0 and x == []int{3, 5, 3}
</pre>

<h3 id="if_语句">if 语句</h3>
<p>if语句类似其它语言中比如Java、C的if语句，但是也有不同：<br>1、if语句中的条件表达式可以有简单的语句:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> x := f(); x &lt; y {</div><div class="line">	<span class="keyword">return</span> x</div><div class="line">} <span class="keyword">else</span> <span class="keyword">if</span> x &gt; z {</div><div class="line">	<span class="keyword">return</span> z</div><div class="line">} <span class="keyword">else</span> {</div><div class="line">	<span class="keyword">return</span> y</div><div class="line">}</div></pre></td></tr></table></figure>

<p>2、代码块必须以大括号括起来，即使是单行代码块不能省略大括号</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> x &gt; max</div><div class="line">  x = max  <span class="comment">//错误</span></div></pre></td></tr></table></figure>

<p>3、if 中的条件表达式可以省略括号，而且一般都省略括号</p>
<h3 id="switch_语句">switch 语句</h3>
<p>switch提供了多路处理的机制。switch有两种：表达式switch和type switch。 类型switch在前一章中已经介绍了，本节只介绍表达式switch。</p>
<p>表达式switch(以下直接叫switch)中的表达式会被计算，然后和case clause进行比较。case clause中的表达式不一定是常数。表达式的计算都是从左到右，从上而下的计算的。</p>
<p>如果遇到第一个满足的case，其它的case就不会执行，如果没有满足条件的case,并且有一个default的case的话，会执行default代码块，相当于default用来兜底。最多有一个default，而且一般都将它放在底部，尽管它的位置和其它case cluase没有顺序限制。</p>
<p>在case表达式中，对于未声明类型的bool常量，它首先会被转换成bool类型，对于其它常量，会被转换成缺省类型进行比较。</p>
<p>编译器可能不允许有重复的 case 常量 clause,但是非常量的表达式可以：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	i :=<span class="number"> 4</span></div><div class="line"></div><div class="line">	<span class="keyword">switch</span> i {</div><div class="line">	<span class="keyword">case</span><span class="number"> 1</span>:</div><div class="line">		fmt.Println<span class="number">(1</span>)</div><div class="line">	<span class="keyword">case</span><span class="number"> 2</span>:</div><div class="line">		fmt.Println<span class="number">(2</span>)</div><div class="line">	<span class="keyword">case</span> f():</div><div class="line">		fmt.Println(<span class="string">"f"</span>)</div><div class="line">	<span class="keyword">case</span><span class="number"> 4</span>:</div><div class="line">		fmt.Println<span class="number">(4</span>)</div><div class="line"></div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		fmt.Println(<span class="string">"unknown"</span>)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> f() <span class="typename">int</span> {</div><div class="line">	<span class="keyword">return</span><span class="number"> 4</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>fallthrough</code>语句可以是case语句或者default的代码块的最后一个语句，只要当前的case语句或者default语句不是最后一个case语句。 但是<code>fallthrough</code>不能出现在代码块的中间(非最后一个语句)。</p>
<p><code>fallthrough</code>将直接跳到下一个case clause的代码块的第一个语句中，不会和那个case 表达式再进行比较。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">i :=<span class="number"> 1</span></div><div class="line"></div><div class="line"><span class="keyword">switch</span> i {</div><div class="line"><span class="keyword">case</span><span class="number"> 1</span>:</div><div class="line">	fmt.Println<span class="number">(1</span>)</div><div class="line">	<span class="keyword">fallthrough</span></div><div class="line">	<span class="comment">//fmt.Println("after fallthrough") //错误</span></div><div class="line"><span class="keyword">case</span><span class="number"> 2</span>:</div><div class="line">	fmt.Println<span class="number">(2</span>)</div><div class="line"><span class="keyword">case</span><span class="number"> 3</span>:</div><div class="line">	fmt.Println<span class="number">(3</span>)</div><div class="line"><span class="keyword">default</span>:</div><div class="line">	fmt.Println(<span class="string">"unknown"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的代码输出 1 和 2。</p>
<p>switch 表达式的前面可以有简单的表达式，它在switch表达式计算之前执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> x := f(); x<span class="number">&gt;0</span> {</div><div class="line">	<span class="keyword">case</span> <span class="constant">true</span>:</div><div class="line">}</div></pre></td></tr></table></figure>

<p>switch表达式也可以省略，省略的时候意味着表达式为 true，所以会进入case 表达式为true的代码块：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> {</div><div class="line"><span class="keyword">case</span> x &lt; y: f1()</div><div class="line"><span class="keyword">case</span> x &lt; z: f2()</div><div class="line"><span class="keyword">case</span> x ==<span class="number"> 4</span>: f3()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>switch表达式也一般省略括号。</p>
<h3 id="for_语句">for 语句</h3>
<p>for 语句也不用括号,而且在三段式的for语句中，加上括号反而报错。</p>
<p>Go扩展了其它语言中的for语句饿功能，它有以下的形式：</p>
<p>1、普通的三段式的for语句 <code>for init; condition; post {……}</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 10</span>; i++ {</div><div class="line">	fmt.Println(i)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>其中的三段中的任意部分都可以省略，但是分号不能省略。</p>
<p>2、只包含条件表达式的for语句 <code>for condition {}</code><br>Go语言中没有while语句，所以for的这种形式类似while语句。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">i :=<span class="number"> 0</span></div><div class="line"><span class="keyword">for</span> i &lt;<span class="number"> 10</span> {</div><div class="line">	i++</div><div class="line">}</div></pre></td></tr></table></figure>

<p>3、for ... range语句<br>对于数组、slice、字符串、map对象以及 从channel中接收的值，可以使用这种语句进行遍历。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = []<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>,<span class="number"> 4</span>,<span class="number"> 5</span>}</div><div class="line"></div><div class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> s {</div><div class="line">	fmt.Printf(<span class="string">"index: %d, value: %d\n"</span>, i, v)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>对于不同的类型， range迭代的结果可能是一个值，也可能是两个值。具体如下：</p>
<table>
<thead>
<tr>
<th>Range 表达式</th>
<th>第一个值</th>
<th>第二个值</th>
</tr>
</thead>
<tbody>
<tr>
<td>array or slice  a  [n]E, *[n]E, or []E</td>
<td>index    i  int</td>
<td>a[i]       E</td>
</tr>
<tr>
<td>string          s  string type</td>
<td>index    i  int</td>
<td>see below  rune</td>
</tr>
<tr>
<td>map             m  map[K]V</td>
<td>key      k  K</td>
<td>m[k]       V</td>
</tr>
<tr>
<td>channel         c  chan E, &lt;-chan E</td>
<td>element  e  E</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>4、 无任何条件和语句的 for</p>
<figure class="highlight for"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="constant">i</span> := 10</div><div class="line">for {</div><div class="line">	i++</div><div class="line">	if i &gt; 20 {</div><div class="line">		break</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li>对于数组，数组指针、slice，索引从0开始，止于 len(a) -1</li>
<li>对于字符串， range将迭代unicode code point，而不是字节byte, 因此索引值为当前unicode字符的起始位置，值为rune。如果不是unicode字符，第二个值为0xFFFD</li>
<li>对于map的迭代每次迭代可能不同。入股迭代的过程中还没有被访问的对象被移除了，后续的迭代中不会出现这些删除的值。如果迭代的过程中往map中增加值，则增加的值可能出现后续的迭代中，也可能不出现。</li>
<li>对于channel,迭代一直会执行，直到channel被关闭。如果channel为nil,则range表达式永远被阻塞，一定要注意。</li>
</ul>
<h3 id="select_语句">select 语句</h3>
<p>select语句从一组<a href="https://golang.org/ref/spec#Send_statements" target="_blank" rel="external">send</a>操作和<a href="https://golang.org/ref/spec#Receive_operator" target="_blank" rel="external">receive</a>操作中选择一个执行。</p>
<p>它类似switch但是只用来对channel进行操作。</p>
<ul>
<li>channel操作数如果是一个表达式，那么表达式只会被计算一次</li>
<li>如果有多个case可以被执行，只有一个case会被选择执行。选择算法是伪随机算法。如果没有case可以执行，并且有一个default case,则这个default会被选择执行， 如果没有default, select会被阻塞直到有一个case可以被执行。</li>
</ul>
<p>select一次只有一个case会执行，所以很多情况下我们把它放入到一个 for循环中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a []<span class="typename">int</span></div><div class="line"><span class="keyword">var</span> c, c1, c2, c3, c4 <span class="keyword">chan</span> <span class="typename">int</span></div><div class="line"><span class="keyword">var</span> i1, i2 <span class="typename">int</span></div><div class="line"><span class="keyword">select</span> {</div><div class="line"><span class="keyword">case</span> i1 = &lt;-c1:</div><div class="line"> <span class="built_in">print</span>(<span class="string">"received "</span>, i1, <span class="string">" from c1\n"</span>)</div><div class="line"><span class="keyword">case</span> c2 &lt;- i2:</div><div class="line"> <span class="built_in">print</span>(<span class="string">"sent "</span>, i2, <span class="string">" to c2\n"</span>)</div><div class="line"><span class="keyword">case</span> i3, ok := (&lt;-c3):  <span class="comment">// same as: i3, ok := &lt;-c3</span></div><div class="line"> <span class="keyword">if</span> ok {</div><div class="line">	 <span class="built_in">print</span>(<span class="string">"received "</span>, i3, <span class="string">" from c3\n"</span>)</div><div class="line"> } <span class="keyword">else</span> {</div><div class="line">	 <span class="built_in">print</span>(<span class="string">"c3 is closed\n"</span>)</div><div class="line"> }</div><div class="line"><span class="keyword">case</span> a[f()] = &lt;-c4:</div><div class="line"> <span class="comment">// same as:</span></div><div class="line"> <span class="comment">// case t := &lt;-c4</span></div><div class="line"> <span class="comment">//	a[f()] = t</span></div><div class="line"><span class="keyword">default</span>:</div><div class="line"> <span class="built_in">print</span>(<span class="string">"no communication\n"</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">for</span> {  <span class="comment">// send random sequence of bits to c</span></div><div class="line"> <span class="keyword">select</span> {</div><div class="line"> <span class="keyword">case</span> c &lt;-<span class="number"> 0</span>:  <span class="comment">// note: no statement, no fallthrough, no folding of cases</span></div><div class="line"> <span class="keyword">case</span> c &lt;-<span class="number"> 1</span>:</div><div class="line"> }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">select</span> {}  <span class="comment">// block forever</span></div></pre></td></tr></table></figure>

<p>select 语句也经常加入超时的case:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">  c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">string</span>,<span class="number"> 1</span>)</div><div class="line">  <span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">      time.Sleep(time.Second *<span class="number"> 2</span>)</div><div class="line">      c1 &lt;- <span class="string">"result 1"</span></div><div class="line">  }()</div><div class="line"></div><div class="line"><span class="comment">//执行超时case</span></div><div class="line">  <span class="keyword">select</span> {</div><div class="line">  <span class="keyword">case</span> res := &lt;-c1:</div><div class="line">      fmt.Println(res)</div><div class="line">  <span class="keyword">case</span> &lt;-time.After(time.Second *<span class="number"> 1</span>):</div><div class="line">      fmt.Println(<span class="string">"timeout 1"</span>)</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="comment">//执行C2</span></div><div class="line">  c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">string</span>,<span class="number"> 1</span>)</div><div class="line">  <span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">      time.Sleep(time.Second *<span class="number"> 2</span>)</div><div class="line">      c2 &lt;- <span class="string">"result 2"</span></div><div class="line">  }()</div><div class="line">  <span class="keyword">select</span> {</div><div class="line">  <span class="keyword">case</span> res := &lt;-c2:</div><div class="line">      fmt.Println(res)</div><div class="line">  <span class="keyword">case</span> &lt;-time.After(time.Second *<span class="number"> 3</span>):</div><div class="line">      fmt.Println(<span class="string">"timeout 2"</span>)</div><div class="line">  }</div></pre></td></tr></table></figure>

<h3 id="return_语句">return 语句</h3>
<p>return语句从函数中返回。</p>
<p>如果函数没有返回类型， return语句不能返回任何值。</p>
<p>如果函数有返回类型，那么有几种情况<br>1、返回值可以显示地写在return的后面,每个表达式必须是单值的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> simpleF() <span class="typename">int</span> {</div><div class="line">	<span class="keyword">return</span><span class="number"> 2</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> complexF1() (re <span class="typename">float64</span>, im <span class="typename">float64</span>) {</div><div class="line">	<span class="keyword">return</span><span class="number"> -7.0</span>,<span class="number"> -4.0</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>2、return语句中的表达式列表可以是对返回多只函数的调用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> complexF2() (re <span class="typename">float64</span>, im <span class="typename">float64</span>) {</div><div class="line">	<span class="keyword">return</span> complexF1()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>3、如果函数的返回类型参数指定了名字，则return 可以返回空。这些返回类型参数就像本地变量一样。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> complexF3() (re <span class="typename">float64</span>, im <span class="typename">float64</span>) {</div><div class="line">	re =<span class="number"> 7.0</span></div><div class="line">	im =<span class="number"> 4.0</span></div><div class="line">	<span class="keyword">return</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (devnull) Write(p []<span class="typename">byte</span>) (n <span class="typename">int</span>, _ error) {</div><div class="line">	n = <span class="built_in">len</span>(p)</div><div class="line">	<span class="keyword">return</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>所有的结果值在函数的开始时都被初始化为它们的零值。</p>
<p>编译器可能不允许下面的scope中的return返回空：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> f(n <span class="typename">int</span>) (res <span class="typename">int</span>, err error) {</div><div class="line">	<span class="keyword">if</span> _, err := f(n<span class="number">-1</span>); err != <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span>  <span class="comment">// invalid return statement: err is shadowed</span></div><div class="line">	}</div><div class="line">	<span class="keyword">return</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="break_语句">break 语句</h3>
<p>break用来终止执行最内层的 for、 switch 或者 select语句。</p>
<p>如果break后面跟着一个标签，则标签应该紧贴着要终止的for、switch或者selector语句，下面的代码中 break label2就是错的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">label2:</div><div class="line">	i :=<span class="number"> 10</span></div><div class="line"></div><div class="line">label1:</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		i++</div><div class="line">		<span class="keyword">if</span> i &gt;<span class="number"> 20</span> {</div><div class="line">			<span class="keyword">break</span> label1</div><div class="line">		}</div><div class="line">		fmt.Println(i)</div><div class="line">		<span class="keyword">if</span> i &lt;<span class="number"> 10</span> {</div><div class="line">			<span class="keyword">break</span> label2</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<p>为什么要用标签呢？因为不带标签的break只能终止最内层(innermost)的循环，如果像终止外部的循环，就得用标签了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">label1:</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		fmt.Println(<span class="string">"hello"</span>)</div><div class="line">		<span class="keyword">for</span> {</div><div class="line">			fmt.Println(<span class="string">"world"</span>)</div><div class="line">			<span class="keyword">break</span> label1</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<h3 id="continue_语句">continue 语句</h3>
<p>continue语句开始最内层的 for循环的下一次迭代，终止本次迭代。</p>
<p>同样，如果后面跟着标签，将开始外层的标签指定的for循环的下一次迭代。</p>
<h3 id="goto语句">goto语句</h3>
<p>goto跳转太强大，在很多语言中虽然都提供但是不推荐使用，Go也一样。</p>
<p>下面的goto是不允许的，因为标签L跳过了变量v等声明和赋值，如果后面的代码访问v会有问题。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">goto</span> L  <span class="comment">// BAD</span></div><div class="line">	v :=<span class="number"> 3</span></div><div class="line">L:</div></pre></td></tr></table></figure>

<p>代码块外部的goto不能跳到一个代码块内部的标签上:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> n<span class="number">%2</span> ==<span class="number"> 1</span> {</div><div class="line">	<span class="keyword">goto</span> L1</div><div class="line">}</div><div class="line"><span class="keyword">for</span> n &gt;<span class="number"> 0</span> {</div><div class="line">	f()</div><div class="line">	n--</div><div class="line">L1:</div><div class="line">	f()</div><div class="line">	n--</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="defer_语句">defer 语句</h3>
<p>defer语句调用一个函数，这个函数将会在当前函数返回的时候才被调用，货站当前函数执行了一个return语句，或者发生panic。</p>
<p>无论是否有panic， defer函数都会调用。</p>
<p>函数可以是普通函数或者方法。调用内置函数有限制，限制条件和上面的表达式语句一样。</p>
<p>当defer语句执行时，函数的参数就会被计算一次，但是函数还没有被调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">i :=<span class="number"> 0</span></div><div class="line"></div><div class="line"><span class="keyword">defer</span> <span class="keyword">func</span>(i <span class="typename">int</span>) {</div><div class="line">	fmt.Printf(<span class="string">"defer: %d\n"</span>, i)</div><div class="line">}(i)</div><div class="line"></div><div class="line">i =<span class="number"> 50</span></div><div class="line"></div><div class="line"><span class="keyword">defer</span> <span class="keyword">func</span>(i <span class="typename">int</span>) {</div><div class="line">	fmt.Printf(<span class="string">"defer: %d\n"</span>, i) <span class="comment">//50</span></div><div class="line">}(i)</div><div class="line"></div><div class="line">i =<span class="number"> 100</span></div></pre></td></tr></table></figure>

<p>当一个函数中有多个defer语句时，最后的defer语句中函数最先被执行，也就是defer函数的执行是和它的定义成反序。比如上面的代码先输出50,再输出0.</p>
<p>defer语句中函数也可以有返回值，但是返回值会被忽略。</p>
<p>defer语句中如果定义了一个函数字面量(匿名函数)，而且函数中对外部的函数返回参数有所修改的话，修改结果会生效，比如下面的结果，虽然函数最后一个语句返回0,但是defer函数又修改了result的结果，所以f的最终结果为1。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// f 返回 1</span></div><div class="line"><span class="keyword">func</span> f() (result <span class="typename">int</span>) {</div><div class="line">	<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">		result++</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span><span class="number"> 0</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>defer语句虽然挺有用处，但是也需要注意它的函数会被推迟到函数返回的时候才会执行。如果defer函数中有对共享资源的占用的释放，比如锁、文件、连接等，等到函数返回才释放会影响程序的性能，所以对资源能今早释放则今早释放，未必非得放在defer函数中释放。</p>
<h3 id="go_语句">go 语句</h3>
<p>go语句将一个函数调用在一个新的goroutine中独立执行。</p>
<p>goroutine是值得仔细介绍的内容，而且goroutine 调度也非常的有趣，这会在下一章中独立介绍。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本章介绍Go语言的各种语句。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入Go语言 - 6]]></title>
    <link href="http://colobu.com/2016/06/21/dive-into-go-6/"/>
    <id>http://colobu.com/2016/06/21/dive-into-go-6/</id>
    <published>2016-06-21T09:25:44.000Z</published>
    <updated>2016-07-06T05:31:43.000Z</updated>
    <content type="html"><![CDATA[<p>本文介绍 类型转换(Conversion)、类型断言(type assertion) 和类型切换（type switch)。</p>
<p>这三个概念类似但是又完全不同。</p>
<a id="more"></a>
<h3 id="类型转换_Conversion">类型转换 Conversion</h3>
<p>将一个值x转换成特定类型T,格式为 <code>T(x)</code>,非常的简单，类型加小括号即可。</p>
<p>如果类型T以 *、&lt;-、func(不带结果列表)，未避免造成歧义，需要将类型括号包裹起来： <code>(T)(x)</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">*Point(p)        <span class="comment">// same as *(Point(p))</span></div><div class="line">(*Point)(p)      <span class="comment">// p is converted to *Point</span></div><div class="line">&lt;-<span class="keyword">chan</span> <span class="typename">int</span>(c)    <span class="comment">// same as &lt;-(chan int(c))</span></div><div class="line">(&lt;-<span class="keyword">chan</span> <span class="typename">int</span>)(c)  <span class="comment">// c is converted to &lt;-chan int</span></div><div class="line"><span class="keyword">func</span>()(x)        <span class="comment">// function signature func() x</span></div><div class="line">(<span class="keyword">func</span>())(x)      <span class="comment">// x is converted to func()</span></div><div class="line">(<span class="keyword">func</span>() <span class="typename">int</span>)(x)  <span class="comment">// x is converted to func() int</span></div><div class="line"><span class="keyword">func</span>() <span class="typename">int</span>(x)    <span class="comment">// x is converted to func() int (unambiguous)</span></div></pre></td></tr></table></figure>

<p>并不是任意的值都可以转换成类型T, 它需要遵循一定的规则，下面一一道来。</p>
<p>对于一个常量值x, 如果能转换成T类型的值，它需要满足下面的条件之一:</p>
<h4 id="转换常量值">转换常量值</h4>
<ul>
<li>x 可以表达为T的值</li>
<li>x 是浮点数值， T是浮点类型。 x 使用 IEEE 754 round-to-even 规则 且 IEEE -0.0 会进一步舍入到无符号的 0.0， 经过舍入后的x可以表示为T。这一条主要约束浮点数取整的规则，并不是完全按照四舍五入规则计算的。</li>
<li>x是一个整数而T是字符串类型</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="typename">uint</span>(<span class="constant">iota</span>)               <span class="comment">// iota value of type uint</span></div><div class="line"><span class="typename">float32</span><span class="number">(2.718281828</span>)     <span class="comment">// 2.718281828 of type float32</span></div><div class="line"><span class="typename">complex128</span><span class="number">(1</span>)            <span class="comment">// 1.0 + 0.0i of type complex128</span></div><div class="line"><span class="typename">float32</span><span class="number">(0.49999999</span>)      <span class="comment">// 0.5 of type float32</span></div><div class="line"><span class="typename">float64</span><span class="number">(-1e-1000</span>)        <span class="comment">// 0.0 of type float64</span></div><div class="line"><span class="typename">string</span>(<span class="string">'x'</span>)              <span class="comment">// "x" of type string</span></div><div class="line"><span class="typename">string</span><span class="number">(0</span>x266c)           <span class="comment">// "♬" of type string</span></div><div class="line">MyString(<span class="string">"foo"</span> + <span class="string">"bar"</span>)  <span class="comment">// "foobar" of type MyString</span></div><div class="line"><span class="typename">string</span>([]<span class="typename">byte</span>{<span class="string">'a'</span>})      <span class="comment">// not a constant: []byte{'a'} is not a constant</span></div><div class="line">(*<span class="typename">int</span>)(<span class="constant">nil</span>)              <span class="comment">// not a constant: nil is not a constant, *int is not a boolean, numeric, or string type</span></div><div class="line"><span class="typename">int</span><span class="number">(1.2</span>)                 <span class="comment">// illegal: 1.2 cannot be represented as an int</span></div><div class="line"><span class="typename">string</span><span class="number">(65.0</span>)             <span class="comment">// illegal: 65.0 is not an integer constant</span></div></pre></td></tr></table></figure>

<h4 id="转换变量值">转换变量值</h4>
<p>对于一个常量值x, 如果能转换成T类型的值，它需要满足下面的条件之一:</p>
<ul>
<li>x可以<a href="https://golang.org/ref/spec#Assignability" target="_blank" rel="external">赋值</a>给 T</li>
<li>x的类型和T的底层类型 类型一致</li>
<li>x类型和T 都是未命名的指针类型，它们的指针指向的对象类型 类型一致</li>
<li>x的类型和T都是整数或者浮点数</li>
<li>x的类型和T都是复数</li>
<li>x是整数、slice of byte、slice of rune, T是字符串类型</li>
<li>x是字符串， T是slice of byte 或者slice of rune</li>
</ul>
<p>数值类型和字符串之间的转换可能会改变x的呈现并且会带来运行时的花费。<br>其它的转换只是改变x的类型，不会改变x的呈现。</p>
<p>并没有直接整数和指针之间的转换。但是在前面的章节中也举例了，指针可以通过曲折的方式转换成整数，<br>它是通过包<code>unsafe</code>实现的， 甚至于你通过这种方式还可以访问struct未导出的字段。</p>
<p>类型不一致的两个变量不能赋值, 并且也没有什么强制类型转换的概念：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i1 <span class="typename">int8</span> =<span class="number"> 10</span></div><div class="line"><span class="keyword">var</span> i2 <span class="typename">uint8</span> = i1 <span class="comment">//错误</span></div><div class="line"><span class="keyword">var</span> i3 <span class="typename">uint8</span> = (<span class="typename">uint8</span>)i1 <span class="comment">//错误</span></div></pre></td></tr></table></figure>

<p>比如在类型那一章讲的例子，也是通过这种类型转换实现的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">x := [...]<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>,<span class="number"> 4</span>,<span class="number"> 5</span>}</div><div class="line">p := &x<span class="number">[0</span>]</div><div class="line"><span class="comment">//p = p + 1</span></div><div class="line">index2Pointer := unsafe.Pointer(<span class="typename">uintptr</span>(unsafe.Pointer(p)) + unsafe.Sizeof(x<span class="number">[0</span>]))</div><div class="line">p = (*<span class="typename">int</span>)(index2Pointer) <span class="comment">//x[1]</span></div><div class="line">fmt.Printf(<span class="string">"%d\n"</span>, *p)    <span class="comment">//2</span></div></pre></td></tr></table></figure>

<h3 id="类型转换实践">类型转换实践</h3>
<p>这一节介绍常见类型一致的转换。</p>
<h4 id="数值类型之间的转换">数值类型之间的转换</h4>
<p>非常量的数值之间的转换遵循下面三条原则:<br>1、整数之间的转换时，如果值是有符号的整数，它的符号位会扩展无限大，否则零扩展，然后它会被删减以适合结果类型。怎么理解，看例子。<br>对于无符号数v: <code>v := uint16(0x10F0)</code>,如果进行转换<code>uint32(int8(v))</code>,可以看到它的结果是<code>0xFFFFFFF0</code>，不会有溢出指示或者错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">v1 := <span class="typename">uint16</span><span class="number">(0</span>x10F0)</div><div class="line">fmt.Printf(<span class="string">"%d=%b\n"</span>, v1, v1) <span class="comment">//4336=1000011110000</span></div><div class="line"></div><div class="line">v2 := <span class="typename">int8</span>(v1)</div><div class="line">fmt.Printf(<span class="string">"%d=%b\n"</span>, v2, v2) <span class="comment">//-16=-10000</span></div><div class="line"></div><div class="line">v3 := <span class="typename">uint16</span>(v2)</div><div class="line">fmt.Printf(<span class="string">"%d=%b\n"</span>, v3, v3) <span class="comment">//65520=1111111111110000</span></div><div class="line"></div><div class="line">v4 := <span class="typename">int16</span>(v2)</div><div class="line">fmt.Printf(<span class="string">"%d=%b\n"</span>, v4, v4) <span class="comment">//-16=-10000</span></div></pre></td></tr></table></figure>

<p>介绍一下。 对于v1,它是一个无符号的整数， 要把它转为有符号的int8，那么我们只看v1的后8位:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1111 0000</div></pre></td></tr></table></figure>

<p>不幸的是，这个8位的最高位是1,我们会把它作为符号位，所以v2是个负数，那么<code>11110000</code>就是这个负数的补码，<br>那么它的原码是多少呢，计算补码的补码就是负数的原码:<code>1001 0000</code>,所以它是-16。如果最高位是0，简单了，本身就是它的原码。</p>
<p>再看v2转v3， 也就是有符号整数转无符号整数。v2是负数，内部表示为<code>11110000</code>,因为要扩展为16位，将符号位1扩展到最高位<code>1111 1111 1111 0000</code>,因为它是无符号整数，所以这个值整数的值65520。</p>
<p>你可以把v1值的值改为0xff60看看输出是什么？此时转换不会符号位为负数的情况。</p>
<blockquote>
<p>补码（two&#39;s complement) 指的是正数=原码，负数=反码加一<br>反码（ones&#39; complement) 指的就是通常所指的反码。<br>对一个整数的补码再求补码，等于该整数自身。<br>补码的正零与负零表示方法相同。</p>
</blockquote>
<p>2、浮点数转换成整数时，小数部分被丢弃,也就是朝0方向舍入。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> v1 <span class="typename">float32</span> =<span class="number"> 0.999999</span></div><div class="line">fmt.Println(<span class="typename">int</span>(v1))</div><div class="line">v1 =<span class="number"> -0.999999</span></div><div class="line">fmt.Println(<span class="typename">int</span>(v1))</div></pre></td></tr></table></figure>

<p>3、当转换整数或者浮点数到浮点数的时候，或者一个复数到另一个复数， 结果值会被舍入到目标类型的精度。例如类型为float32的变量x可以通过附加的精度超过标准的IEEE-754 32-bit数， 但是float32(x)代表x的值舍入到 IEEE-754 32 bit的精度。类似地， x + 0.1 可以使用超过32 bit的精度，但是float32(x + 0.1) 肯定是32 bit的精度。</p>
<blockquote>
<p>the value of a variable x of type float32 may be stored using additional precision beyond that of an IEEE-754 32-bit number, but float32(x) represents the result of rounding x&#39;s value to 32-bit precision. Similarly, x + 0.1 may use more than 32 bits of precision, but float32(x + 0.1) does not.</p>
</blockquote>
<p>关于浮点数格式IEEE-754, 随便一本计算机原理的教材中都会介绍，网上也有无数的文章介绍，它由三个域组成，float32中分别占1位、8位、和 23位,本文中就不详细介绍了。<br><img src="float32.png" alt="float32"></p>
<h4 id="整数和bool之间的转换">整数和bool之间的转换</h4>
<p>虽然有人提议实现快速的整数和bool之间的转换，但是目前看起来还没有实现，所以下面的语句是不对的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">i1 :=<span class="number"> 1</span></div><div class="line">i2 :=<span class="number"> 0</span></div><div class="line">fmt.Printf(<span class="string">"%t %t\n"</span>, <span class="typename">bool</span>(i1), <span class="typename">bool</span>(i2))</div></pre></td></tr></table></figure>

<p>但是你完全可以通过其它方式实现， 比如判断语句 <code>n &gt; 0</code>, 或者利用一个定义好的表(map,数组等)进行查表转换。</p>
<p>参考</p>
<ul>
<li><a href="https://github.com/golang/go/issues/6011" target="_blank" rel="external">https://github.com/golang/go/issues/6011</a></li>
<li><a href="https://github.com/golang/go/issues/7657" target="_blank" rel="external">https://github.com/golang/go/issues/7657</a></li>
</ul>
<h4 id="基于字节的字符串的转换">基于字节的字符串的转换</h4>
<p>字符串代表一串字节流，所以很容易的和slice of byte, slice of rune进行转换。<br>1、无符号整数或者有符号整数通过它对应的UTF-8编码转换成字符串。合法的Unicode code之外的值都被转换成<code>\uFFFD</code>。这里的整数也包含rune.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="typename">string</span>(<span class="string">'a'</span>)       <span class="comment">// "a"</span></div><div class="line"><span class="typename">string</span><span class="number">(-1</span>)        <span class="comment">// "\ufffd" == "\xef\xbf\xbd"</span></div><div class="line"><span class="typename">string</span><span class="number">(0</span>xf8)      <span class="comment">// "\u00f8" == "ø" == "\xc3\xb8"</span></div><div class="line"><span class="keyword">type</span> MyString <span class="typename">string</span></div><div class="line">MyString<span class="number">(0</span>x65e5)  <span class="comment">// "\u65e5" == "日" == "\xe6\x97\xa5"</span></div></pre></td></tr></table></figure>

<p>2、字节slice根据UTF-8编码产生字符串</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="typename">string</span>([]<span class="typename">byte</span>{<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'\xc3'</span>, <span class="string">'\xb8'</span>})   <span class="comment">// "hellø"</span></div><div class="line"><span class="typename">string</span>([]<span class="typename">byte</span>{})                                     <span class="comment">// ""</span></div><div class="line"><span class="typename">string</span>([]<span class="typename">byte</span>(<span class="constant">nil</span>))                                  <span class="comment">// ""</span></div></pre></td></tr></table></figure>

<p>3、将rune slice转换成字符串相当于将rune连接起来</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="typename">string</span>([]<span class="typename">rune</span><span class="number">{0</span>x9E1F,<span class="number"> 0</span>x7A9D})   <span class="comment">// "\u9e1f\u7a9d" == "鸟窝"</span></div><div class="line"><span class="typename">string</span>([]<span class="typename">rune</span>{})                         <span class="comment">// ""</span></div><div class="line"><span class="typename">string</span>([]<span class="typename">rune</span>(<span class="constant">nil</span>))                      <span class="comment">// ""</span></div></pre></td></tr></table></figure>

<p>4、将字符串转为byte slice会将字符串的字节流复制到一个byte slice</p>
<p>5、将一个字符串转为rune slice会将产生一个新的rune slice,包含字符串中每个rune</p>
<h4 id="字符串和基本类型之间的转换">字符串和基本类型之间的转换</h4>
<p>包strconv提供了字符串和基本数据类型的转换。上面我们提到了字符串和整数之间的转换，但是有时候我们需要的是将 12转换成字符串 &quot;12&quot;，或者从字符串中解析处一个整数，这个时候就可以使用这个包。</p>
<p>首先它提供了一组往byte slice增加基本类型元素的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> AppendBool(dst []<span class="typename">byte</span>, b <span class="typename">bool</span>) []<span class="typename">byte</span></div><div class="line"><span class="keyword">func</span> AppendFloat(dst []<span class="typename">byte</span>, f <span class="typename">float64</span>, fmt <span class="typename">byte</span>, prec, bitSize <span class="typename">int</span>) []<span class="typename">byte</span></div><div class="line"><span class="keyword">func</span> AppendInt(dst []<span class="typename">byte</span>, i <span class="typename">int64</span>, base <span class="typename">int</span>) []<span class="typename">byte</span></div><div class="line"><span class="keyword">func</span> AppendQuote(dst []<span class="typename">byte</span>, s <span class="typename">string</span>) []<span class="typename">byte</span></div><div class="line"><span class="keyword">func</span> AppendQuoteRune(dst []<span class="typename">byte</span>, r <span class="typename">rune</span>) []<span class="typename">byte</span></div><div class="line"><span class="keyword">func</span> AppendQuoteRuneToASCII(dst []<span class="typename">byte</span>, r <span class="typename">rune</span>) []<span class="typename">byte</span></div><div class="line"><span class="keyword">func</span> AppendQuoteRuneToGraphic(dst []<span class="typename">byte</span>, r <span class="typename">rune</span>) []<span class="typename">byte</span></div><div class="line"><span class="keyword">func</span> AppendQuoteToASCII(dst []<span class="typename">byte</span>, s <span class="typename">string</span>) []<span class="typename">byte</span></div><div class="line"><span class="keyword">func</span> AppendQuoteToGraphic(dst []<span class="typename">byte</span>, s <span class="typename">string</span>) []<span class="typename">byte</span></div><div class="line"><span class="keyword">func</span> AppendUint(dst []<span class="typename">byte</span>, i <span class="typename">uint64</span>, base <span class="typename">int</span>) []<span class="typename">byte</span></div></pre></td></tr></table></figure>

<p>一组从字符串中解析出基本类型的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> ParseBool(str <span class="typename">string</span>) (value <span class="typename">bool</span>, err error)</div><div class="line"><span class="keyword">func</span> ParseFloat(s <span class="typename">string</span>, bitSize <span class="typename">int</span>) (f <span class="typename">float64</span>, err error)</div><div class="line"><span class="keyword">func</span> ParseInt(s <span class="typename">string</span>, base <span class="typename">int</span>, bitSize <span class="typename">int</span>) (i <span class="typename">int64</span>, err error)</div><div class="line"><span class="keyword">func</span> ParseUint(s <span class="typename">string</span>, base <span class="typename">int</span>, bitSize <span class="typename">int</span>) (n <span class="typename">uint64</span>, err error)</div></pre></td></tr></table></figure>

<p>一组为字符串或者rune加引号和剥离引号的方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Quote(s <span class="typename">string</span>) <span class="typename">string</span></div><div class="line"><span class="keyword">func</span> QuoteRune(r <span class="typename">rune</span>) <span class="typename">string</span></div><div class="line"><span class="keyword">func</span> QuoteRuneToASCII(r <span class="typename">rune</span>) <span class="typename">string</span></div><div class="line"><span class="keyword">func</span> QuoteRuneToGraphic(r <span class="typename">rune</span>) <span class="typename">string</span></div><div class="line"><span class="keyword">func</span> QuoteToASCII(s <span class="typename">string</span>) <span class="typename">string</span></div><div class="line"><span class="keyword">func</span> QuoteToGraphic(s <span class="typename">string</span>) <span class="typename">string</span></div><div class="line"><span class="keyword">func</span> Unquote(s <span class="typename">string</span>) (t <span class="typename">string</span>, err error)</div><div class="line"><span class="keyword">func</span> UnquoteChar(s <span class="typename">string</span>, quote <span class="typename">byte</span>) (value <span class="typename">rune</span>, multibyte <span class="typename">bool</span>, tail <span class="typename">string</span>, err error)</div></pre></td></tr></table></figure>

<p>一组检查字符串或者rune为特定类型的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> CanBackquote(s <span class="typename">string</span>) <span class="typename">bool</span></div><div class="line"><span class="keyword">func</span> IsGraphic(r <span class="typename">rune</span>) <span class="typename">bool</span></div><div class="line"><span class="keyword">func</span> IsPrint(r <span class="typename">rune</span>) <span class="typename">bool</span></div></pre></td></tr></table></figure>

<p>一组格式化基本类型为字符串的方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> FormatBool(b <span class="typename">bool</span>) <span class="typename">string</span></div><div class="line"><span class="keyword">func</span> FormatFloat(f <span class="typename">float64</span>, fmt <span class="typename">byte</span>, prec, bitSize <span class="typename">int</span>) <span class="typename">string</span></div><div class="line"><span class="keyword">func</span> FormatInt(i <span class="typename">int64</span>, base <span class="typename">int</span>) <span class="typename">string</span></div><div class="line"><span class="keyword">func</span> FormatUint(i <span class="typename">uint64</span>, base <span class="typename">int</span>) <span class="typename">string</span></div></pre></td></tr></table></figure>

<p>重要的放在最后说，我们在编程中更多的用到的两个方法, 整数字面值和字符串之间的转换:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Atoi(s <span class="typename">string</span>) (i <span class="typename">int</span>, err error)</div><div class="line"><span class="keyword">func</span> Itoa(i <span class="typename">int</span>) <span class="typename">string</span></div></pre></td></tr></table></figure>

<p>参考</p>
<ul>
<li><a href="https://golang.org/pkg/strconv/" target="_blank" rel="external">https://golang.org/pkg/strconv/</a></li>
</ul>
<h4 id="字节slice和整数之间的转换">字节slice和整数之间的转换</h4>
<p>包 encoding/binary实现了数值和字节序列之间的转换，包含变长int的各种编解码。</p>
<p>Go中的数值类型都是固定长度的位数(int8, uint8, int16, float32, complex64)，所以组成这些数组的bit可以转换成各种字节slice。</p>
<p>变长int (varint)经常用于节省空间，比如一个， Go实现的varint规范可以参考<a href="https://developers.google.com/protocol-buffers/docs/encoding" target="_blank" rel="external">proto-buff的实现</a>。很多编解码库中都使用了变长的int，这样对于大量的小数字我们可以用更少的字节来表示，对于网络传输来说很有好处。</p>
<p>这个包经常用在网络传输的序列化和反序列中。</p>
<p>另外一个值得注意的是数值是由多个字节组成的，这就涉及到字节序的问题，你必须指定使用小端序或大端序。</p>
<p>首先看一下定长的数值的转换，主要是<code>Read</code>和<code>Write</code>两个方法，底层还是通过移位操作实现的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Read(r io.Reader, order ByteOrder, data <span class="keyword">interface</span>{}) error</div><div class="line"><span class="keyword">func</span> Write(w io.Writer, order ByteOrder, data <span class="keyword">interface</span>{}) error</div></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"bytes"</span></div><div class="line">	<span class="string">"encoding/binary"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	b := write()</div><div class="line">	read(b)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> write() []<span class="typename">byte</span> {</div><div class="line">	buf := <span class="built_in">new</span>(bytes.Buffer)</div><div class="line">	<span class="keyword">var</span> data = []<span class="keyword">interface</span>{}{</div><div class="line">		<span class="typename">uint16</span><span class="number">(61374</span>), <span class="comment">//efbe</span></div><div class="line">		<span class="typename">int8</span><span class="number">(-54</span>),     <span class="comment">//-36</span></div><div class="line">		<span class="typename">uint8</span><span class="number">(254</span>),    <span class="comment">//fe</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> data {</div><div class="line">		err := binary.Write(buf, binary.BigEndian, v)</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			fmt.Println(<span class="string">"binary.Write failed:"</span>, err)</div><div class="line">		}</div><div class="line">	}</div><div class="line">	fmt.Printf(<span class="string">"%x\n"</span>, buf.Bytes()) <span class="comment">//efbecafe</span></div><div class="line">	<span class="keyword">return</span> buf.Bytes()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> read(b []<span class="typename">byte</span>) {</div><div class="line">	<span class="keyword">var</span> i1 <span class="typename">uint16</span></div><div class="line">	<span class="keyword">var</span> i2 <span class="typename">int8</span></div><div class="line">	<span class="keyword">var</span> i3 <span class="typename">uint8</span></div><div class="line"></div><div class="line">	buf := bytes.NewReader(b)</div><div class="line">	err := binary.Read(buf, binary.BigEndian, &i1)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		fmt.Println(<span class="string">"binary.Read failed:"</span>, err)</div><div class="line">	}</div><div class="line">	err = binary.Read(buf, binary.BigEndian, &i2)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		fmt.Println(<span class="string">"binary.Read failed:"</span>, err)</div><div class="line">	}</div><div class="line">	err = binary.Read(buf, binary.BigEndian, &i3)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		fmt.Println(<span class="string">"binary.Read failed:"</span>, err)</div><div class="line">	}</div><div class="line"></div><div class="line">	fmt.Println(i1, i2, i3) <span class="comment">//61374 -54 254</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>一种不通用的适合特定类型的转换也可以使用下面的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> readInt32(b []<span class="typename">byte</span>) <span class="typename">int32</span> {</div><div class="line">    <span class="comment">// equivalnt of return int32(binary.LittleEndian.Uint32(b))</span></div><div class="line">    <span class="keyword">return</span> <span class="typename">int32</span>(<span class="typename">uint32</span>(b<span class="number">[0</span>]) | <span class="typename">uint32</span>(b<span class="number">[1</span>])&lt;<span class="number">&lt;8</span> | <span class="typename">uint32</span>(b<span class="number">[2</span>])&lt;<span class="number">&lt;16</span> | <span class="typename">uint32</span>(b<span class="number">[3</span>])&lt;<span class="number">&lt;24</span>)</div><div class="line">}</div><div class="line"><span class="comment">//或者</span></div><div class="line"><span class="keyword">func</span> ReadInt32Unsafe(b []<span class="typename">byte</span>) <span class="typename">int32</span> {</div><div class="line">    <span class="keyword">return</span> *(*<span class="typename">int32</span>)(unsafe.Pointer(&b<span class="number">[0</span>]))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>变长int的操作函数:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> PutUvarint(buf []<span class="typename">byte</span>, x <span class="typename">uint64</span>) <span class="typename">int</span></div><div class="line"><span class="keyword">func</span> PutVarint(buf []<span class="typename">byte</span>, x <span class="typename">int64</span>) <span class="typename">int</span></div><div class="line"><span class="keyword">func</span> Uvarint(buf []<span class="typename">byte</span>) (<span class="typename">uint64</span>, <span class="typename">int</span>)</div><div class="line"><span class="keyword">func</span> Varint(buf []<span class="typename">byte</span>) (<span class="typename">int64</span>, <span class="typename">int</span>)</div><div class="line"><span class="keyword">func</span> ReadUvarint(r io.ByteReader) (<span class="typename">uint64</span>, error)</div><div class="line"><span class="keyword">func</span> ReadVarint(r io.ByteReader) (<span class="typename">int64</span>, error)</div></pre></td></tr></table></figure>

<p>以及一个对象被转换成多少字节的方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Size(v <span class="keyword">interface</span>{}) <span class="typename">int</span></div></pre></td></tr></table></figure>

<p>参考</p>
<ul>
<li><a href="https://golang.org/pkg/encoding/binary/" target="_blank" rel="external">https://golang.org/pkg/encoding/binary/</a></li>
<li><a href="https://zh.wikipedia.org/wiki/字节序#.E5.AD.97.E8.8A.82.E9.A1.BA.E5.BA.8F" target="_blank" rel="external">https://zh.wikipedia.org/wiki/字节序#.E5.AD.97.E8.8A.82.E9.A1.BA.E5.BA.8F</a></li>
<li><a href="http://codereview.stackexchange.com/questions/15945/effectively-convert-little-endian-byte-slice-to-int32" target="_blank" rel="external">http://codereview.stackexchange.com/questions/15945/effectively-convert-little-endian-byte-slice-to-int32</a></li>
</ul>
<h4 id="数组和slice之间的转换">数组和slice之间的转换</h4>
<p>数组转换成slice很简单，前面讲到了，利用索引运算：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a[low:high]</div><div class="line">a[low:high:max]</div></pre></td></tr></table></figure>

<p>而slice转数组，我们可以好好分析一下。</p>
<p>slice的底层实现是数组，所以有一个&quot;hack&quot;方法，将slice的底层数组返回:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"reflect"</span></div><div class="line">    <span class="string">"unsafe"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> SIZEOF_INT32 =<span class="number"> 4</span> <span class="comment">// bytes</span></div><div class="line"></div><div class="line"><span class="comment">// Get the slice header</span></div><div class="line">header := *(*reflect.SliceHeader)(unsafe.Pointer(&raw))</div><div class="line"></div><div class="line"><span class="comment">// The length and capacity of the slice are different.</span></div><div class="line">header.Len /= SIZEOF_INT32</div><div class="line">header.Cap /= SIZEOF_INT32</div><div class="line"></div><div class="line"><span class="comment">// Convert slice header to an []int32</span></div><div class="line">data := *(*[]<span class="typename">int32</span>)(unsafe.Pointer(&header))</div></pre></td></tr></table></figure>

<p>安全的方式是生成数组然后依次赋值，注意copy是不行的，因为copy的参数必须都是slice:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"encoding/binary"</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> SIZEOF_INT32 =<span class="number"> 4</span> <span class="comment">// bytes</span></div><div class="line"></div><div class="line">data := <span class="built_in">make</span>([]<span class="typename">int32</span>, <span class="built_in">len</span>(raw)/SIZEOF_INT32)</div><div class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> data {</div><div class="line">    <span class="comment">// assuming little endian</span></div><div class="line">    data[i] = <span class="typename">int32</span>(binary.LittleEndian.Uint32(raw[i*SIZEOF_INT32:(i<span class="number">+1</span>)*SIZEOF_INT32]))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>参考</p>
<ul>
<li><a href="http://stackoverflow.com/questions/19073769/in-golang-how-do-you-convert-a-slice-into-an-array" target="_blank" rel="external">http://stackoverflow.com/questions/19073769/in-golang-how-do-you-convert-a-slice-into-an-array</a></li>
<li><a href="http://stackoverflow.com/questions/11924196/convert-between-slices-of-different-types" target="_blank" rel="external">http://stackoverflow.com/questions/11924196/convert-between-slices-of-different-types</a></li>
<li><a href="https://groups.google.com/forum/#!topic/golang-nuts/yNis7bQG_rY" target="_blank" rel="external">https://groups.google.com/forum/#!topic/golang-nuts/yNis7bQG_rY</a></li>
</ul>
<h4 id="struct和字符串之间的转换">struct和字符串之间的转换</h4>
<p>struct类型的值和字符串之间的转换我们称之为marshal和unmarshal。<br>有非常多的库可以做这个事情，比如gob, encoding/json等。</p>
<p>Go序列化框架的性能比较可以参照我的一个开源项目: <a href="https://github.com/smallnest/gosercomp" target="_blank" rel="external">gosercomp</a>。</p>
<h4 id="Java字符串和Go字符串之间的转换">Java字符串和Go字符串之间的转换</h4>
<p>Java字符串在内部是以UTF-16编码方式存在的，每个字符包含两个字节。而Go字符串在内部是以UTF-8格式存在的，每个字符串占用的字节数可能不同。</p>
<p>可以使用<a href="golang.org/x/text/encoding/unicode">unicode</a>包进行转换，或者使用<a href="https://golang.org/pkg/unicode/utf16" target="_blank" rel="external">unicode/utf16</a></p>
<p>参考</p>
<ul>
<li><a href="https://jannewmarch.gitbooks.io/network-programming-with-go-golang-/content/encoding/utf-16_and_go.html" target="_blank" rel="external">https://jannewmarch.gitbooks.io/network-programming-with-go-golang-/content/encoding/utf-16_and_go.html</a></li>
</ul>
<h3 id="类型断言_type_assertion">类型断言 type assertion</h3>
<p>和上节的类型转换不同，类型断言是将接口类型的值x，转换成类型T。</p>
<p>格式为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">x.(T)</div><div class="line">v := x.(T)</div><div class="line">v, ok := x.(T)</div></pre></td></tr></table></figure>

<p>类型断言的必要条件是x是接口类型,非接口类型的x不能做类型断言:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i <span class="typename">int</span> =<span class="number"> 10</span></div><div class="line">v := i.(<span class="typename">int</span>) <span class="comment">//错误</span></div></pre></td></tr></table></figure>

<p>T可以是非接口类型，如果想断言合法，则T应该实现x的接口。</p>
<p>T也可以是接口，则x的动态类型也应该实现接口T。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>{} =<span class="number"> 7</span>  <span class="comment">// x 的动态类型为int， 值为 7</span></div><div class="line">i := x.(<span class="typename">int</span>)           <span class="comment">// i 的类型为 int， 值为 7</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> { m() }</div><div class="line"><span class="keyword">var</span> y I</div><div class="line">s := y.(<span class="typename">string</span>)        <span class="comment">// 非法: string 没有实现接口 I (missing method m)</span></div><div class="line">r := y.(io.Reader)     <span class="comment">// y如果实现了接口io.Reader和I的情况下，  r的类型则为io.Reader</span></div></pre></td></tr></table></figure>

<p>类型断言如果非法，运行时时候就会出现 impossible type assertion panic，为了避免这种情况，可以使用下面的语法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">v, ok = x.(T)</div><div class="line">v, ok := x.(T)</div><div class="line"><span class="keyword">var</span> v, ok = x.(T)</div></pre></td></tr></table></figure>

<p>ok代表类型断言是否合法，如果非法ok =false,v为T的零值，这样就不会出现运行时panic了。</p>
<p>希望你能记住，类型转换和类型断言完全是两个概念。</p>
<h3 id="类型切换_type_switch">类型切换 type switch</h3>
<p>类型切换(暂且这么翻译吧，英语更准确)用来比较类型而不是对值进行比较。</p>
<p>switch语句虽然在下一章中去讲，但是对于读者来说，多少会一种或者几种常用的编程语言，switch是一个条件语句，它可以判断某个值是否匹配某个case clause。但是对于type switch，它检查的是值x的类型T是否匹配某个类型。</p>
<p>格式如下，类型类型断言，但是括号内的不是某个具体的类型，而是单词<code>type</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> x.(<span class="keyword">type</span>) {</div><div class="line"><span class="comment">// cases</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>type switch语句中可以有一个简写的变量声明，这种情况下，等价于这个变量声明在每个case clause隐式代码块的开始位置。如果case clause只列出了一个类型，则变量的类型就是这个类型，否则就是原始值的类型。</p>
<p>假设下面的例子中x的类型为x interface{}</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> i := x.(<span class="keyword">type</span>) {</div><div class="line"><span class="keyword">case</span> <span class="constant">nil</span>:</div><div class="line">  printString(<span class="string">"x is nil"</span>) <span class="comment">// i的类型是 x的类型 (interface{})</span></div><div class="line"><span class="keyword">case</span> <span class="typename">int</span>:</div><div class="line">  printInt(i) <span class="comment">// i的类型 int</span></div><div class="line"><span class="keyword">case</span> <span class="typename">float64</span>:</div><div class="line">  printFloat64(i) <span class="comment">// i的类型是 float64</span></div><div class="line"><span class="keyword">case</span> <span class="keyword">func</span>(<span class="typename">int</span>) <span class="typename">float64</span>:</div><div class="line">  printFunction(i) <span class="comment">// i的类型是 func(int) float64</span></div><div class="line"><span class="keyword">case</span> <span class="typename">bool</span>, <span class="typename">string</span>:</div><div class="line">  printString(<span class="string">"type is bool or string"</span>) <span class="comment">// i的类型是 x (interface{})</span></div><div class="line"><span class="keyword">default</span>:</div><div class="line">  printString(<span class="string">"don't know the type"</span>) <span class="comment">// i的类型是 x的类型 (interface{})</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>也许你已经看到上面的例子中有一个case clause中的类型是nil,它用来匹配x为nil的interface{}的情况。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文介绍 类型转换(Conversion)、类型断言(type assertion) 和类型切换（type switch)。</p>
<p>这三个概念类似但是又完全不同。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入Go语言 - 5]]></title>
    <link href="http://colobu.com/2016/06/20/dive-into-go-5/"/>
    <id>http://colobu.com/2016/06/20/dive-into-go-5/</id>
    <published>2016-06-20T08:00:41.000Z</published>
    <updated>2016-07-06T05:31:14.000Z</updated>
    <content type="html"><![CDATA[<p>本文介绍Go语言的表达式。</p>
<p>表达式代表一个值的计算， 计算通过运算符和函数应用在操作数上(operand)。<br><a id="more"></a></p>
<p>操作数代表表达式中的基本值。它可以字面量，标识符。 标识符表示常量、变量、函数、方法表达式、或者一个括号表达式。</p>
<p>空标识符“_”只能出现在赋值语句的左边。</p>
<p>包代码块中定义的标识符通过 <code>package.identifier</code>访问。</p>
<p>表达式的形式有多种，可以参看官方文档: <a href="https://golang.org/ref/spec#Primary_expressions" target="_blank" rel="external">Primary expressions</a>。</p>
<p>以下都是合法的表达式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">x<span class="number"></span></div><div class="line">2</div><div class="line">(s + <span class="string">".txt"</span>)</div><div class="line">f<span class="number">(3.1415</span>, <span class="constant">true</span>)</div><div class="line">Point<span class="number">{1</span>,<span class="number"> 2</span>}</div><div class="line">m[<span class="string">"foo"</span>]</div><div class="line">s[i : j +<span class="number"> 1</span>]</div><div class="line">obj.color</div><div class="line">f.p[i].x()</div><div class="line">i.(<span class="typename">int</span>)</div></pre></td></tr></table></figure>

<p>重点介绍Go语言规范中的以下表达式。</p>
<h3 id="Selector">Selector</h3>
<p>假定x不是包名，selector表达式表示如下: <code>x.f</code>。<br>它表示f是x (或者*x)的字段或者方法。其中标识符f称为selector。</p>
<p>selector f可以是类型T的字段或者方法，也可以是T的匿名嵌套字段的字段和方法。 可以递归地通过匿名字段进行查找，匿名字段递归查找f的数量称之为它在T中的深度。T中声明的字段和方法的深度为0。</p>
<p>selector有以下特性：<br>1、对于类型为 <code>T</code> 或 <code>*T</code>的值x, 当 T 不是指针类型或者接口类型时，x.f 代表 T 的 最小深度的字段或者方法 f。 如果同一深度有多个f， 那么selector表达式就是错误的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> S1 <span class="keyword">struct</span> {</div><div class="line">}</div><div class="line"><span class="keyword">func</span> (s S1) Say() {</div><div class="line"></div><div class="line">}</div><div class="line"><span class="keyword">type</span> S2 <span class="keyword">struct</span> {</div><div class="line">}</div><div class="line"><span class="keyword">func</span> (s S2) Say() {</div><div class="line"></div><div class="line">}</div><div class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> {</div><div class="line">	S1</div><div class="line">	S2</div><div class="line">}</div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> s S</div><div class="line">	s.Say()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>2、对于类型为I的值x, 如果I是接口类型，那么 x.f 代表 x的动态类型的实际方法 f。 如果 I 接口的方法集中没有方法f, 则selector表达式非法。<br>3、一个特例。如果x的类型是一个命名的指针类型，并且(*x).f代表字段f(不是方法),可以简写为 x.f。<br>4、其它情况 x.f 都是非法的。<br>5、如果 x是一个指针类型，它的值是 nil。则 x.f 会导致运行时panic。<br>6、如果x的类型I是接口类型，并且值为 nil， 则x.f会导致运行时panic。</p>
<p>我们首先定义两个类型<code>T0</code>、<code>T1</code>,分别包含一个方法<code>M0</code>和<code>M1</code>，类型参数分别为<code>*T0</code>、<code>T1</code>。</p>
<p>然后定义一个类型<code>T2</code>，嵌入<code>T1</code>和<code>*T0</code>，还包含一个方法<code>M2</code>，类型参数为<code>*T2</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> T0 <span class="keyword">struct</span> {</div><div class="line">	x <span class="typename">int</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (*T0) M0() {}</div><div class="line"></div><div class="line"><span class="keyword">type</span> T1 <span class="keyword">struct</span> {</div><div class="line">	y <span class="typename">int</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (T1) M1() {}</div><div class="line"></div><div class="line"><span class="keyword">type</span> T2 <span class="keyword">struct</span> {</div><div class="line">	z <span class="typename">int</span></div><div class="line">	T1</div><div class="line">	*T0</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (*T2) M2() {}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Q *T2</div><div class="line"></div><div class="line"><span class="keyword">var</span> t T2 = T2{T1: T1{}, T0: &T0{}}</div><div class="line"><span class="keyword">var</span> p *T2 = &T2{T1: T1{}, T0: &T0{}}</div><div class="line"><span class="keyword">var</span> q Q = p</div></pre></td></tr></table></figure>

<p>则下面的表达式都是合法的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	_ = t.z <span class="comment">// t.z</span></div><div class="line">	_ = t.y <span class="comment">// t.T1.y</span></div><div class="line">	_ = t.x <span class="comment">// (*t.T0).x</span></div><div class="line"></div><div class="line">	_ = p.z <span class="comment">// (*p).z</span></div><div class="line">	_ = p.y <span class="comment">// (*p).T1.y</span></div><div class="line">	_ = p.x <span class="comment">// (*(*p).T0).x</span></div><div class="line"></div><div class="line">	_ = q.x <span class="comment">// (*(*q).T0).x        (*q).x is a valid field selector</span></div><div class="line"></div><div class="line">	p.M0() <span class="comment">// ((*p).T0).M0()      M0 expects *T0 receiver</span></div><div class="line">	p.M1() <span class="comment">// ((*p).T1).M1()      M1 expects T1 receiver</span></div><div class="line">	p.M2() <span class="comment">// p.M2()              M2 expects *T2 receiver</span></div><div class="line">	t.M2() <span class="comment">// (&t).M2()           M2 expects *T2 receiver, see section on Calls</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>但是下面的表达式非法(违反规则3)：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">q.M0()       <span class="comment">// (*q).M0 is valid but not a field selector</span></div></pre></td></tr></table></figure>

<h3 id="方法表达式">方法表达式</h3>
<p>如果M在类型T的方法集中，T.M可以当作一个普通的函数调用，它的第一个参数需要传入receiver的值。</p>
<p>考虑到下面的结构体S:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> {</div><div class="line">	Name <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s S) M1(i <span class="typename">int</span>) {</div><div class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, s)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s *S) M2(f <span class="typename">float32</span>) {</div><div class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, s)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>和变量 <code>var s = S{&quot;bird&quot;}</code>,下面的6组表达式都是等价的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">s.M1<span class="number">(1</span>)</div><div class="line">S.M1(s<span class="number">,1</span>)</div><div class="line">(S).M1(s<span class="number">,1</span>)</div><div class="line">f1 := S.M1;f1(s<span class="number">,1</span>)</div><div class="line">f2 := (S).M1;f2(s<span class="number">,1</span>)</div><div class="line">f3 := s.M1;f3<span class="number">(1</span>)</div></pre></td></tr></table></figure>

<p>类似地，<code>(*S).M2</code>也会产生下面的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span>(t *T, <span class="typename">float32</span>)</div></pre></td></tr></table></figure>

<p>对于receiver为value receiver的方法, <code>(*S).M1</code>还会产生下面的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span>(s *S, i <span class="typename">int</span>)</div></pre></td></tr></table></figure>

<p>注意这个方法会为传入的receiver创建一个值，这个方法不会覆盖传入的指针指向的值。</p>
<p>如果x的静态类型为T, M是T的方法集里面的一个方法。 则x.M称之为方法值(method value)。方法值是一个函数，参数和x.M的参数一样。T可以是接口类型或者非接口类型。</p>
<p>Go语言规定，一个指针可以调用value receiver的非接口方法：<code>pt.M1</code>等价于<code>(*pt).M1</code>。<br>而一个值可以调用pointer receiver的非接口方法:<code>s.M2</code>等价于<code>(&amp;s).M2</code>,它会把这个值的地址作为参数。</p>
<p>因此，对于非接口方法，不管它的reeiver是poiter还是value，值对象和指针对象都可以调用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> {</div><div class="line">	Name <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s S) M1() {</div><div class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, s)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s *S) M2() {</div><div class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, s)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> s1 = S{<span class="string">"bird"</span>}</div><div class="line">	<span class="keyword">var</span> s2 = &s1</div><div class="line"></div><div class="line">	s1.M1()</div><div class="line">	s1.M2()</div><div class="line">	s2.M1()</div><div class="line">	s2.M2()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>注意，前面已经讲到，通过指针调用value receiver的方法不会改变指针指向的对象的值，因为它会复制一份value,而不是把自己的value值传入方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> {</div><div class="line">	Name <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s S) M1() {</div><div class="line">	s.Name = <span class="string">"bird1"</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s *S) M2() {</div><div class="line">	s.Name = <span class="string">"bird2"</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> s1 = S{<span class="string">"bird"</span>}</div><div class="line">	<span class="keyword">var</span> s2 = &s1</div><div class="line">	s1.M2()</div><div class="line">	fmt.Printf(<span class="string">"%+v, %+v\n"</span>, s1, s2) <span class="comment">//{Name:bird2}, &{Name:bird2}</span></div><div class="line"></div><div class="line">	s1 = S{<span class="string">"bird"</span>}</div><div class="line">	s2 = &s1</div><div class="line">	s2.M1()</div><div class="line">	fmt.Printf(<span class="string">"%+v, %+v\n"</span>, s1, s2)<span class="comment">//{Name:bird}, &{Name:bird}</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>甚至，函数也可以有方法,比如常见的官方库中的<code>HandlerFunc</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> HandlerFunc <span class="keyword">func</span>(ResponseWriter, *Request)</div><div class="line"></div><div class="line"><span class="keyword">func</span> (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {</div><div class="line">	f(w, r)</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="索引表达式">索引表达式</h3>
<p>索引表达式<code>a[x]</code>可以用于数组、数组指针、slice、字符串和map。</p>
<p>对于非map的对象：</p>
<ul>
<li>索引值x必须是integer类型或者未声明类型的类型，并且 <code>0 &lt;= x &lt; len(a)</code></li>
<li>常数索引值必须非负，而且可以表现为int类型的值</li>
</ul>
<p>索引的以下内容你应该都很熟悉了，可以选择跳过去。</p>
<p>对于数组：</p>
<ul>
<li>索引不能越界</li>
<li>越界的话会发生运行时panic</li>
<li>a[x]是索引在x处的元素，索引值以0开始</li>
</ul>
<p>对于数组指针</p>
<ul>
<li>a[x] 是 (*a)[x]的简写</li>
</ul>
<p>对于slice类型S:</p>
<ul>
<li>x越界，运行时panic</li>
<li>a[x]是索引在x处的元素，索引值以0开始</li>
</ul>
<p>对于字符串类型：</p>
<ul>
<li>x不能越界</li>
<li>x越界，运行时panic</li>
<li>a[x]是索引在x处的非常量 byte值</li>
<li>不能给 a[x]赋值</li>
</ul>
<p>对于map类型：</p>
<ul>
<li>x必须可以赋值map的键类型，参照上一章的类型赋值规则</li>
<li>如果map包含键为x的entry,那么a[x]就是值对象</li>
<li>如果map是nil或者map不包含这个entry, a[x]是值类型的零值</li>
</ul>
<p>当然map类型还有一个特殊格式，就是可以同时返回x是否存在于map中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">v, ok = a[x]</div><div class="line">v, ok := a[x]</div><div class="line"><span class="keyword">var</span> v, ok = a[x]</div></pre></td></tr></table></figure>

<p>如果x存在于map中，则v返回它的值，ok 为 true,否则 ok 为 false。</p>
<h3 id="slice表达式">slice表达式</h3>
<p>字符串、数组、数组指针、slice可以通过下面的方式得到一个子字符串或者slice:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[low:high]</div></pre></td></tr></table></figure>

<p>当然其中<code>low</code>、<code>high</code>都可以忽略。默认low = 0, high = 操作数的最大长度。注意结果的范围是左闭右开的： a[low] &lt;= …… &lt; a[high],</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a<span class="number">[2</span>:]  <span class="comment">// same as a[2 : len(a)]</span></div><div class="line">a[<span class="number">:3</span>]  <span class="comment">// same as a[0 : 3]</span></div><div class="line">a[:]   <span class="comment">// same as a[0 : len(a)]</span></div></pre></td></tr></table></figure>

<p>对于数组、数组指针和slice (不包含字符串)，索引表达式还有下面的形式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[low : high : max]</div></pre></td></tr></table></figure>

<p>它和<code>a[low:high]</code>一样，产生同样的元素类型，同样长度和元素的slice,但是它会设置容量capacity,<br>产生的slice的容量为 <code>max-low</code>。在这个格式下，只有第一个索引low可以省略，默认为0。<br>索引的范围符合 <code>0 &lt;= low &lt;= high &lt;= max &lt;= cap(a)</code>。</p>
<h3 id="变参">变参</h3>
<p>对于函数和方法中的最后一个参数是变参p，类型是...T的情况，p的类型f等价于[]T。</p>
<p>如果没有实际参数传给变参，它的值是nil。</p>
<p>你可以讲一个slice传递给变参，如果想将slice的元素作为变参的各个值传递的话，可以在slice后面加...:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Greeting(prefix <span class="typename">string</span>, who ...<span class="typename">string</span>)</div><div class="line">Greeting(<span class="string">"nobody"</span>)</div><div class="line">Greeting(<span class="string">"hello:"</span>, <span class="string">"Joe"</span>, <span class="string">"Anna"</span>, <span class="string">"Eileen"</span>)</div><div class="line"></div><div class="line">s := []<span class="typename">string</span>{<span class="string">"James"</span>, <span class="string">"Jasmine"</span>}</div><div class="line">Greeting(<span class="string">"goodbye:"</span>, s...)</div></pre></td></tr></table></figure>

<p>加不加...是不一样的，比如下面的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> foo(p ...<span class="keyword">interface</span>{}) {</div><div class="line">	fmt.Println(<span class="built_in">len</span>(p))</div><div class="line">}</div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	s := []<span class="keyword">interface</span>{}<span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>,<span class="number"> 4</span>,<span class="number"> 5</span>}</div><div class="line"></div><div class="line">	foo(s)    <span class="comment">//1</span></div><div class="line">	foo(s...) <span class="comment">//5</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="运算符">运算符</h3>
<p>本节重要用于总结。</p>
<p>除了为移位运算符， 如果一个操作数是有类型的，另一个不是，则另一个会被转换成相同的类型。</p>
<p>移位操作的右边的运算符是无符号整数，或者可以转换成无符合整数的未声明的常量。</p>
<h4 id="运算符优先级">运算符优先级</h4>
<p><code>++</code>、<code>--</code>是语句，不是表达式， *p++等同于(*p)++。</p>
<p>运算符有5层优先级：</p>
<pre class="highlight">
Precedence    Operator
    5             *  /  %  <<  >>  &  &^
    4             +  -  |  ^
    3             ==  !=  <  <=>  >=
    2             &&
    1             ||
</=></pre>


<h4 id="算术运算符">算术运算符</h4>
<p>算术运算符应用于整数、浮点数、复数， + 也可以应用于字符串。</p>
<p>位运算和移位运算只适用于整数。</p>
<pre class="highlight">
+    sum                    integers, floats, complex values, strings
-    difference             integers, floats, complex values
*    product                integers, floats, complex values
/    quotient               integers, floats, complex values
%    remainder              integers

&    bitwise AND            integers
|    bitwise OR             integers
^    bitwise XOR            integers
&^   bit clear (AND NOT)    integers

<<   left shift             integer << unsigned integer
\>>   right shift            integer >> unsigned integer
</pre>

<p><code>^</code>是异或操作。<code>&amp;^</code>位清零操作，如果第二个操作数的二进制的某个位的值为1,那么对应的第一个操作数的位的值则设为0，也就是将第一个操作数上的相应的位清零。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">i1 :=<span class="number"> 0</span>x0F</div><div class="line">i2 := i1 &lt;&lt;<span class="number"> 2</span></div><div class="line"></div><div class="line">fmt.Printf(<span class="string">"0000%b\n00%b\n"</span>, i1, i2) <span class="comment">//00001111 00111100</span></div><div class="line">fmt.Printf(<span class="string">"%b\n"</span>, i1&i2) <span class="comment">//00001100</span></div><div class="line">fmt.Printf(<span class="string">"%b\n"</span>, i1|i2) <span class="comment">//00111111</span></div><div class="line">fmt.Printf(<span class="string">"%b\n"</span>, i1^i2) <span class="comment">//00110011</span></div><div class="line">fmt.Printf(<span class="string">"%b\n"</span>, i1&^i2) <span class="comment">//00000011</span></div></pre></td></tr></table></figure>

<p>对于移位操作，如果左边的操作符是无符号整数，则进行逻辑移位，如果左边的操作符是有符号整数，则进行的是算术移位。略记移位不考虑符号位，而算术移位要考虑符号位，这样能保证 移位操作 和 乘除的操作 一致。</p>
<p><img src="left_logically.png" alt="算术左移"></p>
<p><img src="right_arithmetically.png" alt="算术右移"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i <span class="typename">uint8</span> =<span class="number"> 1</span></div><div class="line">fmt.Printf(<span class="string">"%d: %b\n"</span>, i&lt;<span class="number">&lt;1</span>, i&lt;<span class="number">&lt;1</span>) <span class="comment">//2: 10</span></div><div class="line">fmt.Printf(<span class="string">"%d: %b\n"</span>, i&lt;<span class="number">&lt;7</span>, i&lt;<span class="number">&lt;7</span>) <span class="comment">//128: 10000000</span></div><div class="line">fmt.Printf(<span class="string">"%d: %b\n"</span>, i&lt;<span class="number">&lt;8</span>, i&lt;<span class="number">&lt;8</span>) <span class="comment">//0: 0</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> i2 <span class="typename">int8</span> =<span class="number"> 1</span></div><div class="line">fmt.Printf(<span class="string">"%d: %b\n"</span>, i2&lt;<span class="number">&lt;1</span>, i2&lt;<span class="number">&lt;1</span>) <span class="comment">//2: 10</span></div><div class="line">fmt.Printf(<span class="string">"%d: %b\n"</span>, i2&lt;<span class="number">&lt;7</span>, i2&lt;<span class="number">&lt;7</span>) <span class="comment">//-128: -10000000</span></div><div class="line">fmt.Printf(<span class="string">"%d: %b\n"</span>, i2&lt;<span class="number">&lt;8</span>, i2&lt;<span class="number">&lt;8</span>) <span class="comment">//0: 0</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> i3 <span class="typename">int8</span> =<span class="number"> -1</span></div><div class="line">fmt.Printf(<span class="string">"%d: %b\n"</span>, -i3&lt;<span class="number">&lt;1</span>, -i3&lt;<span class="number">&lt;1</span>) <span class="comment">//2: 10</span></div><div class="line">fmt.Printf(<span class="string">"%d: %b\n"</span>, -i3&lt;<span class="number">&lt;7</span>, -i3&lt;<span class="number">&lt;7</span>) <span class="comment">//-128: -10000000</span></div><div class="line">fmt.Printf(<span class="string">"%d: %b\n"</span>, -i3&lt;<span class="number">&lt;8</span>, -i3&lt;<span class="number">&lt;8</span>) <span class="comment">//0: 0</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> i4 <span class="typename">int8</span> =<span class="number"> -128</span></div><div class="line">fmt.Printf(<span class="string">"%d: %b\n"</span>, -i4&gt;<span class="number">&gt;0</span>, -i4&gt;<span class="number">&gt;0</span>) <span class="comment">//-64: -10000000</span></div><div class="line">fmt.Printf(<span class="string">"%d: %b\n"</span>, -i4&gt;<span class="number">&gt;1</span>, -i4&gt;<span class="number">&gt;1</span>) <span class="comment">//-64: -1000000</span></div><div class="line">fmt.Printf(<span class="string">"%d: %b\n"</span>, -i4&gt;<span class="number">&gt;2</span>, -i4&gt;<span class="number">&gt;2</span>) <span class="comment">//-32: -100000</span></div></pre></td></tr></table></figure>

<p>参考:</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/位操作#.E7.A7.BB.E4.BD.8D" target="_blank" rel="external">https://zh.wikipedia.org/wiki/位操作#.E7.A7.BB.E4.BD.8D</a></li>
</ul>
<p>一元操作符:</p>
<pre class="highlight">
+x                          is 0 + x
-x    negation              is 0 - x
^x    bitwise complement    is m ^ x  with m = "all bits set to 1" for unsigned x
                                      and  m = -1 for signed x
</pre>

<p><code>^x</code> 在C、C#、Java语言中中符号 <code>~</code>,在Go语言中用 <code>^</code>。对于无符号整数来说就是按位取反，对于有符号的整数来说,<br>是按照补码进行取反操作的。<code>-1</code>的补码为<code>11111111</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i1 <span class="typename">uint8</span> =<span class="number"> 3</span></div><div class="line"><span class="keyword">var</span> i2 <span class="typename">int8</span> =<span class="number"> 3</span></div><div class="line"><span class="keyword">var</span> i3 <span class="typename">int8</span> =<span class="number"> -3</span></div><div class="line"></div><div class="line">fmt.Printf(<span class="string">"^%b=%b %d\n"</span>, i1, ^i1, ^i1) <span class="comment">// ^11=11111100 252</span></div><div class="line">fmt.Printf(<span class="string">"^%b=%b %d\n"</span>, i2, ^i2, ^i2) <span class="comment">// ^11=-100 -4</span></div><div class="line">fmt.Printf(<span class="string">"^%b=%b %d\n"</span>, i3, ^i3, ^i3) <span class="comment">// ^-11=10 2</span></div></pre></td></tr></table></figure>

<p>无符号整数的+、-、*、&lt;&lt;的操作的结果会取模2^n， 也就是溢出的位会被丢掉， 比如uint8类型的数 &quot;255 + 2&quot; 会等于 1。</p>
<p>有符号整数的+、-、*、&lt;&lt;的操作的结果的溢出也不会导致异常，但是结果可能不是你想要的，比如x &lt; x+1并不总是成立。比如int8的两个值 &quot;127 + 2 = -127&quot;。</p>
<p>字符串也可以应用<code>+</code>、<code>+=</code>运算符：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s := <span class="string">"hi"</span> + <span class="typename">string</span>(c)</div><div class="line">s += <span class="string">" and good bye"</span></div></pre></td></tr></table></figure>

<h4 id="比较运算符">比较运算符</h4>
<pre class="highlight">
==    等于
!=    不等于
&lt     小于
&lt=    小于等于
&gt     大于
&gt=    大于等于
</pre>

<p><code>==</code>、<code>!=</code>比较相等性， 可比较comparable，<code>&lt;, &lt;=, &gt;, &gt;=</code>是有序运算符, ordered。</p>
<ul>
<li>布尔值: comparable</li>
<li>整数: comparable, ordered</li>
<li>浮点数: comparable, ordered</li>
<li>负数: comparable</li>
<li>字符串： comparable, ordered，根据字节比较</li>
<li>指针: comparable</li>
<li>Channel:  comparable</li>
<li>接口: comparable</li>
<li>一个非接口类型X的值x 可以和 一个接口类型T的值t进行比较: comparable</li>
<li>struct:  comparable 如果它的所有的字段都是comparable的话。<br>＊ 数组：comparable</li>
</ul>
<p>两个接口比较的时候可能导致运行时panic， 如果接口的动态类型的值不可比较的话。</p>
<p>slice、map和函数值都不可以比较，但是它们可以和预定义的零值nil进行比较。</p>
<h3 id="逻辑运算符">逻辑运算符</h3>
<pre class="highlight">
&&    conditional AND    p && q  is  "if p then q else false"
||    conditional OR     p || q  is  "if p then true else q"
!     NOT                !p      is  "not p"
</pre>

<h3 id="地址运算符">地址运算符</h3>
<p><code>&amp;x</code>取址</p>
<p><code>*x</code>取得指针指向的值</p>
<h3 id="receive运算符">receive运算符</h3>
<p>对于Channel类型的值ch, receive操作 <code>&lt;-ch</code>的值代表从ch中取出的一个值。<br>ch的声明时应该允许receive操作。</p>
<p>这个操作会阻塞，直到有值收到。</p>
<p>从一个nil channel中receive会一直阻塞。</p>
<p>从closed channel中的receive会以及处理，返回零值。</p>
<p>从ch中receive也可以用下面的格式:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">x, ok = &lt;-ch</div><div class="line">x, ok := &lt;-ch</div><div class="line"><span class="keyword">var</span> x, ok = &lt;-ch</div></pre></td></tr></table></figure>

<h3 id="Order_of_evaluation">Order of evaluation</h3>
<p>表达式的运算(评估)顺序。</p>
<p>包一级的变量声明中的表达式的运算顺序会根据它们的依赖，这个以后讲，其它的表达式的运算顺序都是从左向右计算。</p>
<p>比如一个函数内的下面的表达式:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">y[f()], ok = g(h(), i()+x[j()], &lt;-c), k()</div></pre></td></tr></table></figure>

<p>它的计算顺序为f(),  h(), i(), j(), &lt;-c, g(), k(),但是计算索引y[],x[]的顺序并没有指定。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a :=<span class="number"> 1</span></div><div class="line">f := <span class="keyword">func</span>() <span class="typename">int</span> { a++; <span class="keyword">return</span> a }</div><div class="line">x := []<span class="typename">int</span>{a, f()}            <span class="comment">// x may be [1, 2] or [2, 2]: evaluation order between a and f() is not specified</span></div><div class="line">m := <span class="keyword">map</span>[<span class="typename">int</span>]<span class="typename">int</span>{a:<span class="number"> 1</span>, a:<span class="number"> 2</span>}  <span class="comment">// m may be {2: 1} or {2: 2}: evaluation order between the two map assignments is not specified</span></div><div class="line">n := <span class="keyword">map</span>[<span class="typename">int</span>]<span class="typename">int</span>{a: f()}      <span class="comment">// n may be {2: 3} or {3: 3}: evaluation order between the key and the value is not specified</span></div></pre></td></tr></table></figure>

<p>对于包一级的变量声明中的表达式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a, b, c = f() + v(), g(), sqr(u()) + v()</div><div class="line"></div><div class="line"><span class="keyword">func</span> f() <span class="typename">int</span>        { <span class="keyword">return</span> c }</div><div class="line"><span class="keyword">func</span> g() <span class="typename">int</span>        { <span class="keyword">return</span> a }</div><div class="line"><span class="keyword">func</span> sqr(x <span class="typename">int</span>) <span class="typename">int</span> { <span class="keyword">return</span> x*x }</div></pre></td></tr></table></figure>

<p>顺序为 u(), sqr(), v(), f(), v(), g()。</p>
<p>下一章将介绍 类型转换(Conversion)、类型断言(type assertion) 和类型切换（type switch）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文介绍Go语言的表达式。</p>
<p>表达式代表一个值的计算， 计算通过运算符和函数应用在操作数上(operand)。<br>]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入Go语言 - 4]]></title>
    <link href="http://colobu.com/2016/06/20/dive-into-go-4/"/>
    <id>http://colobu.com/2016/06/20/dive-into-go-4/</id>
    <published>2016-06-20T04:35:19.000Z</published>
    <updated>2016-07-06T05:30:50.000Z</updated>
    <content type="html"><![CDATA[<p>本文介绍Go的声明和作用域。</p>
<a id="more"></a>
<p>声明用于常量、变量、类型、函数、标签和包。</p>
<p>每个非空标识符(identifier)必须声明。同一代码块中标识符只能声明一次。标识符不能同时声明在文件代码块和包代码块中。</p>
<p>空标识符为下划线 &quot;_&quot;，它可以做为匿名占位符。</p>
<p>一个声明的标识符的作用域总结如下：</p>
<ul>
<li>预声明的标识符的作用域是全局代码块如<code>int</code>、<code>true</code>等</li>
<li>顶层的(函数之外)的标识符， 用来声明常量、类型、变量或者函数(非方法), 这些标识符的作用域是包代码块</li>
<li>一个输入的包的包名的作用域是这个文件的文件代码块</li>
<li>用来表示方法 receiver、函数参数、结果变量的标识符的作用域是函数体</li>
<li>在一个函数内声明的常量或者变量的标识符的作用域起于ConstSpec 、 VarSpec之后(也就是标识符声明之后)， 结束于包含它的最内层的代码块尾部</li>
<li>函数内声明的类型标识符始于 TypeSpec， 结束于包含它的最内层的代码块尾部</li>
</ul>
<p>代码块中的标识符可以在内部的代码块中再次声明，但是内部的标识符和外部的标识符表示不同的对象，这个一定小心。</p>
<p><a href="https://golang.org/ref/spec#Package_clause" target="_blank" rel="external">package clause</a>并不是声明语句。<strong>包名不能出现在任何作用域中</strong>, 经常我们为了方便，声明一个变量的时候和包名一样，比如在引入<code>net/http</code>包的时候声明一个变量是<code>http</code>,这是不对的，这会导致变量名会隐藏(shadow)包名。</p>
<h3 id="标签作用域">标签作用域</h3>
<p>标签(label)作用域可以用于<code>break</code>、<code>continue</code>、<code>goto</code>语句，这在其它语言中也有定义，尽管不会推荐广泛应用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">i :=<span class="number"> 0</span></div><div class="line">回来:</div><div class="line">i++</div><div class="line">fmt.Println(i)</div><div class="line"><span class="keyword">if</span> i &lt;<span class="number"> 5</span> {</div><div class="line">  <span class="keyword">goto</span> 回来</div><div class="line">}</div></pre></td></tr></table></figure>

<p>定义一个未被使用的标签是非法的，这和函数内的定义未被使用的变量是一样的。</p>
<p>标签不会和其它同名的标识符冲突。</p>
<p>标签的作用域只在声明它的位置到函数体的尾部，不会作用于内部嵌套的函数。</p>
<h3 id="空标识符和预定义标识符">空标识符和预定义标识符</h3>
<p>空标识符前面已经提到了，下面是一些空标识符的应用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">	_ <span class="string">"net/http"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> _ = <span class="string">"hello world"</span></div><div class="line"><span class="keyword">var</span> _ =<span class="number"> 100</span></div><div class="line"><span class="keyword">type</span> _ []<span class="typename">int</span></div><div class="line"><span class="keyword">type</span> _ <span class="keyword">struct</span>{}</div><div class="line"><span class="keyword">type</span> _ <span class="keyword">interface</span>{}</div></pre></td></tr></table></figure>

<p>预定义的标识符<a href="http://colobu.com/2016/06/15/dive-into-go-1/" target="_blank" rel="external">第一章</a>中已经介绍了。</p>
<h3 id="输出标识符">输出标识符</h3>
<p>Go语言中没有 public、protect、private等关键字，如果想在其它包中访问当前包的标识符，<br>标识符应该具备下面两个条件,这和其它编程语言不太一样:<br>1、标识符名字的第一个字符应该是unicode upper case letter (Lu)<br>2、并且标识符声明在包代码块中，或者它是一个字段名或者方法名。</p>
<p>举个例子。<br>在当前的main程序所在的目录中创建一个目录p,在里面创建一个文件t.go,定义两个包作用域的变量:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> p</div><div class="line"></div><div class="line"><span class="keyword">var</span> str = <span class="string">"hello world"</span></div><div class="line"><span class="keyword">var</span> Str = <span class="string">"Hello World"</span></div></pre></td></tr></table></figure>

<p>然后在main程序中尝试访问package p下的这两个变量，会发现只能访问<code>Str</code>，<code>str</code>报错，说没有导出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line"></div><div class="line">	<span class="string">"./p"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	fmt.Println(p.str)</div><div class="line">	fmt.Println(p.Str)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>函数、常量、类型、struct、interface、方法都遵循这个法则。所以要想导出一个标识符，请首字母大写。</p>
<p>注意，这里要求的是首字母是unicode upper case letter,就是unicode分类为Lu的字符，对于Unicode字符，你需要知道哪些是大写字符,比如希腊字符也是有大小写的，中文不是大小写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> 一二三 = <span class="string">"123"</span> <span class="comment">//未输出</span></div><div class="line"><span class="keyword">var</span> Π =<span class="number"> 3.1415926</span> <span class="comment">//输出</span></div></pre></td></tr></table></figure>

<p>你可以在 <a href="http://www.fileformat.info/info/unicode/category/Lu/list.htm" target="_blank" rel="external">这里</a> 查看unicode 大写字符列表。</p>
<h3 id="iota">iota</h3>
<p>在常量定义中，<strong>iota</strong> 代表一个连续的未指定类型的整数常量。每当保留字const出现的时候，它都重置为0，后续的每个常量定义都会把它加一。 它常用来定义一组类似枚举的类型，比如月份、星期、颜色等。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ( <span class="comment">// iota is reset to 0</span></div><div class="line">	c0 = <span class="constant">iota</span>  <span class="comment">// c0 == 0</span></div><div class="line">	c1 = <span class="constant">iota</span>  <span class="comment">// c1 == 1</span></div><div class="line">	c2 = <span class="constant">iota</span>  <span class="comment">// c2 == 2</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> ( <span class="comment">// iota 重置为 0</span></div><div class="line">	a =<span class="number"> 1</span> &lt;&lt; <span class="constant">iota</span>  <span class="comment">// a == 1</span></div><div class="line">	b =<span class="number"> 1</span> &lt;&lt; <span class="constant">iota</span>  <span class="comment">// b == 2</span></div><div class="line">	c =<span class="number"> 3</span>          <span class="comment">// c == 3  (iota 虽然没有使用，但是还是会增加)</span></div><div class="line">	d =<span class="number"> 1</span> &lt;&lt; <span class="constant">iota</span>  <span class="comment">// d == 8</span></div><div class="line">)</div><div class="line"><span class="keyword">const</span> ( <span class="comment">// iota 重置为 0</span></div><div class="line">	u         = <span class="constant">iota</span> *<span class="number"> 42</span>  <span class="comment">// u == 0     (untyped integer constant)</span></div><div class="line">	v <span class="typename">float64</span> = <span class="constant">iota</span> *<span class="number"> 42</span>  <span class="comment">// v == 42.0  (float64 constant)</span></div><div class="line">	w         = <span class="constant">iota</span> *<span class="number"> 42</span>  <span class="comment">// w == 84    (untyped integer constant)</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> x = <span class="constant">iota</span>  <span class="comment">// x == 0  (iota 重置为 0)</span></div><div class="line"><span class="keyword">const</span> y = <span class="constant">iota</span>  <span class="comment">// y == 0  (iota 重置为 0)</span></div></pre></td></tr></table></figure>

<p>如果使用表达式列表，同一表达式的iota的值是相同的，因为只有遇到新的ConstSpec才会增加。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> (</div><div class="line">	bit0, mask0 =<span class="number"> 1</span> &lt;&lt; <span class="constant">iota</span>,<span class="number"> 1</span>&lt;&lt;<span class="constant">iota</span> -<span class="number"> 1</span>  <span class="comment">// bit0 == 1, mask0 == 0, iota = 0</span></div><div class="line">	bit1, mask1                           <span class="comment">// bit1 == 2, mask1 == 1, iota = 1</span></div><div class="line">	_, _                                  <span class="comment">// skips iota == 2</span></div><div class="line">	bit3, mask3                           <span class="comment">// bit3 == 8, mask3 == 7, iota =3</span></div><div class="line">)</div></pre></td></tr></table></figure>

<p>Go语言中没有枚举类型，所以一般通过下面的方式定义枚举类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Week <span class="typename">int</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> names = [...]<span class="typename">string</span>{<span class="string">"星期一"</span>, <span class="string">"星期二"</span>, <span class="string">"星期三"</span>, <span class="string">"星期四"</span>, <span class="string">"星期五"</span>, <span class="string">"星期六"</span>, <span class="string">"星期日"</span>}</div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">	Monday Week = <span class="constant">iota</span> +<span class="number"> 1</span></div><div class="line">	Tuesday</div><div class="line">	Wednesday</div><div class="line">	Thursday</div><div class="line">	Friday</div><div class="line">	Saturday</div><div class="line">	Sunday</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> (w Week) String() <span class="typename">string</span> {</div><div class="line">	<span class="keyword">if</span> w &gt;<span class="number"> 0</span> && w &lt;<span class="number"> 8</span> {</div><div class="line">		<span class="keyword">return</span> names[w<span class="number">-1</span>]</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="string">"非法的星期名"</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="函数声明">函数声明</h3>
<p>函数可以声明为签名，也可以定义方法体。</p>
<p>没有方法体的函数只有签名的函数可以声明在接口中，也可以声明包代码块中，此时标明方法是由外部实现的，比如汇编语言。</p>
<p>如果函数声明了返回类型，那么方法体中必须有相应的return语句。</p>
<p>匿名函数又叫函数字面量，它不包含函数名，可以用来赋值给变量(比如在一个函数内或者外赋值给一个变量)、或者直接调用(比如go语句中)。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">f := <span class="keyword">func</span>(x, y <span class="typename">int</span>) <span class="typename">int</span> { <span class="keyword">return</span> x + y }</div><div class="line"><span class="keyword">func</span>(ch <span class="keyword">chan</span> <span class="typename">int</span>) { ch &lt;- ACK }(replyChan)</div><div class="line"><span class="keyword">go</span> <span class="keyword">func</span>(ch <span class="keyword">chan</span> <span class="typename">int</span>) { ch &lt;- ACK }(replyChan)</div></pre></td></tr></table></figure>

<h3 id="方法声明">方法声明</h3>
<p>方法声明类似函数声明，但是它包含一个接受者receiver。</p>
<p>在方法名的前面要声明一个额外的参数，这个参数是单一的，不可变的，作为receiver，<br>它的类型为<code>T</code>或者<code>*T</code>，T叫做receiver base type。</p>
<p>注意<code>T</code>不能是指针类型或者皆苦类型，并且必须和方法声明在同一个包下。你想在自己的包下为标准库中的类型定义一个方法是不行的。</p>
<p>方法名仅仅在类型T 或者 *T的 selector中显示。</p>
<p>receiver名不能和参数名或者返回参数重名：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//错误</span></div><div class="line"><span class="keyword">func</span> (i IntArr) Say(i <span class="typename">int</span>) (i <span class="typename">int</span>) {</div><div class="line">	<span class="keyword">return</span><span class="number"> 0</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>方法名唯一。</p>
<p>对于struct类型，方法名和字段名必须唯一。</p>
<p>方法的特性和selector在下一章的表达式介绍。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文介绍Go的声明和作用域。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Scala集合技术手册出版了]]></title>
    <link href="http://colobu.com/2016/06/19/scala-collections-cookbook-is-available/"/>
    <id>http://colobu.com/2016/06/19/scala-collections-cookbook-is-available/</id>
    <published>2016-06-19T09:45:47.000Z</published>
    <updated>2016-06-21T08:57:05.000Z</updated>
    <content type="html"><![CDATA[<p>拙著《Scala集合技术手册》出版了，详细信息请看 <a href="/ScalaCollectionsCookbook/">这里</a>。</p>
<p>这是我在学习和使用Scala过程中的技术总结和探索。</p>
<p>市面上第一本全面介绍Scala集合框架的图书。</p>
<p>首部国人原创中文Scala图书。</p>
<p><strong>编辑推荐</strong><br>√ Scala集合库不可多得的中文资料<br>√ 作为Scala的制胜法宝本书教你如何驾驭<br>√ 面向实际问题用示例代码讲解类的使用和原理<br>√ 全新角度实现基本数据结构是提升功力的不二法门</p>
<p><strong>挖财架构师《 Scala 函数式编程》译者 王宏江 作序</strong></p>
<p><strong>推荐</strong><br>√ 极牛创始人 CEO 吴际超<br>√ 《快学Scala》译者 高宇翔<br>√ 阿里巴巴 善马(柴克斌)<br>√ 联想 柴明贵</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>拙著《Scala集合技术手册》出版了，详细信息请看 <a href="/ScalaCollectionsCookbook/">这里</a>。</p>
<p>这是我在学习和使用Scala过程中的技术总结和探索。</p>
<p>市面上第一本全面介绍Scala集合框架的图书。</]]>
    </summary>
    
      <category term="Scala" scheme="http://colobu.com/tags/Scala/"/>
    
      <category term="Scala" scheme="http://colobu.com/categories/Scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入Go语言 - 3]]></title>
    <link href="http://colobu.com/2016/06/16/dive-into-go-3/"/>
    <id>http://colobu.com/2016/06/16/dive-into-go-3/</id>
    <published>2016-06-16T05:24:22.000Z</published>
    <updated>2016-07-21T01:53:10.000Z</updated>
    <content type="html"><![CDATA[<p>本文介绍Go的类型系统,以及类型的比较和语句块。</p>
<p>Go语言包含11种类型，你应该很熟悉了，下面让我们再深入的了解一下每种类型的细节。</p>
<ul>
<li>布尔类型</li>
<li>数值类型</li>
<li>字符串类型</li>
<li>数组类型</li>
<li>Slice类型</li>
<li>Struct类型</li>
<li>指针类型</li>
<li>函数类型</li>
<li>接口类型</li>
<li>Map类型</li>
<li>Channel类型</li>
</ul>
<a id="more"></a>
<p>bool、数值型类型、rune、字符串都是预定义的类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="typename">bool</span> <span class="typename">byte</span> <span class="typename">complex64</span> <span class="typename">complex128</span> error <span class="typename">float32</span> <span class="typename">float64</span></div><div class="line"><span class="typename">int</span> <span class="typename">int8</span> <span class="typename">int16</span> <span class="typename">int32</span> <span class="typename">int64</span> <span class="typename">rune</span> <span class="typename">string</span></div><div class="line"><span class="typename">uint</span> <span class="typename">uint8</span> <span class="typename">uint16</span> <span class="typename">uint32</span> <span class="typename">uint64</span> <span class="typename">uintptr</span></div></pre></td></tr></table></figure>

<p>复合类型array, struct, pointer, function, interface, slice, map 和 channel 由类型字面量构造而成。</p>
<p>每一个类型都有一个底层类型(underlying type),比如下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> T1 <span class="typename">string</span></div><div class="line"><span class="keyword">type</span> T2 T1</div><div class="line"><span class="keyword">type</span> T3 []T1</div><div class="line"><span class="keyword">type</span> T4 T3</div></pre></td></tr></table></figure>

<p><code>string</code>、<code>T1</code>、<code>T2</code>的底层类型</p>
<ul>
<li><strong>命名类型(named type)</strong> : 由一个确定的类型的名称指定</li>
<li><strong>未命名类型(unamed type)</strong>:由类型字面量指定，类型字面量由既有的类型组成</li>
</ul>
<p>比如下面的例子中, x的类型就是未命名类型，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x <span class="keyword">struct</span>{ I <span class="typename">int</span> }</div></pre></td></tr></table></figure>

<p>而下面的例子中，y的类型就是命名类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span>{ I <span class="typename">int</span> }</div><div class="line"><span class="keyword">var</span> y Foo</div></pre></td></tr></table></figure>

<p>未命名类型的一个重要属性就是用同样类型的未命名类型声明的变量拥有相同的类型，而两个不同的命名类型，即使底层的类型相同，它们的类型也是不同的。<br>更详细的总结会在下一篇文章中介绍，比如我们再定义两个类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x2 <span class="keyword">struct</span>{ I <span class="typename">int</span> }</div><div class="line"><span class="keyword">type</span> Bar <span class="keyword">struct</span>{ I <span class="typename">int</span> }</div><div class="line"><span class="keyword">var</span> y2 Bar</div></pre></td></tr></table></figure>

<p>其中 <strong>x</strong> 和 <strong>x2</strong> 的类型相同， 而 <strong>y</strong> 和 <strong>y2</strong> 的类型却不相同。</p>
<p>命名类型可以定义自己的函数， 而未命名类型确不行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (f *Foo) Hello() {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (a []<span class="typename">int</span>) Hello() { <span class="comment">//错误, []int是未命名类型</span></div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>比如上例中，<code>[]int</code>是未命名类型，没办法为它定义方法,所以我们可以像下面的例子一样定义一个命名类型，它的底层类型是<code>[]int</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> IntArr []<span class="typename">int</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> (ia *IntArr) Hello() {</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>参考</p>
<ul>
<li><a href="https://github.com/golang/go/issues/5682" target="_blank" rel="external">https://github.com/golang/go/issues/5682</a></li>
<li><a href="http://stackoverflow.com/questions/32983546/named-and-unnamed-types" target="_blank" rel="external">http://stackoverflow.com/questions/32983546/named-and-unnamed-types</a></li>
<li><a href="http://blog.csdn.net/hittata/article/details/51250179" target="_blank" rel="external">http://blog.csdn.net/hittata/article/details/51250179</a></li>
</ul>
<h3 id="布尔类型">布尔类型</h3>
<p>很简单，类型名为<code>bool</code>,只有两个值： <code>true</code> 和 <code>false</code>。</p>
<p>参考</p>
<ul>
<li><a href="https://github.com/golang/go/issues/15171" target="_blank" rel="external">https://github.com/golang/go/issues/15171</a></li>
</ul>
<h3 id="数值类型">数值类型</h3>
<p>数值类型包括整数、浮点数和复数。总结如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>uint8</td>
<td>无符号8位整数，(0 to 255)｜</td>
</tr>
<tr>
<td>uint16</td>
<td>无符号16位整数， (0 to 65535)</td>
<td></td>
</tr>
<tr>
<td>uint32</td>
<td>无符号32位整数， (0 to 4294967295)</td>
</tr>
<tr>
<td>uint64</td>
<td>无符号64位整数， (0 to 18446744073709551615)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>int8</td>
<td>8位整数， (-128 to 127)</td>
</tr>
<tr>
<td>int16</td>
<td>16位整数， (-32768 to 32767)</td>
</tr>
<tr>
<td>int32</td>
<td>16位整数， (-2147483648 to 2147483647)</td>
</tr>
<tr>
<td>int64</td>
<td>64位整数， (-9223372036854775808 to 9223372036854775807)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>float32</td>
<td>IEEE-754 32位浮点数</td>
</tr>
<tr>
<td>float64</td>
<td>IEEE-754 64位浮点数</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>complex64</td>
<td>实部和虚部都是float32</td>
</tr>
<tr>
<td>complex128</td>
<td>实部和虚部都是float32</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>byte</td>
<td>uint8的别名</td>
</tr>
<tr>
<td>rune</td>
<td>int32的别名</td>
</tr>
</tbody>
</table>
<p>在不同的架构上，下面的几种类型可能的位数不同：<br><code>uint</code>可能是32位或者64位<br><code>int</code>可能是32位或者64位<br><code>uintptr</code> 是一个足够大的无符号整数，可以代表一个指针的值得</p>
<p><code>int</code>和<code>int32</code>并不是一个相同的类型，尽管在一些环境下它们的位数都是32位。</p>
<h3 id="数组类型">数组类型</h3>
<p>数组代表有限的同一元素类型的对象的序列。对象的数量就是数组的长度， 通过<code>len</code>方法得到。</p>
<p>数组是一维的，但是你可以构造多维数组：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">[3</span>]<span class="number">[5</span>]<span class="typename">int</span></div><div class="line"><span class="number">[2</span>]<span class="number">[2</span>]<span class="number">[2</span>]<span class="typename">float64</span>  <span class="comment">// 等价 [2]([2]([2]float64))</span></div></pre></td></tr></table></figure>

<p>数组可以通过下面的方式声明，需要指定它的长度：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> buffer <span class="number">[256</span>]<span class="typename">byte</span></div></pre></td></tr></table></figure>

<p>声明和初始化可以合在一起：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">buffer := <span class="number">[10</span>]<span class="typename">string</span>{}             <span class="comment">// len(buffer) == 10</span></div><div class="line">intSet := <span class="number">[6</span>]<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>,<span class="number"> 5</span>}       <span class="comment">// len(intSet) == 6</span></div><div class="line">days := [...]<span class="typename">string</span>{<span class="string">"Sat"</span>, <span class="string">"Sun"</span>}  <span class="comment">// len(days) == 2</span></div></pre></td></tr></table></figure>

<p><code>[...]</code>是根据初始化的元素的数量确定数组的长度。</p>
<h3 id="Slice类型">Slice类型</h3>
<p>实际在开发的过程中，我们使用数组的场合比较少，这是因为数组一旦定义，它的长度就不能再发生变化，这和很多其它编程语言的定义是一样的。<br>更多的情况下我们会使用slice。</p>
<p>Slice描述了数组的一个连续的片段。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> slice []<span class="typename">byte</span> = buffer<span class="number">[100</span><span class="number">:150</span>]</div></pre></td></tr></table></figure>

<p>上面的例子中<code>slice</code>对象代表数组的索引位置为100 ~149的元素。</p>
<p>其实slice数据结构是由<code>SliceHeader</code>描述的,所以我们可以看到slice是由三个数据描述的：<code>第0个元素的指针</code>、<code>长度</code>、<code>容量</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> {</div><div class="line">        Data <span class="typename">uintptr</span></div><div class="line">        Len  <span class="typename">int</span></div><div class="line">        Cap  <span class="typename">int</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>在后面的文章中我会介绍通过指针操作SliceHeader。</p>
<p>slice可以从数组中生成，如上面的例子，也可以直接生成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1 []<span class="typename">int</span></div><div class="line"><span class="keyword">var</span> s2 = <span class="built_in">make</span>([]<span class="typename">int</span>,<span class="number"> 10</span>)</div><div class="line"><span class="keyword">var</span> s3 = <span class="built_in">make</span>([]<span class="typename">int</span>,<span class="number"> 10</span>,<span class="number"> 20</span>)</div><div class="line"></div><div class="line">fmt.Printf(<span class="string">"len:%d, cap:%d\n"</span>, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</div><div class="line">fmt.Printf(<span class="string">"len:%d, cap:%d\n"</span>, <span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2))</div><div class="line">fmt.Printf(<span class="string">"len:%d, cap:%d\n"</span>, <span class="built_in">len</span>(s3), <span class="built_in">cap</span>(s3))</div></pre></td></tr></table></figure>

<p>在生成的时候可以指定slice的长度和容量，如果没有指定容量(make的第三个参数)，则容量和长度相同。<br>如果不是通过<code>make</code>创建，而是通过<code>var</code>的方式声明一个零值的slice，则它的长度和容量都为0。</p>
<p>一旦一个slice创建出来，它的底层元素是由一个数组保存着。slice的容量就是这个数组的长度，可以通过<code>cap</code>获得。<br>如果slice的元素的数量超过容量，就需要创建新的数组。这是一个值得注意的地方，如果你初始的时候就可以确定元素的最大数量的情况下，<br>最好设置slice的容量的值，这样避免数组的重新分配和数据拷贝，提高程序的性能。</p>
<h4 id="index,_append,_remove_和_copy">index, append, remove 和 copy</h4>
<p>slice和数组一样，都是可以通过索引得到某个位置的元素。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a := [...]<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>,<span class="number"> 4</span>,<span class="number"> 5</span>}</div><div class="line"><span class="keyword">var</span> s = a[:]</div><div class="line"></div><div class="line">fmt.Printf(<span class="string">"%d\n"</span>, s<span class="number">[0</span>])</div><div class="line">fmt.Printf(<span class="string">"%d/n"</span>, s<span class="number">[10</span>])<span class="comment">//panic: runtime error: index out of range</span></div></pre></td></tr></table></figure>

<p>如果超出slice的索引最大值，就会导致panic。</p>
<p>可以往slice增加元素：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">s2 := <span class="built_in">append</span>(s,<span class="number"> 6</span>)</div><div class="line">fmt.Printf(<span class="string">"s: %#v\ns2:%#v\n"</span>, s, s2)</div><div class="line"></div><div class="line"><span class="comment">//output:</span></div><div class="line"><span class="comment">//s: []int{1, 2, 3, 4, 5}</span></div><div class="line"><span class="comment">//s2:[]int{1, 2, 3, 4, 5, 6}</span></div></pre></td></tr></table></figure>

<p>通过<code>append</code>方法可以往slice增加元素，值得注意的是append的返回值是增加元素后的slice，和原始的slice不同，尽管它们底层的数组可能相同。<br>如果容量足够，元素就继续增加底层数组中，如果容量不够，则结果slice就会创建新的数组。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> <span class="built_in">append</span>(slice []Type, elems ...Type) []Type</div></pre></td></tr></table></figure>

<p>你可以往slice一次增加多个元素：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">slice = <span class="built_in">append</span>(slice, elem1, elem2)</div><div class="line">slice = <span class="built_in">append</span>(slice, anotherSlice...)</div></pre></td></tr></table></figure>

<p>注意<code>...</code>写法，它意味着你可以把一个slice中所有的元素全部增加到另外一个slice的尾部:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s3 := <span class="built_in">append</span>(s, s...)</div><div class="line">fmt.Printf(<span class="string">"s: %#v\ns3:%#v\n"</span>, s, s3)</div></pre></td></tr></table></figure>

<p>一个值得注意的技巧是可以将一个字符串的byte一次都增加到一个 []byte中:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s4 := <span class="built_in">append</span>([]<span class="typename">byte</span>(<span class="string">"hello "</span>), <span class="string">"world"</span>...)</div></pre></td></tr></table></figure>

<p>要删除slice某个索引的位置，可以通过下面的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s5 := <span class="built_in">append</span>(s[<span class="number">:2</span>], s<span class="number">[3</span>:]...)</div><div class="line">fmt.Printf(<span class="string">"s: %#v\ns5:%#v\n"</span>, s, s5)</div></pre></td></tr></table></figure>

<p>这个例子删除索引2处的元素。</p>
<p>slice的拷贝是通过<code>copy</code>方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> <span class="built_in">copy</span>(dst, src []Type) <span class="typename">int</span></div></pre></td></tr></table></figure>

<p>返回结果为 dst和src的长度的最小值。这也就是说，如果dst的长度大，则将src全部元素都复制到dst中。如果src的长度大，则将src的len(dst)个元素复制到dst中。</p>
<h4 id="slice类型再深入">slice类型再深入</h4>
<p>因为slice底层使用数组，而这个数组可能在数组和多个slice中共用，这会带来潜在的问题。</p>
<p>1、对数组中元素的更改会影响slice<br>下面的例子中我们将数组的第一个值改为100,可以看到slice的第一个值也变了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a := [...]<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>,<span class="number"> 4</span>,<span class="number"> 5</span>}</div><div class="line"><span class="keyword">var</span> s = a[:]</div><div class="line"></div><div class="line">a<span class="number">[0</span>] =<span class="number"> 100</span></div><div class="line">fmt.Printf(<span class="string">"a: %#v\ns:%#v\n"</span>, a, s)</div></pre></td></tr></table></figure>

<p>2、如果slice使用不同的数组，则不会有影响<br>这一条是显而易见的，既然数组都不相同了，当然也没有什么影响了。<br>但是有时候你不是很容易的发现:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a := [...]<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>,<span class="number"> 4</span>,<span class="number"> 5</span>}</div><div class="line"><span class="keyword">var</span> s = a[:]</div><div class="line">s = <span class="built_in">append</span>(s,<span class="number"> 6</span>)</div><div class="line"></div><div class="line">a<span class="number">[0</span>] =<span class="number"> 100</span></div><div class="line">fmt.Printf(<span class="string">"a: %#v\ns:%#v\n"</span>, a, s)</div></pre></td></tr></table></figure>

<p>第三行在增加6到数组的尾部的时候，其实slice的容量已经不够了，所以为返回结果的slice新建了数组。<br>因此对原始数组的更改不会影响s2,但是对s却有影响，s的第一个值也变了。</p>
<p>3、当两个slice有重叠时，可能会有影响</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">a := [...]<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>,<span class="number"> 4</span>,<span class="number"> 5</span>}</div><div class="line">s1 := a<span class="number">[0</span><span class="number">:1</span>]</div><div class="line">s2 := a<span class="number">[0</span><span class="number">:2</span>]</div><div class="line"></div><div class="line">s1 = <span class="built_in">append</span>(s1,<span class="number"> 100</span>)</div><div class="line"></div><div class="line">fmt.Printf(<span class="string">"a: %#v\ns1:%#v\ns2:%#v\n"</span>, a, s1, s2)</div></pre></td></tr></table></figure>

<p>这个例子s1和s2都使用相同的数组a,而且它们的容量都是5，不同的是它们的长度分别是1和2。</p>
<p>当往s1增加增加一个元素的时候，它事实上将元素放在的数组的索引为2的位置。这会对原始数组和s2都有影响，<br>看到检查输出的结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">a</span>: <span class="attr_selector">[5]</span><span class="tag">int</span><span class="rules">{<span class="rule">1, 100, 3, 4, 5}</span></span></div><div class="line"><span class="tag">s1</span>:<span class="attr_selector">[]</span><span class="tag">int</span><span class="rules">{<span class="rule">1, 100}</span></span></div><div class="line"><span class="tag">s2</span>:<span class="attr_selector">[]</span><span class="tag">int</span><span class="rules">{<span class="rule">1, 100}</span></span></div></pre></td></tr></table></figure>

<p>4、 copy的时候有重叠<br>调用<code>copy</code>方法的时候也可能会产生副作用，比如下面的例子，copy到s1的操作导致底层的数组改变了，影响了a,s1,s2的值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a := [...]<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>,<span class="number"> 4</span>,<span class="number"> 5</span>}</div><div class="line">s1 := a<span class="number">[0</span><span class="number">:3</span>]</div><div class="line">s2 := a<span class="number">[1</span><span class="number">:5</span>]</div><div class="line"><span class="built_in">copy</span>(s1, s2)</div><div class="line"></div><div class="line">fmt.Printf(<span class="string">"a: %#v\ns1:%#v\ns2:%#v\n"</span>, a, s1, s2)</div></pre></td></tr></table></figure>

<p>5、Slice作为参数传递<br>Go语言实际上都是按值传递的(指针类型传递的是指针的值)。因此下面的例子中s1并没有被修改，你只能按照<code>returningToo</code>函数的方式得到修改的slice。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> mystruct <span class="keyword">struct</span> {</div><div class="line">	val <span class="typename">int</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> s1 []mystruct</div><div class="line">	<span class="keyword">var</span> s2 []mystruct</div><div class="line"></div><div class="line">	onlyPassing(s1)</div><div class="line">	s2 = returningToo(s2)</div><div class="line"></div><div class="line">	fmt.Printf(<span class="string">"%#v\n%#v"</span>, s1, s2)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> onlyPassing(s []mystruct) {</div><div class="line">	s = <span class="built_in">append</span>(s, mystruct<span class="number">{1</span>})</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> returningToo(s []mystruct) []mystruct {</div><div class="line">	s = <span class="built_in">append</span>(s, mystruct<span class="number">{1</span>})</div><div class="line">	<span class="keyword">return</span> s</div><div class="line">}</div></pre></td></tr></table></figure>

<p>或者传递slice的指针：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> onlyPassing(s *[]mystruct) {</div><div class="line">    *s = <span class="built_in">append</span>(*s, mystruct<span class="number">{1</span>})</div><div class="line">}</div></pre></td></tr></table></figure>

<p>参考</p>
<ul>
<li><a href="https://blog.golang.org/slices" target="_blank" rel="external">https://blog.golang.org/slices</a></li>
<li><a href="https://golang.org/pkg/unsafe/" target="_blank" rel="external">https://golang.org/pkg/unsafe/</a></li>
<li><a href="https://www.reddit.com/r/golang/comments/283vpk/help_with_slices_and_passbyreference/" target="_blank" rel="external">https://www.reddit.com/r/golang/comments/283vpk/help_with_slices_and_passbyreference/</a></li>
</ul>
<h3 id="字符串类型">字符串类型</h3>
<p>字符串类型(string)是一个常用的类型，它的值是一组基本按照UTF-8编码的字节序列，可以为空。<br>在前一篇文章中我已经介绍了字符串类型，所以此处不再重复介绍了，我会介绍一些有趣的性能。</p>
<p>字符串是不可变的，一旦创建，它的值就不能修改了。</p>
<p>内建的<code>len</code>方法可以得到字符串的长度，每个字节可以根据索引得到，不能像 C 语言一样得到某个字节的地址，<code>&amp;s[i]</code>这样做是非法的。</p>
<p>你可以把字符串看成一个不可变的slice，比如根据索引得到某个位置的字节，copy操作, append 字符串到[]byte中等：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">s := <span class="string">"hello world"</span></div><div class="line">b := <span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number"> 5</span>)</div><div class="line"><span class="built_in">copy</span>(b, s)</div><div class="line">fmt.Println(s<span class="number">[0</span>])</div><div class="line">fmt.Println(b)</div><div class="line">fmt.Println(<span class="built_in">append</span>([]<span class="typename">byte</span>{}, s...))</div></pre></td></tr></table></figure>

<p>字符串和slices of bytes可以很方便的进行互转，因为它们的结构类似，底层都是通过一个数组保存元素的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">s := <span class="string">"hello world"</span></div><div class="line">b := []<span class="typename">byte</span>(s)</div><div class="line">s = <span class="typename">string</span>(b)</div></pre></td></tr></table></figure>

<p>通常情况下，这种转换是对底层数组的复制，所以对转换后的slice的更改不会影响原来的字符串，这也保证了字符串的不可变。</p>
<p>但是，数组的复制是有代价的，内存的分配和数据的拷贝以及垃圾回收都会带来性能等开销，所以在追求性能的场合，比如一些Web框架中，<br>采用来了一些&quot;花招&quot;实现&quot;零拷贝&quot;。</p>
<p>首先我们看看stirng和slice的数据结构是怎么样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> {</div><div class="line">        Data <span class="typename">uintptr</span></div><div class="line">        Len  <span class="typename">int</span></div><div class="line">        Cap  <span class="typename">int</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> {</div><div class="line">        Data <span class="typename">uintptr</span></div><div class="line">        Len  <span class="typename">int</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>看起来结构类似明知不过slice对string多了一个Cap字段。<br>所以我们可以根据它们的结构进行转换，不需要拷贝底层的数据Data:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"reflect"</span></div><div class="line">	<span class="string">"unsafe"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	s := <span class="string">"hello world"</span></div><div class="line">	b := StringToBytes(s)</div><div class="line">	s = BytesToString(b)</div><div class="line"></div><div class="line">	fmt.Printf(<span class="string">"%s\n"</span>, s)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> BytesToString(b []<span class="typename">byte</span>) <span class="typename">string</span> {</div><div class="line">	bytesHeader := (*reflect.SliceHeader)(unsafe.Pointer(&b))</div><div class="line">	strHeader := reflect.StringHeader{bytesHeader.Data, bytesHeader.Len}</div><div class="line">	<span class="keyword">return</span> *(*<span class="typename">string</span>)(unsafe.Pointer(&strHeader))</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> StringToBytes(s <span class="typename">string</span>) []<span class="typename">byte</span> {</div><div class="line">	strHeader := (*reflect.StringHeader)(unsafe.Pointer(&s))</div><div class="line">	bytesHeader := reflect.SliceHeader{strHeader.Data, strHeader.Len, strHeader.Len}</div><div class="line">	<span class="keyword">return</span> *(*[]<span class="typename">byte</span>)(unsafe.Pointer(&bytesHeader))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>整数之间、整数和字符串之间、slice和整数之间的转换放在数据转换一文中专门介绍。<br>参考</p>
<ul>
<li><a href="https://golang.org/src/runtime/string.go" target="_blank" rel="external">https://golang.org/src/runtime/string.go</a></li>
<li><a href="https://golang.org/pkg/reflect/#SliceHeader" target="_blank" rel="external">https://golang.org/pkg/reflect/#SliceHeader</a></li>
<li><a href="https://github.com/alecthomas/unsafeslice" target="_blank" rel="external">https://github.com/alecthomas/unsafeslice</a></li>
</ul>
<h3 id="Struct类型">Struct类型</h3>
<p>了解C语言的同学都知道struct(结构体)。</p>
<p>struct是一组命名的元素的序列，每个元素都有名字和类型，这些元素叫做结构体的字段(field)。字段名可能显示地指定，也可能隐式地指定。字段名不能重复。</p>
<p>struct类型有很多有趣的特性。</p>
<p>1、匿名字段<br>空字段、占位字段自不必说，你应该都已经了解了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> A <span class="keyword">struct</span>{}</div><div class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> {</div><div class="line">	i1 <span class="typename">uint16</span></div><div class="line">	_  <span class="typename">int16</span></div><div class="line">	i2 <span class="typename">int</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>struct还允许定义匿名字段。 匿名字段指声明了类型的字段，也叫嵌入字段或者嵌入类型。嵌入类型由类型名T或者指向非接口类型的指针*T指定。T本身不能再是指针类型。 类型名作为字段的名字。</p>
<p>下面的例子中的结构体包含四个匿名字段，可以看到包名不会作为字段名的一部分。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> {</div><div class="line">	T1        <span class="comment">// 字段名 T1</span></div><div class="line">	*T2       <span class="comment">// 字段名 T2</span></div><div class="line">	P.T3      <span class="comment">// 字段名 T3</span></div><div class="line">	*P.T4     <span class="comment">// 字段名 T4</span></div><div class="line">	x, y <span class="typename">int</span>  <span class="comment">// 字段名 x 和 y</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>下面的结构体的定义是非法的，因为三个字段重名了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> {</div><div class="line">	T     </div><div class="line">	*T    </div><div class="line">	*P.T  </div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果结构体x有一个嵌入字段E,并且E拥有字段或者方法f，那么你可以直接调用x.f (如果x.f是一个合法的selector的话)，<br>这叫做字段提升(promoted)。</p>
<p>提升的字段就像结构体的正常的字段一样，除了初始化的时候不能像普通的字段设置。</p>
<p>假设有一个struct S和一个类型T, 提升的方法有以下的特性：</p>
<ul>
<li>如果 <code>S</code> 包含一个嵌入字段 <code>T</code>, 那么 <code>S</code> 和 <code>*S</code> 的方法集包含 receiver <code>T</code>的方法. 而 <code>*S</code> 还包含 receiver <code>*T</code>的方法.</li>
<li>如果 <code>S</code> 包含一个嵌入字段 <code>*T</code>, 那么 <code>S</code> 和 <code>*S</code> 的方法集都包含 receiver <code>T</code> 和 <code>*T</code>的方法.</li>
</ul>
<p><code>*S</code> 可以直接访问 <code>S</code> 的方法，而不必求值后再访问。</p>
<p>关于方法集和receiver我们在以后再讲。</p>
<p>字段的声明中还可以包含一个缺省的字符串tag, 用来作为这个字段的属性，通过反射可以得到这个tag的值，在类型比较的时候会进行比较。经常用在结构体的序列化反序列化中,序列化库可以根据这些tag将相应的字段转换成合适的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> ColorGroup <span class="keyword">struct</span> {</div><div class="line">	Id     <span class="typename">int</span>      <span class="string">`json:"id" xml:"id,attr" msg:"id"`</span></div><div class="line">	Name   <span class="typename">string</span>   <span class="string">`json:"name" xml:"name" msg:"name"`</span></div><div class="line">	Colors []<span class="typename">string</span> <span class="string">`json:"colors" xml:"colors" msg:"colors"`</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>struct本身也可以是匿名的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">struct</span> {</div><div class="line">	Name <span class="typename">string</span></div><div class="line">}{<span class="string">"鸟窝"</span>}</div></pre></td></tr></table></figure>

<p>但是不能把一个匿名struct作为匿名字段，因为Go不知道如何命名此字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>

<p>所以必须为匿名struct字段命名，初始化的时候还挺麻烦：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> u = <span class="keyword">struct</span> {</div><div class="line">	Age  <span class="typename">int</span></div><div class="line">	Name <span class="keyword">struct</span> {</div><div class="line">		FirstName <span class="typename">string</span></div><div class="line">		LastName  <span class="typename">string</span></div><div class="line">	}</div><div class="line">}{Age:<span class="number"> 18</span>, Name: <span class="keyword">struct</span> {</div><div class="line">	FirstName <span class="typename">string</span></div><div class="line">	LastName  <span class="typename">string</span></div><div class="line">}{<span class="string">"鸟"</span>, <span class="string">"窝"</span>}}</div></pre></td></tr></table></figure>

<h3 id="指针类型">指针类型</h3>
<p>指针类型相对于于C语言，是一个简化版的指针，避免了C语言指针复杂的计算带来的陷阱。</p>
<p>指针类型就是在原有的类型前面加星号 <code>*</code>。</p>
<p>假设有个操作数x, 类型为T, 那么 <code>&amp;T</code>则为x的指针，类型为 <code>*T</code>。</p>
<p>你可以声明指向指针的指针:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x :=<span class="number"> 10</span></div><div class="line">p := &x</div><div class="line"><span class="keyword">var</span> pp **<span class="typename">int</span> = &p</div><div class="line">fmt.Printf(<span class="string">"%d\n"</span>, **pp)</div></pre></td></tr></table></figure>

<p>但是不能像C语言一样直接移动指针:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x := [...]<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>,<span class="number"> 4</span>,<span class="number"> 5</span>}</div><div class="line">p := &x</div><div class="line">p = p +<span class="number"> 1</span></div><div class="line">fmt.Printf(<span class="string">"%d\n"</span>, *p)</div></pre></td></tr></table></figure>

<p>虽然我们不能直接移动指针，但是我们可以通过曲折的方法操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">x := [...]<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>,<span class="number"> 4</span>,<span class="number"> 5</span>}</div><div class="line">p := &x<span class="number">[0</span>]</div><div class="line"></div><div class="line"><span class="comment">//p = p + 1</span></div><div class="line">index2Pointer := unsafe.Pointer(<span class="typename">uintptr</span>(unsafe.Pointer(p)) + unsafe.Sizeof(x<span class="number">[0</span>]))</div><div class="line">p = (*<span class="typename">int</span>)(index2Pointer) <span class="comment">//x[1]</span></div><div class="line">fmt.Printf(<span class="string">"%d\n"</span>, *p)    <span class="comment">//2</span></div></pre></td></tr></table></figure>

<p>这个例子中我们成功地将指针移动到第二个索引处，虽然它和 &amp;x[1]的功能是一样的，但却表明我们可以根据偏移量计算指针。<br>这种方法更多的应用到struct的字段值的读取中，一些序列化的库通过它来读取struct字段的值。</p>
<p>首先我们认识两个对象: <code>uintptr</code>和<code>unsafe.Pointer</code>。<br><code>uintptr</code>是一个足够大的整数，用来存放指针的位。</p>
<p><code>unsafe.Pointer</code>定义如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> ArbitraryType <span class="typename">int</span>  <span class="comment">// shorthand for an arbitrary Go type; it is not a real type</span></div><div class="line"><span class="keyword">type</span> Pointer *ArbitraryType</div></pre></td></tr></table></figure>

<p>Pointer代表指向任意类型的指针，它有四个独有的操作：<br>1) 任意类型的指针可以被转换成一个 Pointer对象.<br>2) 相反一个Pointer也可以转换成任意类型的指针.<br>3) 一个uintptr可以转换成一个Pointer.<br>4) 相反一个Pointer可以转换成uintptr.</p>
<p>通过Pointer我们就可以直接读取内存，使用起来要格外小心。<br>下面列出了几种转换：<br>1、*T -&gt;  Pointer to T2</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i <span class="typename">int64</span> =<span class="number"> 100</span></div><div class="line"><span class="keyword">var</span> p *<span class="typename">int64</span> = &i <span class="comment">//*int64</span></div><div class="line">P := unsafe.Pointer(p)</div></pre></td></tr></table></figure>

<p>2、Pointer to T2 -&gt; *T</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i <span class="typename">int64</span> =<span class="number"> 100</span></div><div class="line"><span class="keyword">var</span> p *<span class="typename">int64</span> = &i <span class="comment">//*int64</span></div><div class="line"></div><div class="line">P := unsafe.Pointer(p)</div><div class="line"></div><div class="line">p2 := (*<span class="typename">int32</span>)(P) <span class="comment">//*int32</span></div><div class="line">fmt.Println(*p2)</div></pre></td></tr></table></figure>

<p>3、Pointer -&gt; uintptr</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i <span class="typename">int64</span> =<span class="number"> 200</span>&lt;<span class="number">&lt;32</span> +<span class="number"> 100</span></div><div class="line"><span class="keyword">var</span> p = &i</div><div class="line">P0 := unsafe.Pointer(p)</div><div class="line"></div><div class="line">P := unsafe.Pointer(<span class="typename">uintptr</span>(P0) +<span class="number"> 4</span>)</div><div class="line">p2 := (*<span class="typename">int32</span>)(P)</div><div class="line"></div><div class="line">fmt.Println(*p2) <span class="comment">//200</span></div></pre></td></tr></table></figure>

<p>4、uintptr -&gt; Pointer<br>同上, Pointer(uintptr)转换即可。</p>
<p>内建的<code>new</code>函数可以为类型T创建零值的对象,它返回的对象类型为<code>*T</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i = <span class="built_in">new</span>(<span class="typename">int</span>)</div><div class="line"><span class="keyword">var</span> s = <span class="built_in">new</span>(<span class="typename">string</span>)</div><div class="line"><span class="keyword">var</span> j = <span class="built_in">new</span>(<span class="keyword">struct</span>{ <span class="typename">int</span> })</div><div class="line"></div><div class="line">fmt.Printf(<span class="string">"%T %T %T\n"</span>, i, s, j) <span class="comment">//*int *string *struct { int }</span></div></pre></td></tr></table></figure>

<p>参考</p>
<ul>
<li><a href="https://golang.org/pkg/unsafe/" target="_blank" rel="external">https://golang.org/pkg/unsafe/</a></li>
<li><a href="http://learngowith.me/gos-pointer-pointer-type/" target="_blank" rel="external">http://learngowith.me/gos-pointer-pointer-type/</a></li>
</ul>
<h3 id="函数类型">函数类型</h3>
<p>在Go语言中，函数是第一类的，可以赋值给变量，当做参数传入传出。</p>
<p>参数名和返回值名可以省略，但是如果要省略，必须所有的参数名或者返回值名全省略，部分省略是不行的。</p>
<p>通过<code>...</code>支持变参，但是变参只能作为最后一个参数。</p>
<p>如果不需要返回值，则不需要定义返回类型。</p>
<p>可以命名函数类型。</p>
<p>以下都是合法的函数类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span>()</div><div class="line"><span class="keyword">func</span>(x <span class="typename">int</span>) <span class="typename">int</span></div><div class="line"><span class="keyword">func</span>(a, _ <span class="typename">int</span>, z <span class="typename">float32</span>) <span class="typename">bool</span></div><div class="line"><span class="keyword">func</span>(a, b <span class="typename">int</span>, z <span class="typename">float32</span>) (<span class="typename">bool</span>)</div><div class="line"><span class="keyword">func</span>(prefix <span class="typename">string</span>, values ...<span class="typename">int</span>)</div><div class="line"><span class="keyword">func</span>(a, b <span class="typename">int</span>, z <span class="typename">float64</span>, opt ...<span class="keyword">interface</span>{}) (success <span class="typename">bool</span>)</div><div class="line"><span class="keyword">func</span>(<span class="typename">int</span>, <span class="typename">int</span>, <span class="typename">float64</span>) (<span class="typename">float64</span>, *[]<span class="typename">int</span>)</div><div class="line"><span class="keyword">func</span>(n <span class="typename">int</span>) <span class="keyword">func</span>(p *T)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Handler <span class="keyword">func</span>(ResponseWriter, *Request)</div></pre></td></tr></table></figure>

<p>注意此处介绍的是函数类型，函数的定义可以指定函数名称，也可以定义匿名函数。</p>
<h3 id="接口类型">接口类型</h3>
<p>Go并没有Java那样的完全的面向对象的类型系统， 而是通过接口和duck typing支持面向对象的编程,也就是会呱呱叫的我们都认为它是鸭子。</p>
<p>一个接口代表一组方法的集合。任何实现了这些方法的类型的值都可以赋值给这个接口变量，我们也可以说这些类型实现了这个接口。</p>
<p>特殊的， <code>interface{}</code>代表一个万能的接口，其它类型都实现了这个接口，有点像Java中的Object类。</p>
<p>接口也可以嵌入,只要保证方法名唯一即可：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> {</div><div class="line">	Read(b Buffer) <span class="typename">bool</span></div><div class="line">	Write(b Buffer) <span class="typename">bool</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> File <span class="keyword">interface</span> {</div><div class="line">	ReadWriter  <span class="comment">// same as adding the methods of ReadWriter</span></div><div class="line">	Locker      <span class="comment">// same as adding the methods of Locker</span></div><div class="line">	Close()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> LockedFile <span class="keyword">interface</span> {</div><div class="line">	Locker</div><div class="line">	File        <span class="comment">// illegal: Lock, Unlock not unique</span></div><div class="line">	Lock()      <span class="comment">// illegal: Lock not unique</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>但是接口不能嵌入它本身，或者递归地嵌入本身。</p>
<p>参考</p>
<ul>
<li><a href="https://medium.com/@matryer/golang-advent-calendar-day-one-duck-typing-a513aaed544d#.m5iuzvhjg" target="_blank" rel="external">https://medium.com/@matryer/golang-advent-calendar-day-one-duck-typing-a513aaed544d#.m5iuzvhjg</a></li>
</ul>
<h3 id="Map类型">Map类型</h3>
<p>Map类型在Go语言中提高到语言规范的级别，在Java只是作为类库中的类实现的。</p>
<p>Map是一组无序的键值对的集合。键的类型相同，值的类型也相同。</p>
<p>Map的变量的定义可以通过下面几种方式,中括号中是键的类型，后边接着是值的类型，键：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span>)</div><div class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span>,<span class="number"> 100</span>)</div><div class="line">m3 := <span class="built_in">new</span>(<span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span>)</div><div class="line"><span class="keyword">var</span> m4 <span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span></div></pre></td></tr></table></figure>

<p>一般通过｀make｀方法生成，可以设置map的初始容量，但是在增加元素的时候容量会快速增加，这也是一般map集合应对元素扩展的时候的方法。</p>
<p>注意， map的键类型是必须是可以比较的(comparable),比如下面的类型都不能作为键值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Func <span class="keyword">func</span>()</div><div class="line"><span class="keyword">type</span> SL []<span class="typename">int</span></div><div class="line"><span class="keyword">type</span> M <span class="keyword">map</span>[<span class="typename">int</span>]<span class="typename">int</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[Func]<span class="typename">int</span>) <span class="comment">//错误</span></div><div class="line">	m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[SL]<span class="typename">int</span>) <span class="comment">//错误</span></div><div class="line">	m3 := <span class="built_in">make</span>(<span class="keyword">map</span>[M]<span class="typename">int</span>) <span class="comment">//错误</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>只有以下类型可以比较，也就是可以应用比较操作符(&gt;、 &lt;、＝＝ 等):</p>
<ul>
<li>布尔型</li>
<li>整型</li>
<li>浮点型</li>
<li>复数</li>
<li>字符串</li>
<li>指针</li>
<li>Channel</li>
<li>接口</li>
<li>struct</li>
<li>数组</li>
</ul>
<p>内置函数<code>delete</code>可以根据key删除map对象的entry, 如果map为nil或者键不存在，delete相当于一个空操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">delete</span>(m, k)  <span class="comment">// remove element m[k] from map m</span></div></pre></td></tr></table></figure>

<p>而往map中增加元素或者查找元素都是通过索引实现的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">m[k] = v</div><div class="line"><span class="keyword">var</span> v = m[k]</div><div class="line">t, ok := m[k]</div></pre></td></tr></table></figure>

<p>参考</p>
<ul>
<li><a href="https://blog.golang.org/go-maps-in-action" target="_blank" rel="external">https://blog.golang.org/go-maps-in-action</a></li>
</ul>
<h3 id="Channel类型">Channel类型</h3>
<p>Channel类型我在另外一篇文章中专门介绍了，本文中就不再赘述: <a href="http://colobu.com/2016/04/14/Golang-Channels/" target="_blank" rel="external">Go Channel 详解</a></p>
<h3 id="类型的零值">类型的零值</h3>
<p>当一个值被创建的时候，无论你是用什么方法，声明或者new方法创建，如果没有显示地初始化，Go就会给它分配一个零值(zero value)。</p>
<ul>
<li>布尔型: false</li>
<li>整数: 0</li>
<li>浮点数: 0.0</li>
<li>字符串: &quot;&quot;</li>
<li>指针: nil</li>
<li>函数: nil</li>
<li>接口: nil</li>
<li>slice: nil</li>
<li>channel: nil</li>
<li>map: nil</li>
</ul>
<p>值得注意的是字符串，从Java转过来的程序员会以为字符串的零值是nil，其实不是，字符串的零值是空的字符串。</p>
<h3 id="类型的比较">类型的比较</h3>
<p>如何判断两个对象的类型是一样的？本节我们来讨论类型一致性(Type identity, 类型完全相同)。</p>
<p>两个类型，要么类型一致，要不类型不同。</p>
<p>1、如果两个命名类型传承自同样的<a href="https://golang.org/ref/spec#Type_declarations" target="_blank" rel="external">TypeSpec</a>)，则它们是类型一致的。这是显然地，因为是自己和自己比较<br>2、一个命名类型和一个未命名类型肯定是类型不一致</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> (</div><div class="line">	T0 []<span class="typename">string</span></div><div class="line">	T1 []<span class="typename">string</span></div><div class="line">	T2 <span class="keyword">struct</span>{ a, b <span class="typename">int</span> }</div><div class="line">)</div></pre></td></tr></table></figure>

<p><code>T0</code>、<code>T1</code>、 <code>T2</code>和 <code>[]string</code>都是不同的。</p>
<p>对于两个未命名类型，如果类型的声明一致，则类型一致，具体如下：<br>1、两个数组类型一致， 如果它们的元素的类型是类型一致并且数组长度相同<br>2、两个slice类型一致，如果它们的元素的类型是类型一致<br>3、两个struct类型一致，如果它们拥有相同的字段序列，并且相应的字段的名字相同而且类型一致，并且tag相同。两个匿名字段被认为有相同的名字。不同包下的Lower-case字段总是不同的<br>4、两个指针类型相同，如果它们指向的对象的类型是类型一致的<br>5、两个函数的类型相同，如果它们的参数和返回值的数量一致，并且类型一致，都有变参或者都没有。不要求参数名和返回名一致<br>6、两个接口类型相同，如果它们的方法集相同，方法名相同，方法的类型一致。不同包下的Lower-case方法名是不同的。方法声明的顺序无关<br>7、两个map类型相同，如果它们的key和value的类型一致<br>8、两个channel类型一致，如果它们的值的类型一致，并且有相同的方法(direction)</p>
<p>对于下列类型:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> (</div><div class="line">	T0 []<span class="typename">string</span></div><div class="line">	T1 []<span class="typename">string</span></div><div class="line">	T2 <span class="keyword">struct</span>{ a, b <span class="typename">int</span> }</div><div class="line">	T3 <span class="keyword">struct</span>{ a, c <span class="typename">int</span> }</div><div class="line">	T4 <span class="keyword">func</span>(<span class="typename">int</span>, <span class="typename">float64</span>) *T0</div><div class="line">	T5 <span class="keyword">func</span>(x <span class="typename">int</span>, y <span class="typename">float64</span>) *[]<span class="typename">string</span></div><div class="line">)</div></pre></td></tr></table></figure>

<p>下列的类型是一致的：</p>
<ul>
<li><code>T0</code> 和 <code>T0</code></li>
<li><code>[]int</code> 和<code>[]int</code></li>
<li><code>struct{ a, b *T5 }</code> 和 <code>struct{ a, b *T5 }</code></li>
<li><code>func(x int, y float64) *[]string</code> 和 <code>func(int, float64) (result *[]string)</code></li>
</ul>
<p>但是<code>T0</code> 和 <code>T1</code> 类型不同; <code>func(int, float64) *T0</code> 和 <code>func(x int, y float64) *[]string</code> 也不同， 因为 <code>T0</code> 和 <code>[]string</code>不同。</p>
<p>这也容易理解，不同的类型可以拥有不同的方法集。</p>
<h3 id="赋值">赋值</h3>
<p>一个值x只有在下述情况下才能指派给类型<code>T</code> (类型为T的一个变量):</p>
<ul>
<li>x的类型和<code>T</code>类型一致。 相同类型的值当然可以赋值给相同类型的变量。</li>
<li>x的类型<code>V</code>和 类型<code>T</code>的底层类型一致， 并且至少<code>V</code>和<code>T</code>中的一个是未命名类型。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> S1 <span class="keyword">struct</span> {</div><div class="line">	Name <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> s2 = <span class="keyword">struct</span> {</div><div class="line">	Name <span class="typename">string</span></div><div class="line">}{<span class="string">"hello"</span>}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> s1 S1 = s2</div><div class="line">	fmt.Printf(<span class="string">"%#v\n"</span>, s1)</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li><code>T</code> 是一个接口, 而 x 实现了接口<code>T</code>。</li>
<li>x 是双向的channel, 而 <code>T</code>是一个channel类型，并且 x 的类型 <code>V</code> 和 <code>T</code>的元素的类型是类型一致的，并且 <code>V</code> 和 <code>T</code>至少有一个是未命名类型。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> CH1 *(<span class="keyword">chan</span> <span class="typename">int</span>)</div><div class="line"></div><div class="line"><span class="keyword">var</span> ch2 = <span class="built_in">new</span>(<span class="keyword">chan</span> <span class="typename">int</span>)</div><div class="line"></div><div class="line"><span class="keyword">type</span> CH3 *(<span class="keyword">chan</span> <span class="typename">int</span>)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> ch1 CH1 = ch2</div><div class="line">	<span class="comment">//var ch3 CH3 = ch2</span></div><div class="line">	<span class="comment">//ch1 = ch3</span></div><div class="line">	fmt.Printf(<span class="string">"%#v\n"</span>, ch1)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上例中ch2可以赋值给<code>CH1</code>、<code>CH2</code>类型的变量，因为ch2的类型是未命令类型,但是ch3就不可以赋值ch1，因为它们两个的类型都是命名类型。</p>
<ul>
<li>x 是预声明的值 <code>nil</code>,  <code>T</code>是一个指针、函数、slice、map、channel 或者接口的话，可以赋值，<code>nil</code>是这些类型的零值。</li>
<li>x 是一个未标明类型的常量，可以作为类型<code>T</code>的值。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> c =<span class="number"> 100</span></div><div class="line"><span class="keyword">var</span> _ <span class="typename">int</span> = c</div><div class="line"><span class="keyword">var</span> _ <span class="typename">int64</span> = c</div><div class="line"><span class="keyword">var</span> _ <span class="typename">int8</span> = c</div><div class="line"><span class="keyword">var</span> _ <span class="typename">float32</span> = c</div><div class="line"><span class="keyword">var</span> _ <span class="typename">float64</span> = c</div></pre></td></tr></table></figure>

<h3 id="代码块(block)">代码块(block)</h3>
<p>代码块是用括号&quot;{}&quot;括起来的包含声明和语句的一段代码。可以为空。</p>
<p>事实上当你编写Go代码的时候，就包含了隐式的代码块:</p>
<ul>
<li>全局的语句块包含所有的源码</li>
<li>package包含本package中的源码</li>
<li>每个文件包含一个文件代码块,它包含本文件中的所有源码</li>
<li><code>if</code>、<code>for</code> 和 <code>switch</code>语句包含在它们的隐式代码块中</li>
<li><code>switch</code>、<code>select</code>中的每一个clause语句都是一个隐式代码块</li>
</ul>
<p>代码块最重要的特性就是scope,以后讲。</p>
<blockquote>
<p>声明一下， 本系列的第一部分基本是按照Go语言的规范编写的，大量参考了Go语言规范的内容</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文介绍Go的类型系统,以及类型的比较和语句块。</p>
<p>Go语言包含11种类型，你应该很熟悉了，下面让我们再深入的了解一下每种类型的细节。</p>
<ul>
<li>布尔类型</li>
<li>数值类型</li>
<li>字符串类型</li>
<li>数组类型</li>
<li>Slice类型</li>
<li>Struct类型</li>
<li>指针类型</li>
<li>函数类型</li>
<li>接口类型</li>
<li>Map类型</li>
<li>Channel类型</li>
</ul>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
</feed>
